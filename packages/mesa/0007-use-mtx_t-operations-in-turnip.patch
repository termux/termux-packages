--- a/src/freedreno/vulkan/tu_shader.cc
+++ b/src/freedreno/vulkan/tu_shader.cc
@@ -1980,10 +1980,10 @@
       size += vpc_size;
    }
 
-   pthread_mutex_lock(&dev->pipeline_mutex);
+   mtx_lock(&dev->pipeline_mutex);
    VkResult result = tu_suballoc_bo_alloc(&shader->bo, &dev->pipeline_suballoc,
                                           size * 4, 128);
-   pthread_mutex_unlock(&dev->pipeline_mutex);
+   mtx_unlock(&dev->pipeline_mutex);
 
    if (result != VK_SUCCESS)
       return result;
@@ -2013,9 +2013,9 @@
 
    result = tu_setup_pvtmem(dev, shader, &pvtmem_config, pvtmem_size, per_wave);
    if (result != VK_SUCCESS) {
-      pthread_mutex_lock(&dev->pipeline_mutex);
+      mtx_lock(&dev->pipeline_mutex);
       tu_suballoc_bo_free(&dev->pipeline_suballoc, &shader->bo);
-      pthread_mutex_unlock(&dev->pipeline_mutex);
+      mtx_unlock(&dev->pipeline_mutex);
       return result;
    }
 
@@ -2419,10 +2419,10 @@
    if (!shader)
       return VK_ERROR_OUT_OF_HOST_MEMORY;
 
-   pthread_mutex_lock(&dev->pipeline_mutex);
+   mtx_lock(&dev->pipeline_mutex);
    VkResult result = tu_suballoc_bo_alloc(&shader->bo, &dev->pipeline_suballoc,
                                           32 * 4, 128);
-   pthread_mutex_unlock(&dev->pipeline_mutex);
+   mtx_unlock(&dev->pipeline_mutex);
 
    if (result != VK_SUCCESS) {
       vk_free(&dev->vk.alloc, shader);
@@ -2528,9 +2528,9 @@
 {
    tu_cs_finish(&shader->cs);
 
-   pthread_mutex_lock(&dev->pipeline_mutex);
+   mtx_lock(&dev->pipeline_mutex);
    tu_suballoc_bo_free(&dev->pipeline_suballoc, &shader->bo);
-   pthread_mutex_unlock(&dev->pipeline_mutex);
+   mtx_unlock(&dev->pipeline_mutex);
 
    if (shader->pvtmem_bo)
       tu_bo_finish(dev, shader->pvtmem_bo);
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -2648,12 +2648,12 @@ wsi_wl_swapchain_wait_for_present2(struct wsi_swapchain *wsi_chain,
       return result;
 
    while (1) {
-      err = pthread_mutex_lock(&chain->present_ids.lock);
+      err = mtx_lock(&chain->present_ids.lock);
       if (err != 0)
          return VK_ERROR_OUT_OF_DATE_KHR;
 
       bool completed = chain->present_ids.max_completed >= present_id;
-      pthread_mutex_unlock(&chain->present_ids.lock);
+      mtx_unlock(&chain->present_ids.lock);
 
       if (completed)
          return VK_SUCCESS;
