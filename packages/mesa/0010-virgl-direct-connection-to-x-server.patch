+++ ./src/virtio/virtio-gpu/virgl_hw.h
@@ -587,6 +587,7 @@
 #define VIRGL_CAP_V2_GROUP_VOTE           (1 << 15)
 #define VIRGL_CAP_V2_MIRROR_CLAMP_TO_EDGE (1 << 16)
 #define VIRGL_CAP_V2_MIRROR_CLAMP         (1 << 17)
+#define VIRGL_CAP_V2_DIRECT_CONNECTION_TO_X_SERVER (1u << 31)
 
 /* virgl bind flags - these are compatible with mesa 10.5 gallium.
  * but are fixed, no other should be passed to virgl either.
+++ ./src/virtio/vtest/vtest_protocol.h
@@ -84,6 +84,8 @@
 #define VCMD_SUBMIT_CMD2 24
 #endif /* VIRGL_RENDERER_UNSTABLE_APIS */
 
+#define VCMD_DRAW_TO_X_SERVER_DRAWABLE 48
+
 #define VCMD_RES_CREATE_SIZE 10
 #define VCMD_RES_CREATE_RES_HANDLE 0 /* must be 0 since protocol version 3 */
 #define VCMD_RES_CREATE_TARGET 1
@@ -243,4 +245,6 @@
 
 #endif /* VIRGL_RENDERER_UNSTABLE_APIS */
 
+#define VCMD_DRAW_TO_X_SERVER_DRAWABLE_SIZE 2
+
 #endif /* VTEST_PROTOCOL */
+++ ./src/gallium/winsys/virgl/vtest/virgl_vtest_winsys.h
@@ -50,6 +50,7 @@
    mtx_t mutex;
 
    unsigned protocol_version;
+   unsigned direct_x_server_connection_supported;
 };
 
 struct virgl_hw_res {
@@ -154,4 +155,6 @@
 
 int virgl_vtest_busy_wait(struct virgl_vtest_winsys *vws, int handle,
                           int flags);
+
+int virgl_vtest_send_draw_to_x_server_drawable(struct virgl_vtest_winsys *vws, uint32_t res_id, uint32_t handle);
 #endif
+++ ./src/gallium/winsys/virgl/vtest/virgl_vtest_socket.c
@@ -544,3 +544,17 @@
    assert(ret);
    return result[0];
 }
+
+int virgl_vtest_send_draw_to_x_server_drawable(struct virgl_vtest_winsys *vws, uint32_t res_id, uint32_t handle)
+{
+   uint32_t vtest_hdr[VTEST_HDR_SIZE];
+   uint32_t cmd[2];
+   vtest_hdr[VTEST_CMD_LEN] = 2;
+   vtest_hdr[VTEST_CMD_ID] = VCMD_DRAW_TO_X_SERVER_DRAWABLE;
+
+   cmd[0] = res_id;
+   cmd[1] = handle;
+   virgl_block_write(vws->sock_fd, &vtest_hdr, sizeof(vtest_hdr));
+   virgl_block_write(vws->sock_fd, &cmd, sizeof(cmd));
+   return 0;
+}
+++ ./src/gallium/include/mesa_interface.h	2024-11-24 21:33:02.048266004 +0200
@@ -644,6 +644,8 @@
     unsigned char (*getImageShm2)(__DRIdrawable *readable,
                                   int x, int y, int width, int height,
                                   int shmid, void *loaderPrivate);
+
+    uint32_t (*getDrawable)(void *loaderPrivate);
 };
 
 /**
+++ ./src/egl/drivers/dri2/platform_x11.c	2024-11-26 21:13:32.850492116 +0200
@@ -365,6 +365,12 @@
    xcb_shm_detach(dri2_dpy->conn, shm_seg);
 }
 
+static uint32_t
+swrastGetDrawable(void *loaderPrivate)
+{
+   return (uintptr_t) ((struct dri2_egl_surface*) loaderPrivate)->base.NativeSurface;
+}
+
 static xcb_screen_t *
 get_xcb_screen(xcb_screen_iterator_t iter, int screen)
 {
@@ -1587,6 +1593,7 @@
    .putImage = swrastPutImage,
    .putImage2 = swrastPutImage2,
    .getImage = swrastGetImage,
+   .getDrawable = swrastGetDrawable,
 };
 
 static const __DRIswrastLoaderExtension swrast_loader_shm_extension = {
@@ -1599,6 +1606,7 @@
    .getImage = swrastGetImage,
    .getImage2 = swrastGetImage2,
    .getImageShm = swrastGetImageShm,
+   .getDrawable = swrastGetDrawable,
 };
 
 static_assert(sizeof(struct kopper_vk_surface_create_storage) >=
+++ ./src/glx/drisw_glx.c
@@ -349,6 +349,12 @@
    swrastGetImageShm2(read, x, y, w, h, shmid, loaderPrivate);
 }
 
+static uint32_t
+swrastGetDrawable(void *loaderPrivate)
+{
+   return ((struct drisw_drawable*) loaderPrivate)->base.xDrawable;
+}
+
 static const __DRIswrastLoaderExtension swrastLoaderExtension_shm = {
    .base = {__DRI_SWRAST_LOADER, 6 },
 
@@ -361,6 +367,7 @@
    .getImageShm         = swrastGetImageShm,
    .putImageShm2        = swrastPutImageShm2,
    .getImageShm2        = swrastGetImageShm2,
+   .getDrawable         = swrastGetDrawable,
 };
 
 static const __DRIswrastLoaderExtension swrastLoaderExtension = {
@@ -371,6 +378,7 @@
    .getImage            = swrastGetImage,
    .putImage2           = swrastPutImage2,
    .getImage2           = swrastGetImage2,
+   .getDrawable         = swrastGetDrawable,
 };
 
 static_assert(sizeof(struct kopper_vk_surface_create_storage) >= sizeof(VkXcbSurfaceCreateInfoKHR), "");
+++ ./src/gallium/include/frontend/drisw_api.h
@@ -22,6 +22,7 @@
    void (*put_image_shm) (struct dri_drawable *dri_drawable,
                           int shmid, char *shmaddr, unsigned offset, unsigned offset_x,
                           int x, int y, unsigned width, unsigned height, unsigned stride);
+   uint32_t (*get_drawable) (struct dri_drawable *dri_drawable);
 };
 
 #endif
+++ ./src/gallium/frontends/dri/drisw.c
@@ -188,6 +188,13 @@
    put_image_shm(drawable, shmid, shmaddr, offset, offset_x, x, y, width, height, stride);
 }
 
+static inline uint32_t
+drisw_get_drawable(struct dri_drawable *drawable)
+{
+   const __DRIswrastLoaderExtension *loader = drawable->screen->swrast_loader;
+   return loader->getDrawable(drawable->loaderPrivate);
+}
+
 static inline void
 drisw_present_texture(struct pipe_context *pipe, struct dri_drawable *drawable,
                       struct pipe_resource *ptex, unsigned nrects, struct pipe_box *sub_box)
@@ -543,12 +550,14 @@
 };
 
 static const struct drisw_loader_funcs drisw_lf = {
+   .get_drawable = drisw_get_drawable,
    .get_image = drisw_get_image,
    .put_image = drisw_put_image,
    .put_image2 = drisw_put_image2
 };
 
 static const struct drisw_loader_funcs drisw_shm_lf = {
+   .get_drawable = drisw_get_drawable,
    .get_image = drisw_get_image,
    .put_image = drisw_put_image,
    .put_image2 = drisw_put_image2,
+++ ./src/gallium/include/frontend/sw_winsys.h
@@ -146,6 +146,8 @@
                                    unsigned width, unsigned height,
                                    unsigned stride,
                                    void *data );
+
+   uint32_t (*displaytarget_get_drawable)( struct sw_winsys *ws, void *context_private);
 };
 
 
+++ ./src/gallium/winsys/sw/dri/dri_sw_winsys.c	2024-11-24 21:56:05.806775337 +0200
@@ -380,6 +380,13 @@
    FREE(winsys);
 }
 
+static uint32_t
+dri_sw_displaytarget_get_drawable(struct sw_winsys *ws, void *priv)
+{
+   struct dri_sw_winsys *dri_sw_ws = dri_sw_winsys(ws);
+   return dri_sw_ws->lf->get_drawable((struct dri_drawable*) priv);
+}
+
 struct sw_winsys *
 dri_create_sw_winsys(const struct drisw_loader_funcs *lf)
 {
@@ -406,6 +413,7 @@
    ws->base.displaytarget_unmap = dri_sw_displaytarget_unmap;
 
    ws->base.displaytarget_display = dri_sw_displaytarget_display;
+   ws->base.displaytarget_get_drawable = dri_sw_displaytarget_get_drawable;
 
    return &ws->base;
 }
+++ ./src/gallium/winsys/virgl/vtest/virgl_vtest_winsys.c
@@ -593,6 +593,8 @@
    // vtest doesn't support that
    if (caps->caps.v2.capability_bits_v2 & VIRGL_CAP_V2_COPY_TRANSFER_BOTH_DIRECTIONS)
       caps->caps.v2.capability_bits_v2 &= ~VIRGL_CAP_V2_COPY_TRANSFER_BOTH_DIRECTIONS;
+   if (caps->caps.v2.capability_bits_v2 & VIRGL_CAP_V2_DIRECT_CONNECTION_TO_X_SERVER)
+      vtws->direct_x_server_connection_supported = true;
    return ret;
 }
 
@@ -647,6 +649,12 @@
    if (!res->dt)
       return;
 
+   if (vtws->direct_x_server_connection_supported) {
+      virgl_vtest_send_draw_to_x_server_drawable(vtws, res->res_handle, vtws->sws->displaytarget_get_drawable(vtws->sws, winsys_drawable_handle));
+      virgl_vtest_busy_wait(vtws, res->res_handle, VCMD_BUSY_WAIT_FLAG_WAIT);
+      return;
+   }
+
    memset(&box, 0, sizeof(box));
 
    if (sub_box) {
