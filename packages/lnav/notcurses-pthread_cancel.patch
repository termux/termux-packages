# Similar patches from notcurses directory but without hunks in src/demo/

diff --git a/src/third-party/notcurses/src/lib/fd.c b/src/third-party/notcurses/src/lib/fd.c
index ea5fd04..66b00b0 100644
--- a/src/third-party/notcurses/src/lib/fd.c
+++ b/src/third-party/notcurses/src/lib/fd.c
@@ -23,6 +23,15 @@
 #define NCPOLLEVENTS (POLLIN)
 #endif
 
+#ifdef __ANDROID__
+#define PTHREAD_CANCELED ((void *)-1)
+static void
+thread_signal_handler(int signum)
+{
+  pthread_exit(PTHREAD_CANCELED);
+}
+#endif
+
 // release the memory and fd, but don't join the thread (since we might be
 // getting called within the thread's context, on a callback).
 static int
@@ -85,6 +94,15 @@ fdthread(ncfdplane* ncfp, int pidfd){
 
 static void *
 ncfdplane_thread(void* vncfp){
+#ifdef __ANDROID__
+  struct sigaction actions;
+  memset(&actions, 0, sizeof(actions));
+  sigemptyset(&actions.sa_mask);
+  actions.sa_flags = 0;
+  actions.sa_handler = thread_signal_handler;
+  sigaction(SIGUSR2, &actions, NULL);
+#endif
+
   fdthread(vncfp, -1);
   return NULL;
 }
@@ -266,6 +284,15 @@ kill_and_wait_subproc(pid_t pid, int pidfd, int* status){
 // need a poll on both main fd and pidfd
 static void *
 ncsubproc_thread(void* vncsp){
+#ifdef __ANDROID__
+  struct sigaction actions;
+  memset(&actions, 0, sizeof(actions));
+  sigemptyset(&actions.sa_mask);
+  actions.sa_flags = 0;
+  actions.sa_handler = thread_signal_handler;
+  sigaction(SIGUSR2, &actions, NULL);
+#endif
+
   int* status = malloc(sizeof(*status));
   if(status){
     ncsubproc* ncsp = vncsp;
@@ -287,6 +314,15 @@ ncsubproc_thread(void* vncsp){
 // wake up our poll()ing thread).
 static void *
 ncsubproc_waiter(void* vncsp){
+#ifdef __ANDROID__
+  struct sigaction actions;
+  memset(&actions, 0, sizeof(actions));
+  sigemptyset(&actions.sa_mask);
+  actions.sa_flags = 0;
+  actions.sa_handler = thread_signal_handler;
+  sigaction(SIGUSR2, &actions, NULL);
+#endif
+
   ncsubproc* ncsp = vncsp;
   int* status = malloc(sizeof(*status));
   pid_t pid;
@@ -425,7 +461,11 @@ int ncsubproc_destroy(ncsubproc* n){
     // then exits. don't try to cancel the thread in that case; rely instead on
     // killing the subprocess.
     if(n->pidfd < 0){
+#ifndef __ANDROID__
       pthread_cancel(n->nfp->tid);
+#else
+      pthread_kill(n->nfp->tid, SIGUSR2);
+#endif
       // shouldn't need a cancellation of waittid thanks to SIGKILL
       pthread_join(n->waittid, &vret);
     }
diff --git a/src/third-party/notcurses/src/lib/in.c b/src/third-party/notcurses/src/lib/in.c
index 3074563..36cddbc 100644
--- a/src/third-party/notcurses/src/lib/in.c
+++ b/src/third-party/notcurses/src/lib/in.c
@@ -8,6 +8,15 @@
 #include "render.h"
 #include "in.h"
 
+#ifdef __ANDROID__
+#define PTHREAD_CANCELED ((void *)-1)
+static void
+thread_signal_handler(int signum)
+{
+  pthread_exit(PTHREAD_CANCELED);
+}
+#endif
+
 // Notcurses takes over stdin, and if it is not connected to a terminal, also
 // tries to make a connection to the controlling terminal. If such a connection
 // is made, it will read from that source (in addition to stdin). We dump one or
@@ -2735,6 +2744,14 @@ read_inputs_nblock(inputctx* ictx){
 static void*
 input_thread(void* vmarshall){
   setup_alt_sig_stack();
+#ifdef __ANDROID__
+  struct sigaction actions;
+  memset(&actions, 0, sizeof(actions));
+  sigemptyset(&actions.sa_mask);
+  actions.sa_flags = SA_ONSTACK;
+  actions.sa_handler = thread_signal_handler;
+  sigaction(SIGUSR2, &actions, NULL);
+#endif
   inputctx* ictx = vmarshall;
   if(prep_all_keys(ictx) || build_cflow_automaton(ictx)){
     ictx->failed = true;
diff --git a/src/third-party/notcurses/src/lib/internal.h b/src/third-party/notcurses/src/lib/internal.h
index 66a89b3..dbb1108 100644
--- a/src/third-party/notcurses/src/lib/internal.h
+++ b/src/third-party/notcurses/src/lib/internal.h
@@ -1854,9 +1854,13 @@ tty_check(int fd){
 // have already exited), and then join it (an error here is propagated).
 static inline int
 cancel_and_join(const char* name, pthread_t tid, void** res){
+#ifndef __ANDROID__
   if(pthread_cancel(tid)){
     logerror("couldn't cancel %s thread", name); // tid might have died
   }
+#else
+  pthread_kill(tid, SIGUSR2);
+#endif
   if(pthread_join(tid, res)){
     logerror("error joining %s thread", name);
     return -1;
