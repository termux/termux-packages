#!/bin/env bash
# set -x

# remove prefix from non proot build 

# repack_to_proot dpkg

TERMUX_PKG_REPACK=false

repack_to_proot(){
	local app=$1

down load
un pack

termux_replace_prefix $PREFIX ""

# if bionic
# 	patchelf --set-rpath /bionic $elf
# if glibc
# patchelf --set-interpreter /usr/lib/ld-linux-aarch64.so.1 $elf

repack
upload
}

termux_replace_prefix() {
	set +e
	local  old new count
	old=$1
	new=$2

	count=$(ls -R|wc|tr -s " "|cut -f2 -d" ")
	test $count -gt 200 && echo $(pwd) contains $count files. aborting && return
	printf '%s\0' "${replaced_prefix[@]}" | grep -q -F -x -z -- "$old" && return
	replaced_prefix+=($old)
	test $old = "$new" && return

	echo termux - massage - replacing prefix $old with $new ...
	while IFS= read -r f; do
		# echo $f
		if file $f | grep -q "ASCII"; then
			# echo found text file $f
			if grep -q $old $f; then
				if ! $TERMUX_PKG_REPACK; then
					echo prefix found inside $f . this should not happen . add -f -C to ignore and replace
					$TERMUX_FORCE_BUILD || exit
				fi
				sed -i "s,$old,$new,g" $f
			fi
		fi

		if file $f | grep -q "ELF"; then
			# echo found bin file $f
			(patchelf --set-interpreter $PATH_DYNAMIC_LINKER $f)
			if $TERMUX_PKG_REPACK && [ "$TERMUX_PACKAGE_LIBRARY" = "bionic" ]; then
				(patchelf --set-rpath /bionic $f)
			fi
			if strings $f | grep -q $old; then
				if ! $TERMUX_PKG_REPACK; then
					echo prefix found inside $f . this should not happen . add -f -C to ignore and replace
					$TERMUX_FORCE_BUILD || exit
				fi
				replace_in_binary $f $old "$new"
			fi
		fi

	done < <(find -type f)
	# exit
	set -e
}

# by Johan hedin
replace_in_binary() {
local FILE="$1"
local PATTERN="$2"
local REPLACEMENT="$3"

# Find all unique strings in FILE that contain the pattern 
STRINGS=$(strings ${FILE} | grep ${PATTERN} | sort -u -r)

if [ "${STRINGS}" = "" ] ; then
	echo "File '${FILE}' not contain strings with '${PATTERN}' in them:"
	return
fi

echo "File '${FILE}' contain strings with '${PATTERN}' in them:"

for OLD_STRING in ${STRINGS} ; do
	# Create the new string with a simple bash-replacement
	NEW_STRING=${OLD_STRING//${PATTERN}/${REPLACEMENT}}

	# Create null terminated ASCII HEX representations of the strings
	OLD_STRING_HEX="$(echo -n ${OLD_STRING} | xxd -g 0 -u -ps -c 256)00"
	NEW_STRING_HEX="$(echo -n ${NEW_STRING} | xxd -g 0 -u -ps -c 256)00"

	if [ ${#NEW_STRING_HEX} -le ${#OLD_STRING_HEX} ] ; then
		# Pad the replacement string with null terminations so the
		# length matches the original string
		while [ ${#NEW_STRING_HEX} -lt ${#OLD_STRING_HEX} ] ; do
			NEW_STRING_HEX="${NEW_STRING_HEX}00"
		done

		# Now, replace every occurrence of OLD_STRING with NEW_STRING 
		echo -n "Replacing ${OLD_STRING} with ${NEW_STRING}... "
		hexdump -ve '1/1 "%.2X"' ${FILE} | \
			sed "s/${OLD_STRING_HEX}/${NEW_STRING_HEX}/g" | \
			xxd -r -p > ${FILE}.tmp
					chmod --reference ${FILE} ${FILE}.tmp
					mv ${FILE}.tmp ${FILE}
					echo "Done!"
				else
					echo "New string '${NEW_STRING}' is longer than old" \
						"string '${OLD_STRING}'. Skipping."
	fi
done
}

