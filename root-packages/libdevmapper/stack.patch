Fixes errors like:
/storage/termux-build/_cache/android-r21d-api-24-v3/bin/../sysroot/usr/include/linux/sched.h:53:17: error: expected parameter declarator
  __aligned_u64 stack;

There's probably a better way to fix this. This patch will be annoying to maintain..

diff -u -r ../LVM2.2.03.16.orig/configure ./configure
diff -u -r ../LVM2.2.03.16.orig/daemons/dmeventd/dmeventd.c ./daemons/dmeventd/dmeventd.c
--- ../LVM2.2.03.16.orig/daemons/dmeventd/dmeventd.c	2022-05-18 18:24:20.000000000 +0200
+++ ./daemons/dmeventd/dmeventd.c	2022-06-30 16:18:13.510063540 +0200
@@ -729,7 +729,7 @@
 				message_data->id, getpid(),
 				_foreground ? "no" : "yes",
 				_systemd_activation ? "systemd" : "direct")) < 0) {
-		stack;
+		log_stack;
 		return -ENOMEM;
 	}
 
@@ -1175,7 +1175,7 @@
 
 	if (!(dso_data = _lookup_dso(message_data)) &&
 	    !(dso_data = _load_dso(message_data))) {
-		stack;
+		log_stack;
 #ifdef ELIBACC
 		ret = ELIBACC;
 #else
@@ -1195,12 +1195,12 @@
 		/* Only creating thread during event processing
 		 * Remaining initialization happens within monitoring thread */
 		if (!(thread = _alloc_thread_status(message_data, dso_data))) {
-			stack;
+			log_stack;
 			return -ENOMEM;
 		}
 
 		if ((ret = _create_thread(thread))) {
-			stack;
+			log_stack;
 			_free_thread_status(thread);
 			return -ret;
 		}
@@ -1220,7 +1220,7 @@
 	   almost as good as dead already... */
 	if ((message_data->events_field & DM_EVENT_TIMEOUT) &&
 	    (ret = _register_for_timeout(thread))) {
-		stack;
+		log_stack;
 		_unregister_for_event(message_data);
 	}
 
@@ -1635,7 +1635,7 @@
 			free(answer);
 		}
 	} else if (msg->cmd != DM_EVENT_CMD_ACTIVE && !_parse_message(&message_data)) {
-		stack;
+		log_stack;
 		ret = -EINVAL;
 	} else
 		ret = _handle_request(msg, &message_data);
@@ -1670,7 +1670,7 @@
 	_do_process_request(&msg);
 
 	if (!_client_write(fifos, &msg))
-		stack;
+		log_stack;
 
 	DEBUGLOG("<<< CMD:%s (0x%x) completed (result %d).", decode_cmd(cmd), cmd, msg.cmd);
 
diff -u -r ../LVM2.2.03.16.orig/daemons/dmeventd/libdevmapper-event.c ./daemons/dmeventd/libdevmapper-event.c
--- ../LVM2.2.03.16.orig/daemons/dmeventd/libdevmapper-event.c	2022-05-18 18:24:20.000000000 +0200
+++ ./daemons/dmeventd/libdevmapper-event.c	2022-06-30 16:18:13.513396942 +0200
@@ -379,7 +379,7 @@
 	 * read status return code from daemon.
 	 */
 	if (!_daemon_write(fifos, msg)) {
-		stack;
+		log_stack;
 		free(msg->data);
 		msg->data = NULL;
 		return -EIO;
@@ -390,7 +390,7 @@
 		msg->data = NULL;
 
 		if (!_daemon_read(fifos, msg)) {
-			stack;
+			log_stack;
 			return -EIO;
 		}
 	} while (!_check_message_id(msg));
diff -u -r ../LVM2.2.03.16.orig/daemons/dmeventd/plugins/thin/dmeventd_thin.c ./daemons/dmeventd/plugins/thin/dmeventd_thin.c
--- ../LVM2.2.03.16.orig/daemons/dmeventd/plugins/thin/dmeventd_thin.c	2022-05-18 18:24:20.000000000 +0200
+++ ./daemons/dmeventd/plugins/thin/dmeventd_thin.c	2022-06-30 16:18:13.416728276 +0200
@@ -185,7 +185,7 @@
 		if (_use_policy(dmt, state))
 			goto out;
 
-		stack;
+		log_stack;
 
 		/*
 		 * Rather update oldish status
diff -u -r ../LVM2.2.03.16.orig/daemons/dmeventd/plugins/vdo/dmeventd_vdo.c ./daemons/dmeventd/plugins/vdo/dmeventd_vdo.c
--- ../LVM2.2.03.16.orig/daemons/dmeventd/plugins/vdo/dmeventd_vdo.c	2022-05-18 18:24:20.000000000 +0200
+++ ./daemons/dmeventd/plugins/vdo/dmeventd_vdo.c	2022-06-30 16:18:13.506730138 +0200
@@ -178,7 +178,7 @@
 		if (_use_policy(dmt, state))
 			goto out;
 
-		stack;
+		log_stack;
 
 		if (!(new_dmt = dm_task_create(DM_DEVICE_STATUS)))
 			goto_out;
diff -u -r ../LVM2.2.03.16.orig/device_mapper/ioctl/libdm-iface.c ./device_mapper/ioctl/libdm-iface.c
--- ../LVM2.2.03.16.orig/device_mapper/ioctl/libdm-iface.c	2022-05-18 18:24:20.000000000 +0200
+++ ./device_mapper/ioctl/libdm-iface.c	2022-06-30 16:18:13.223390943 +0200
@@ -565,7 +565,7 @@
 
 	r = dm_task_run(task);
 	if (!dm_task_get_driver_version(task, version, size))
-		stack;
+		log_stack;
 	dm_task_destroy(task);
 	_log_suppress = 0;
 
@@ -1511,12 +1511,12 @@
 			continue;
 		if (!dm_task_set_name(dmt, dirent->d_name)) {
 			r = 0;
-			stack;
+			log_stack;
 			continue; /* try next name */
 		}
 		if (!dm_task_run(dmt)) {
 			r = 0;
-			stack;  /* keep going */
+			log_stack;  /* keep going */
 		}
 	}
 
@@ -1637,14 +1637,14 @@
 
 	/* Next load the table */
 	if (!(task = dm_task_create(DM_DEVICE_RELOAD))) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
 
 	/* Copy across relevant fields */
 	if (dmt->dev_name && !dm_task_set_name(task, dmt->dev_name)) {
-		stack;
+		log_stack;
 		dm_task_destroy(task);
 		_udev_complete(dmt);
 		goto revert;
@@ -1663,7 +1663,7 @@
 	dm_task_destroy(task);
 
 	if (!r) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
@@ -1697,7 +1697,7 @@
 		if (!dm_task_set_cookie(dmt, &cookie,
 					(dmt->event_nr & DM_UDEV_FLAGS_MASK) >>
 					DM_UDEV_FLAGS_SHIFT))
-			stack; /* keep going */
+			log_stack; /* keep going */
 	}
 
 	if (!dm_task_run(dmt))
@@ -2107,7 +2107,7 @@
 
 	if (dmt->record_timestamp)
 		if (!dm_timestamp_get(_dm_ioctl_timestamp))
-			stack;
+			log_stack;
 
 	if (r < 0 && dmt->expected_errno != errno) {
 		dmt->ioctl_errno = errno;
diff -u -r ../LVM2.2.03.16.orig/device_mapper/libdm-common.c ./device_mapper/libdm-common.c
--- ../LVM2.2.03.16.orig/device_mapper/libdm-common.c	2022-05-18 18:24:20.000000000 +0200
+++ ./device_mapper/libdm-common.c	2022-06-30 16:18:13.143389288 +0200
@@ -1812,7 +1812,7 @@
 	while (!feof(minfo) && fgets(buffer, sizeof(buffer), minfo))
 		if (!_mountinfo_parse_line(buffer, &maj, &min, target) ||
 		    !read_fn(buffer, maj, min, target, cb_data)) {
-			stack;
+			log_stack;
 			r = 0;
 			break;
 		}
@@ -2057,7 +2057,7 @@
 		if (_sysfs_get_dm_name(major, minor, buf, buf_size))
 			return 1;
 		else
-			stack;
+			log_stack;
 	}
 
 	/*
@@ -2151,7 +2151,7 @@
 	if ((major == data->maj) && (minor == data->min)) {
 		if (!dm_device_get_name(major, minor, 1, kernel_dev_name,
 					sizeof(kernel_dev_name))) {
-			stack;
+			log_stack;
 			*kernel_dev_name = '\0';
 		}
 		log_verbose("Device %s (%u:%u) appears to be mounted on %s.",
@@ -2171,7 +2171,7 @@
 	};
 
 	if (!dm_mountinfo_read(_device_has_mounted_fs, &data))
-		stack;
+		log_stack;
 
 	if (data.mounted)
 		return 1;
@@ -2574,7 +2574,7 @@
 			     gen_cookie, gen_semid, val);
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*semid = gen_semid;
 	*cookie = gen_cookie;
@@ -2583,7 +2583,7 @@
 
 bad:
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*cookie = 0;
 
diff -u -r ../LVM2.2.03.16.orig/device_mapper/libdm-deptree.c ./device_mapper/libdm-deptree.c
--- ../LVM2.2.03.16.orig/device_mapper/libdm-deptree.c	2022-05-18 18:24:20.000000000 +0200
+++ ./device_mapper/libdm-deptree.c	2022-06-30 16:18:13.146722690 +0200
@@ -640,7 +640,7 @@
 			"%s (" FMTu32 ":" FMTu32 ")",
 			dnode->name ? dnode->name : "",
 			dnode->info.major, dnode->info.minor) < 0) {
-		stack;
+		log_stack;
 		return dnode->name;
 	}
 
@@ -765,7 +765,7 @@
 
 	dm_list_iterate_items(dlink, list) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -984,7 +984,7 @@
 	/* Iterate through parents of this node */
 	dm_list_iterate_items(dlink, &node->used_by) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1247,7 +1247,7 @@
 	/* Can't recurse if not a mapped device or there are no dependencies */
 	if (!node->info.exists || !deps || !deps->count) {
 		if (!_add_to_bottomlevel(node)) {
-			stack;
+			log_stack;
 			node = NULL;
 		}
 		goto out;
@@ -1361,7 +1361,7 @@
 		dec_suspended();
 
 	if (!(r = dm_task_get_info(dmt, newinfo)))
-		stack;
+		log_stack;
 
 out:
 	dm_task_destroy(dmt);
@@ -1783,17 +1783,17 @@
 
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1828,7 +1828,7 @@
 
 			/* Check toplevel node for holders/mounted fs */
 			if (!_check_device_not_in_use(name, &info)) {
-				stack;
+				log_stack;
 				r = 0;
 				continue;
 			}
@@ -1868,7 +1868,7 @@
 		if (child->callback &&
 		    !child->callback(child, DM_NODE_CALLBACK_DEACTIVATED,
 				     child->callback_data))
-			stack;
+			log_stack;
 			/* FIXME Deactivation must currently ignore failure
 			 * here so that lvremove can continue: we need an
 			 * alternative way to handle this state without 
@@ -1905,17 +1905,17 @@
 	/* Suspend nodes at this level of the tree */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1936,7 +1936,7 @@
 		/* If child has some real messages send them */
 		if ((child->props.send_messages > 1) && r) {
 			if (!(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 			else {
 				log_debug_activation("Sent messages to thin-pool %s and "
 						     "skipping suspend of its children.",
@@ -1967,7 +1967,7 @@
 			continue;
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -2015,7 +2015,7 @@
 			continue;
 
 		if (!(sibling_name = dm_tree_node_get_name(sibling))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -2044,7 +2044,7 @@
 	/* Activate children first */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -2065,7 +2065,7 @@
 				continue;
 
 			if (!(uuid = dm_tree_node_get_uuid(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -2073,7 +2073,7 @@
 				continue;
 
 			if (!(name = dm_tree_node_get_name(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -2116,7 +2116,7 @@
 			 */
 			if (r && (child->props.send_messages > 1) &&
 			    !(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 		}
 		if (awaiting_peer_rename)
 			priority--; /* redo priority level */
@@ -2200,7 +2200,7 @@
 do {\
 	int w;\
 	if ((w = dm_snprintf(params + p, paramsize - (size_t) p, str)) < 0) {\
-		stack; /* Out of space */\
+		log_stack; /* Out of space */\
 		return -1;\
 	}\
 	p += w;\
@@ -2814,7 +2814,7 @@
 		EMIT_PARAMS(pos, " sectors_per_bit:%llu", (unsigned long long)set->sectors_per_bit);
 
 	if (!dm_task_secure_data(dmt))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -3070,7 +3070,7 @@
 		free(params);
 
 		if (!ret)
-			stack;
+			log_stack;
 
 		if (ret >= 0)
 			return ret;
@@ -3201,7 +3201,7 @@
 static int _dm_tree_wait_and_revert_activated(struct dm_tree_node *dnode)
 {
 	if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-		stack;
+		log_stack;
 
 	dm_tree_set_cookie(dnode, 0);
 
@@ -3247,13 +3247,13 @@
 		if (!child->info.inactive_table &&
 		    child->props.segment_count &&
 		    !_load_node(child)) {
-			stack;
+			log_stack;
 			/*
 			 * If the table load fails, try to device in the kernel
 			 * together with other created and preloaded devices.
 			 */
 			if (!_dm_tree_wait_and_revert_activated(dnode))
-				stack;
+				log_stack;
 			r = 0;
 			continue;
 		}
@@ -3274,7 +3274,7 @@
 				  child->info.suspended)) {
 			log_error("Unable to resume %s.", _node_name(child));
 			if (!_dm_tree_wait_and_revert_activated(dnode))
-				stack;
+				log_stack;
 			r = 0;
 			continue;
 		}
@@ -3283,9 +3283,9 @@
 			/* When creating new node also check transaction_id. */
 			if (child->props.send_messages &&
 			    !_node_send_messages(child, uuid_prefix, uuid_prefix_len, 0)) {
-				stack;
+				log_stack;
 				if (!_dm_tree_wait_and_revert_activated(dnode))
-					stack;
+					log_stack;
 				r = 0;
 				continue;
 			}
@@ -3303,7 +3303,7 @@
 	if (update_devs_flag ||
 	    (r && !dnode->info.exists && dnode->callback)) {
 		if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-			stack;
+			log_stack;
 		dm_tree_set_cookie(dnode, 0);
 
 		if (r && !dnode->info.exists && dnode->callback &&
diff -u -r ../LVM2.2.03.16.orig/device_mapper/libdm-file.c ./device_mapper/libdm-file.c
--- ../LVM2.2.03.16.orig/device_mapper/libdm-file.c	2022-05-18 18:24:20.000000000 +0200
+++ ./device_mapper/libdm-file.c	2022-06-30 16:18:13.083388046 +0200
@@ -252,12 +252,12 @@
                log_error("Cannot check lock status of lockfile [%s], error was [%s]",
                          lockfile, strerror(errno));
                if (close(fd))
-                       stack;
+                       log_stack;
                return 0;
        }
 
        if (close(fd))
-               stack;
+               log_stack;
 
        return (lock.l_type == F_UNLCK) ? 0 : 1;
 }
diff -u -r ../LVM2.2.03.16.orig/device_mapper/libdm-report.c ./device_mapper/libdm-report.c
--- ../LVM2.2.03.16.orig/device_mapper/libdm-report.c	2022-05-18 18:24:20.000000000 +0200
+++ ./device_mapper/libdm-report.c	2022-06-30 16:18:13.083388046 +0200
@@ -836,7 +836,7 @@
 	}
 
 	if (!_copy_field(rh, fp, field_num, implicit)) {
-		stack;
+		log_stack;
 		dm_pool_free(rh->mem, fp);
 		return NULL;
 	}
diff -u -r ../LVM2.2.03.16.orig/device_mapper/libdm-timestamp.c ./device_mapper/libdm-timestamp.c
--- ../LVM2.2.03.16.orig/device_mapper/libdm-timestamp.c	2022-05-18 18:24:20.000000000 +0200
+++ ./device_mapper/libdm-timestamp.c	2022-06-30 16:18:13.076721242 +0200
@@ -55,7 +55,7 @@
 	struct dm_timestamp *ts = NULL;
 
 	if (!(ts = zalloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
@@ -103,7 +103,7 @@
 	struct dm_timestamp *ts;
 
 	if (!(ts = malloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
diff -u -r ../LVM2.2.03.16.orig/device_mapper/regex/parse_rx.c ./device_mapper/regex/parse_rx.c
--- ../LVM2.2.03.16.orig/device_mapper/regex/parse_rx.c	2022-05-18 18:24:20.000000000 +0200
+++ ./device_mapper/regex/parse_rx.c	2022-06-30 16:18:13.223390943 +0200
@@ -377,7 +377,7 @@
 		return l;
 
 	if (!(n = _node(ps->mem, CAT, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
@@ -400,7 +400,7 @@
 	}
 
 	if (!(n = _node(ps->mem, OR, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
diff -u -r ../LVM2.2.03.16.orig/lib/activate/activate.c ./lib/activate/activate.c
--- ../LVM2.2.03.16.orig/lib/activate/activate.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/activate/activate.c	2022-06-30 16:18:10.473334049 +0200
@@ -888,7 +888,7 @@
 		log_debug_activation("Retrying open_count check for %s.",
 				     display_lvname(lv));
 		if (!lv_info(lv->vg->cmd, lv, 0, &info, 1, 0) || !info.exists) {
-			stack; /* device dissappeared? */
+			log_stack; /* device dissappeared? */
 			return 1;
 		} else if (!info.open_count)
 			return 1;
@@ -919,7 +919,7 @@
 		return_0;
 
 	if (!(r = dev_manager_transient(dm, lv)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -944,7 +944,7 @@
 		return_0;
 
 	if (!(r = dev_manager_snapshot_percent(dm, lv, percent)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -975,7 +975,7 @@
 		return_0;
 
 	if (!(r = dev_manager_mirror_percent(dm, lv, wait, percent, event_nr)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1025,7 +1025,7 @@
 
 	if (!(*dev_health = dm_pool_strdup(lv->vg->cmd->mem,
 					  raid_status->raid->dev_health))) {
-		stack;
+		log_stack;
                 r = 0;
 	}
 
@@ -1098,7 +1098,7 @@
 	if (!raid_status->raid->sync_action ||
 	    !(*sync_action = dm_pool_strdup(lv->vg->cmd->mem,
 					    raid_status->raid->sync_action))) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -1190,7 +1190,7 @@
 	if (!dev_manager_raid_status(dm, lv, status, &exists)) {
 		dev_manager_destroy(dm);
 		if (exists)
-			stack;
+			log_stack;
 		return 0;
 	}
 	/* User has to call dm_pool_destroy(status->mem)! */
@@ -1254,7 +1254,7 @@
 	if (!dev_manager_cache_status(dm, cache_lv, status, &exists)) {
 		dev_manager_destroy(dm);
 		if (exists)
-			stack;
+			log_stack;
 		return 0;
 	}
 	/* User has to call dm_pool_destroy(status->mem)! */
@@ -1274,7 +1274,7 @@
 	if (!dev_manager_thin_pool_status(dm, lv, flush, thin_pool_status, &exists)) {
 		dev_manager_destroy(dm);
 		if (exists)
-			stack;
+			log_stack;
 		return 0;
 	}
 
@@ -1295,7 +1295,7 @@
 	if (!dev_manager_thin_status(dm, lv, flush, thin_status, &exists)) {
 		dev_manager_destroy(dm);
 		if (exists)
-			stack;
+			log_stack;
 		return 0;
 	}
 
@@ -1315,7 +1315,7 @@
 
 	if (!(r = dev_manager_thin_device_id(dm, lv, device_id, &exists)))
 		if (exists)
-			stack;
+			log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1341,7 +1341,7 @@
 	if (!dev_manager_vdo_pool_status(dm, lv, flush, vdo_status, &exists)) {
 		dev_manager_destroy(dm);
 		if (exists)
-			stack;
+			log_stack;
 		return 0;
 	}
 
@@ -1382,7 +1382,7 @@
 	struct lvinfo info;
 
 	if (!lv_info(cmd, lv, 0, &info, 1, 0)) {
-		stack;
+		log_stack;
 		return -1;
 	}
 
@@ -1398,7 +1398,7 @@
 		return_0;
 
 	if (!(r = dev_manager_activate(dm, lv, laopts)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 	return r;
@@ -1417,7 +1417,7 @@
 	laopts->read_only = _passes_readonly_filter(lv->vg->cmd, lv);
 
 	if (!(r = dev_manager_preload(dm, lv, laopts, flush_required)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1435,7 +1435,7 @@
 		return_0;
 
 	if (!(r = dev_manager_deactivate(dm, lv)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 	return r;
@@ -1457,7 +1457,7 @@
 		return_0;
 
 	if (!(r = dev_manager_suspend(dm, lv, laopts, lockfs, flush_required)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 	return r;
@@ -1798,7 +1798,7 @@
 	if (lv_is_cow(lv) && (laopts->no_merging || !lv_is_merging_cow(lv) ||
 			      lv_has_target_type(lv->vg->cmd->mem, lv, NULL, TARGET_NAME_SNAPSHOT))) {
 		if (!(r = monitor_dev_for_events(cmd, lv->snapshot->lv, NULL, monitor)))
-			stack;
+			log_stack;
 		return r;
 	}
 
@@ -1812,7 +1812,7 @@
 		dm_list_iterate_safe(snh, snht, &lv->snapshot_segs)
 			if (!monitor_dev_for_events(cmd, dm_list_struct_base(snh,
 				struct lv_segment, origin_list)->cow, NULL, monitor)) {
-				stack;
+				log_stack;
 				r = 0;
 			}
 
@@ -1824,7 +1824,7 @@
 	    (log_seg = first_seg(seg->log_lv)) != NULL &&
 	    seg_is_mirrored(log_seg))
 		if (!monitor_dev_for_events(cmd, seg->log_lv, NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
@@ -1835,7 +1835,7 @@
 				continue;
 			if (!monitor_dev_for_events(cmd, seg_lv(seg, s), NULL,
 						    monitor)) {
-				stack;
+				log_stack;
 				r = 0;
 			}
 		}
@@ -1848,20 +1848,20 @@
 		if (seg->pool_lv &&
 		    !monitor_dev_for_events(cmd, seg->pool_lv,
 					    (!monitor) ? laopts : NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
 		if (seg->external_lv &&
 		    !monitor_dev_for_events(cmd, seg->external_lv,
 					    (!monitor) ? laopts : NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
 		if (seg->metadata_lv &&
 		    !monitor_dev_for_events(cmd, seg->metadata_lv, NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
@@ -1942,7 +1942,7 @@
 			 * so they skip this dm mirror table refreshing step.
 			 */
 			if (!_lv_activate_lv(lv, &mirr_laopts)) {
-				stack;
+				log_stack;
 				r = 0;
 			}
 		}
@@ -1952,7 +1952,7 @@
 		for (i = 0;; i++) {
 			pending = 0;
 			if (!seg->segtype->ops->target_monitored(seg, &pending, &monitored)) {
-				stack;
+				log_stack;
 				r = 0;
 				break;
 			}
@@ -2148,7 +2148,7 @@
 
 	if (!monitor_dev_for_events(cmd, lv, laopts, 0))
 		/* FIXME Consider aborting here */
-		stack;
+		log_stack;
 
 	if (!laopts->origin_only &&
 	    (lv_is_origin(lv_pre) || lv_is_cow(lv_pre)))
@@ -2331,7 +2331,7 @@
 	critical_section_dec(cmd, "resumed");
 
 	if (!monitor_dev_for_events(cmd, lv, laopts, 1))
-		stack;
+		log_stack;
 
 	r = 1;
 out:
@@ -2448,7 +2448,7 @@
 	}
 
 	if (!monitor_dev_for_events(cmd, lv, &laopts, 0))
-		stack;
+		log_stack;
 
 	critical_section_inc(cmd, "deactivating");
 	r = _lv_deactivate(lv);
@@ -2596,11 +2596,11 @@
 
 	critical_section_inc(cmd, "activating");
 	if (!(r = _lv_activate_lv(lv, laopts)))
-		stack;
+		log_stack;
 	critical_section_dec(cmd, "activated");
 
 	if (r && !monitor_dev_for_events(cmd, lv, laopts, 1))
-		stack;
+		log_stack;
 out:
 	return r;
 }
diff -u -r ../LVM2.2.03.16.orig/lib/activate/dev_manager.c ./lib/activate/dev_manager.c
--- ../LVM2.2.03.16.orig/lib/activate/dev_manager.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/activate/dev_manager.c	2022-06-30 16:18:10.473334049 +0200
@@ -336,7 +336,7 @@
 
 		if (!target_name ||
 		    !_get_segment_status_from_target_params(target_name, target_params, dminfo, seg_status))
-			stack;
+			log_stack;
 	}
 
 	r = 1;
@@ -424,7 +424,7 @@
 					       .check_error_target = 1,
 					       .check_reserved = 0 }, NULL))
 				goto out; /* safe to use */
-			stack;
+			log_stack;
 		}
 	}
 
@@ -590,7 +590,7 @@
 		return_0;
 
 	if (!dm_get_status_snapshot(mem, params, &s))
-		stack;
+		log_stack;
         else
 		r = s->invalid;
 
@@ -609,7 +609,7 @@
 		return_0;
 
 	if (!dm_get_status_raid(mem, params, &s))
-		stack;
+		log_stack;
 	else if (s->sync_action && !strcmp(s->sync_action, "frozen")) {
 		log_warn("WARNING: %s frozen raid device (%d:%d) needs inspection.",
 			  dev_name(dev), (int)MAJOR(dev->dev), (int)MINOR(dev->dev));
@@ -983,7 +983,7 @@
 	if (!(r = _info(cmd, name, dlid,
 			with_open_count, with_read_ahead, with_name_check,
 			dminfo, read_ahead, seg_status)))
-		stack;
+		log_stack;
 out:
 	dm_pool_free(cmd->mem, name);
 
diff -u -r ../LVM2.2.03.16.orig/lib/activate/fs.c ./lib/activate/fs.c
--- ../LVM2.2.03.16.orig/lib/activate/fs.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/activate/fs.c	2022-06-30 16:18:10.473334049 +0200
@@ -286,10 +286,10 @@
 	case FS_RENAME:
 		if (old_lv_name && !_rm_link(dev_dir, vg_name, old_lv_name,
 					     check_udev))
-			stack;
+			log_stack;
 
 		if (!_mk_link(dev_dir, vg_name, lv_name, dev, check_udev))
-			stack;
+			log_stack;
 	default:
 		; /* NOTREACHED */
 	}
@@ -492,7 +492,7 @@
 		log_debug_activation("Syncing device names");
 		/* Wait for all processed udev devices */
 		if (!dm_udev_wait(_fs_cookie))
-			stack;
+			log_stack;
 		_fs_cookie = DM_COOKIE_AUTO_CREATE; /* Reset cookie */
 		dm_lib_release();
 		_pop_fs_ops();
diff -u -r ../LVM2.2.03.16.orig/lib/cache/lvmcache.c ./lib/cache/lvmcache.c
--- ../LVM2.2.03.16.orig/lib/cache/lvmcache.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/cache/lvmcache.c	2022-06-30 16:18:10.480000854 +0200
@@ -618,7 +618,7 @@
 	dm_list_iterate_items(devl, &_unused_duplicates) {
 		memcpy(&id, devl->dev->pvid, ID_LEN);
 		if (!id_write_format(&id, pvid_dashed, sizeof(pvid_dashed)))
-			stack;
+			log_stack;
 
 		log_warn("WARNING: Not using device %s for PV %s.", dev_name(devl->dev), pvid_dashed);
 	}
@@ -630,7 +630,7 @@
 
 		memcpy(&id, info->dev->pvid, ID_LEN);
 		if (!id_write_format(&id, pvid_dashed, sizeof(pvid_dashed)))
-			stack;
+			log_stack;
 
 		log_warn("WARNING: PV %s prefers device %s because %s.",
 			 pvid_dashed, dev_name(info->dev), info->dev->duplicate_prefer_reason);
@@ -1847,7 +1847,7 @@
 		return 1;
 
 	if (!id_write_format((const struct id *)vgid, vgid_dashed, sizeof(vgid_dashed)))
-		stack;
+		log_stack;
 
 	/*
 	 * Add vginfo for orphan VG
@@ -1943,7 +1943,7 @@
 
 			if (vginfo_is_allowed && other_is_allowed) {
 				if (!id_write_format((const struct id *)other->vgid, other_dashed, sizeof(other_dashed)))
-					stack;
+					log_stack;
 
 				vginfo->has_duplicate_local_vgname = 1;
 				other->has_duplicate_local_vgname = 1;
@@ -2635,11 +2635,11 @@
 		struct format_type *fmt;
 
 		if (!lvmcache_init(cmd))
-			stack;
+			log_stack;
 
 		dm_list_iterate_items(fmt, &cmd->formats) {
 			if (!lvmcache_add_orphan_vginfo(cmd, fmt->orphan_vg_name, fmt))
-				stack;
+				log_stack;
 		}
 	}
 }
diff -u -r ../LVM2.2.03.16.orig/lib/commands/toolcontext.c ./lib/commands/toolcontext.c
--- ../LVM2.2.03.16.orig/lib/commands/toolcontext.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/commands/toolcontext.c	2022-06-30 16:18:10.513334877 +0200
@@ -128,7 +128,7 @@
 	free(line);
 
 	if (fclose(fp))
-		stack;
+		log_stack;
 
 	return system_id;
 }
@@ -166,7 +166,7 @@
 				 strerror(errno), errno);
 
 		if (dm_snprintf(buf, PATH_MAX, SD_ID128_FORMAT_STR, SD_ID128_FORMAT_VAL(id)) < 0)
-			stack;
+			log_stack;
 		system_id = system_id_from_string(cmd, buf);
 		goto out;
 	}
@@ -1874,7 +1874,7 @@
 
 	_destroy_filters(cmd);
 	if (!(r = init_filters(cmd, 0)))
-                stack;
+                log_stack;
 
 	/*
 	 * During repair code must not reset suspended flag.
@@ -1907,7 +1907,7 @@
 
 	devices_file_exit(cmd);
 	if (!dev_cache_exit())
-		stack;
+		log_stack;
 	_destroy_dev_types(cmd);
 	_destroy_tags(cmd);
 
diff -u -r ../LVM2.2.03.16.orig/lib/config/config.c ./lib/config/config.c
--- ../LVM2.2.03.16.orig/lib/config/config.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/config/config.c	2022-06-30 16:18:10.513334877 +0200
@@ -253,7 +253,7 @@
 		cf = cs->source.file;
 		if (cf && cf->dev)
 			if (!dev_close(cf->dev))
-				stack;
+				log_stack;
 	}
 
 	dm_config_destroy(cft);
@@ -638,7 +638,7 @@
 
 	if (!cf->keep_open) {
 		if (!dev_close(cf->dev))
-			stack;
+			log_stack;
 		cf->dev = NULL;
 	}
 
@@ -1941,7 +1941,7 @@
 	}
 
 	if (baton.fp && baton.fp != stdout && dm_fclose(baton.fp)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -2497,7 +2497,7 @@
 
 	if (!get_default_allocation_thin_pool_chunk_size(cmd, profile, &chunk_size,
 							 &chunk_size_calc_method)) {
-		stack; /* Ignore this error, never happens... */
+		log_stack; /* Ignore this error, never happens... */
 		chunk_size = DEFAULT_THIN_POOL_CHUNK_SIZE * 2;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/device/bcache.c ./lib/device/bcache.c
--- ../LVM2.2.03.16.orig/lib/device/bcache.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/bcache.c	2022-06-30 16:18:10.486667659 +0200
@@ -1180,7 +1180,7 @@
 		log_warn("some blocks are still locked");
 
 	if (!bcache_flush(cache))
-		stack;
+		log_stack;
 	_wait_all(cache);
 	_exit_free_list(cache);
 	radix_tree_destroy(cache->rtree);
diff -u -r ../LVM2.2.03.16.orig/lib/device/dev-cache.c ./lib/device/dev-cache.c
--- ../LVM2.2.03.16.orig/lib/device/dev-cache.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/dev-cache.c	2022-06-30 16:18:10.486667659 +0200
@@ -1308,7 +1308,7 @@
 				  dev_name(dev), dev->open_count);
 			num_open++;
 			if (close_immediate && !dev_close_immediate(dev))
-				stack;
+				log_stack;
 		}
 	}
 
@@ -2127,7 +2127,7 @@
 				continue;
 			if (dm_snprintf(devname, sizeof(devname), "/dev/%s", dirent->d_name) < 0) {
 				devname[0] = '\0';
-				stack;
+				log_stack;
 			}
 			break;
 		}
@@ -2155,7 +2155,7 @@
 
 		if (dm_snprintf(devname, sizeof(devname), "/dev/mapper/%s", namebuf) < 0) {
 			devname[0] = '\0';
-			stack;
+			log_stack;
 		}
 
 		if (devname[0]) {
@@ -2184,7 +2184,7 @@
 
 		if (dm_snprintf(devname, sizeof(devname), "/dev/%s", namebuf) < 0) {
 			devname[0] = '\0';
-			stack;
+			log_stack;
 		}
 		break;
 	}
diff -u -r ../LVM2.2.03.16.orig/lib/device/dev-dasd.c ./lib/device/dev-dasd.c
--- ../LVM2.2.03.16.orig/lib/device/dev-dasd.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/dev-dasd.c	2022-06-30 16:18:10.493334464 +0200
@@ -96,7 +96,7 @@
 
 out:
 	if (!dev_close(dev))
-		stack;
+		log_stack;
 
 	return ret;
 }
diff -u -r ../LVM2.2.03.16.orig/lib/device/device_id.c ./lib/device/device_id.c
--- ../LVM2.2.03.16.orig/lib/device/device_id.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/device_id.c	2022-06-30 16:18:10.486667659 +0200
@@ -64,7 +64,7 @@
 	if (!(fp = fopen(_searched_file, "w")))
 		return;
 	if (fclose(fp))
-		stack;
+		log_stack;
 }
 
 void unlink_searched_devnames(struct cmd_context *cmd)
@@ -633,7 +633,7 @@
 		dm_list_add(&cmd->use_devices, &du->list);
 	}
 	if (fclose(fp))
-		stack;
+		log_stack;
 
 	return ret;
 }
@@ -750,7 +750,7 @@
 		fprintf(fp, "SYSTEMID=%s\n", cmd->system_id);
 
 	if (dm_snprintf(version_buf, VERSION_LINE_MAX, "VERSION=%u.%u.%u", DEVICES_FILE_MAJOR, DEVICES_FILE_MINOR, df_counter+1) < 0)
-		stack;
+		log_stack;
 	else
 		fprintf(fp, "%s\n", version_buf);
 
@@ -780,9 +780,9 @@
 	}
 
 	if (fflush(fp))
-		stack;
+		log_stack;
 	if (fclose(fp))
-		stack;
+		log_stack;
 
 	if (rename(tmppath, cmd->devices_file_path) < 0) {
 		log_error("Failed to replace devices file errno %d", errno);
@@ -790,9 +790,9 @@
 	}
 
 	if (fsync(dir_fd) < 0)
-		stack;
+		log_stack;
 	if (close(dir_fd) < 0)
-		stack;
+		log_stack;
 
 	log_debug("Wrote devices file %s", version_buf);
 out:
@@ -823,7 +823,7 @@
 	} else {
 		if (device_ids_version_unchanged(cmd)) {
 			if (!device_ids_write(cmd))
-				stack;
+				log_stack;
 		} else
 			log_debug("Skip devices file update (changed).");
 	}
@@ -848,7 +848,7 @@
 
 		if (!strncmp(line, "VERSION", 7)) {
 			if (fclose(fp))
-				stack;
+				log_stack;
 
 			_copy_idline_str(line, version_buf, sizeof(version_buf));
 
@@ -861,7 +861,7 @@
 	}
 
 	if (fclose(fp))
-		stack;
+		log_stack;
 	return 0;
 }
 
@@ -1335,7 +1335,7 @@
 
 	if (update &&
 	    !device_ids_write(cmd))
-		stack;
+		log_stack;
 	unlock_devices_file(cmd);
 }
 
@@ -2271,7 +2271,7 @@
 			free(dup_devname2);
 			free(dup_devname3);
 			free(id);
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -2375,7 +2375,7 @@
 		return 0;
 	}
 	if (close(fd))
-		stack;
+		log_stack;
 	return 1;
 }
 
@@ -2491,7 +2491,7 @@
 	log_debug("lock_devices_file flock errno %d", errno);
 
 	if (close(fd))
-		stack;
+		log_stack;
 	if (cmd->sysinit || cmd->ignorelockingfailure)
 		return 1;
 	return 0;
@@ -2533,7 +2533,7 @@
 	_devices_file_locked = 0;
 
 	if (close(_devices_fd))
-		stack;
+		log_stack;
 	_devices_fd = -1;
 }
 
diff -u -r ../LVM2.2.03.16.orig/lib/device/dev-io.c ./lib/device/dev-io.c
--- ../LVM2.2.03.16.orig/lib/device/dev-io.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/dev-io.c	2022-06-30 16:18:10.486667659 +0200
@@ -109,7 +109,7 @@
 	if (ioctl(fd, BLKGETSIZE64, size) < 0) {
 		log_warn("WARNING: %s: ioctl BLKGETSIZE64 %s", name, strerror(errno));
 		if (do_close && !dev_close_immediate(dev))
-			stack;
+			log_stack;
 		return 0;
 	}
 
@@ -120,7 +120,7 @@
 	log_very_verbose("%s: size is %" PRIu64 " sectors", name, *size);
 
 	if (do_close && !dev_close_immediate(dev))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -143,7 +143,7 @@
 	if (ioctl(dev->fd, BLKRAGET, &read_ahead_long) < 0) {
 		log_warn("WARNING: %s: ioctl BLKRAGET %s.", dev_name(dev), strerror(errno));
 		if (!dev_close_immediate(dev))
-			stack;
+			log_stack;
 		return 0;
 	}
 
@@ -154,7 +154,7 @@
 			 dev_name(dev), *read_ahead);
 
 	if (!dev_close_immediate(dev))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -177,13 +177,13 @@
 		log_warn("WARNING: %s: ioctl BLKDISCARD at offset %" PRIu64 " size %" PRIu64 " failed: %s.",
 			  dev_name(dev), offset_bytes, size_bytes, strerror(errno));
 		if (!dev_close_immediate(dev))
-			stack;
+			log_stack;
 		/* It doesn't matter if discard failed, so return success. */
 		return 1;
 	}
 
 	if (!dev_close_immediate(dev))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -216,7 +216,7 @@
 	 * without reverting to read-modify-write operations"
 	 */
 	if (ioctl(fd, BLKPBSZGET, &pbs)) {
-		stack;
+		log_stack;
 		pbs = 0;
 	}
 #endif
@@ -226,7 +226,7 @@
 	 * "the lowest possible block size that the storage device can address."
 	 */
 	if (ioctl(fd, BLKSSZGET, &lbs)) {
-		stack;
+		log_stack;
 		lbs = 0;
 	}
 
@@ -237,7 +237,7 @@
 	*logical_block_size = lbs;
 
 	if (do_close && !dev_close_immediate(dev))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -409,7 +409,7 @@
 	    ((fstat(dev->fd, &buf) < 0) || (buf.st_rdev != dev->dev))) {
 		log_error("%s: fstat failed: Has device name changed?", name);
 		if (!dev_close_immediate(dev))
-			stack;
+			log_stack;
 		return 0;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/device/dev-md.c ./lib/device/dev-md.c
--- ../LVM2.2.03.16.orig/lib/device/dev-md.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/dev-md.c	2022-06-30 16:18:10.486667659 +0200
@@ -179,7 +179,7 @@
 	int ret;
 
 	if (!dev_get_size(dev, &size)) {
-		stack;
+		log_stack;
 		return -1;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/device/dev-mpath.c ./lib/device/dev-mpath.c
--- ../LVM2.2.03.16.orig/lib/device/dev-mpath.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/dev-mpath.c	2022-06-30 16:18:10.503334670 +0200
@@ -150,15 +150,15 @@
 
 		if (section_exceptions) {
 			if (!str_list_add(_wwid_mem, &_ignored_exceptions, dm_pool_strdup(_wwid_mem, wwid)))
-				stack;
+				log_stack;
 		} else {
 			if (!str_list_add(_wwid_mem, &_ignored, dm_pool_strdup(_wwid_mem, wwid)))
-				stack;
+				log_stack;
 		}
 	}
 
 	if (fclose(fp))
-		stack;
+		log_stack;
 }
 
 static void _read_wwid_exclusions(void)
@@ -236,7 +236,7 @@
 	}
 
 	if (fclose(fp))
-		stack;
+		log_stack;
 
 	log_debug("multipath wwids read %d from %s", count, config_wwids_file);
 }
@@ -585,7 +585,7 @@
 
  out:
 	if (closedir(dr))
-		stack;
+		log_stack;
 
 	if (is_mpath_component)
 		*mpath_devno = MKDEV(dm_dev_major, dm_dev_minor);
@@ -710,7 +710,7 @@
 			break;
 	}
 	if (closedir(dr))
-		stack;
+		log_stack;
 
 	return wwid;
 }
diff -u -r ../LVM2.2.03.16.orig/lib/device/dev-swap.c ./lib/device/dev-swap.c
--- ../LVM2.2.03.16.orig/lib/device/dev-swap.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/device/dev-swap.c	2022-06-30 16:18:10.493334464 +0200
@@ -43,7 +43,7 @@
 	int ret = 0;
 
 	if (!dev_get_size(dev, &size)) {
-		stack;
+		log_stack;
 		return -1;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/display/display.c ./lib/display/display.c
--- ../LVM2.2.03.16.orig/lib/display/display.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/display/display.c	2022-06-30 16:18:12.340039335 +0200
@@ -214,7 +214,7 @@
 		return;
 
 	if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -271,7 +271,7 @@
 		return;
 
 	if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -795,7 +795,7 @@
 		  display_size(vg->cmd, vg_free(vg)));
 
 	if (!id_write_format(&vg->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -826,7 +826,7 @@
 	}
 
 	if (!id_write_format(&vg->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -1012,7 +1012,7 @@
 
 	/* For other then Yes answer check there is really no interrupt */
 	if (sig || sigint_caught()) {
-		stack;
+		log_stack;
 		ret = 'n';
 	} else if (c == EOF) {
 		fputs("[n]\n", stderr);
diff -u -r ../LVM2.2.03.16.orig/lib/format_text/archiver.c ./lib/format_text/archiver.c
--- ../LVM2.2.03.16.orig/lib/format_text/archiver.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/format_text/archiver.c	2022-06-30 16:18:12.100034370 +0200
@@ -326,7 +326,7 @@
 
 	dm_list_iterate_items(mda, &tf->metadata_areas_in_use) {
 		if (!(vg = mda->ops->vg_read(cmd, tf, vg_name, mda, NULL, NULL)))
-			stack;
+			log_stack;
 		break;
 	}
 
@@ -600,12 +600,12 @@
 	/* Write and commit the metadata area */
 	dm_list_iterate_items(mda, &tf->metadata_areas_in_use) {
 		if (!(r = mda->ops->vg_write(tf, vg, mda))) {
-			stack;
+			log_stack;
 			continue;
 		}
 		if (mda->ops->vg_commit &&
 		    !(r = mda->ops->vg_commit(tf, vg, mda))) {
-			stack;
+			log_stack;
 		}
 	}
 
@@ -656,11 +656,11 @@
 
 	if (vg_backup) {
 		if (!_archive(vg_backup, 0))
-			stack;
+			log_stack;
 		release_vg(vg_backup);
 	}
 	if (!_archive(vg, 0))
-		stack;
+		log_stack;
 	if (!backup_locally(vg))
-		stack;
+		log_stack;
 }
diff -u -r ../LVM2.2.03.16.orig/lib/format_text/format-text.c ./lib/format_text/format-text.c
--- ../LVM2.2.03.16.orig/lib/format_text/format-text.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/format_text/format-text.c	2022-06-30 16:18:12.103367773 +0200
@@ -1732,7 +1732,7 @@
 		return_0;
 
 	if (!label_write(pv->dev, label)) {
-		stack;
+		log_stack;
 		return 0;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/format_text/import.c ./lib/format_text/import.c
--- ../LVM2.2.03.16.orig/lib/format_text/import.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/format_text/import.c	2022-06-30 16:18:12.103367773 +0200
@@ -232,7 +232,7 @@
 		 * so it can use cached PV state too.
 		 */
 		if (!(vg = (*vsn)->read_vg(cmd, fid->fmt, fid, cft)))
-			stack;
+			log_stack;
 		else {
 			set_pv_devices(fid, vg);
 
diff -u -r ../LVM2.2.03.16.orig/lib/format_text/text_label.c ./lib/format_text/text_label.c
--- ../LVM2.2.03.16.orig/lib/format_text/text_label.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/format_text/text_label.c	2022-06-30 16:18:12.003365703 +0200
@@ -105,7 +105,7 @@
 	memcpy(pvhdr->pv_uuid, &lvmcache_device(info)->pvid, sizeof(struct id));
 	if (!id_write_format((const struct id *)pvhdr->pv_uuid, buffer,
 			     sizeof(buffer))) {
-		stack;
+		log_stack;
 		buffer[0] = '\0';
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/label/hints.c ./lib/label/hints.c
--- ../LVM2.2.03.16.orig/lib/label/hints.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/label/hints.c	2022-06-30 16:18:12.183369427 +0200
@@ -235,7 +235,7 @@
 	if (!(fp = fopen(_newhints_file, "w")))
 		return_0;
 	if (fclose(fp))
-		stack;
+		log_stack;
 	log_debug("newhints created");
 	return 1;
 }
@@ -247,7 +247,7 @@
 	if (!(fp = fopen(_nohints_file, "w")))
 		return_0;
 	if (fclose(fp))
-		stack;
+		log_stack;
 	return 1;
 }
 
@@ -362,7 +362,7 @@
 		log_warn("unlock_hints flock errno %d", errno);
 
 	if (close(_hints_fd))
-		stack;
+		log_stack;
 	_hints_fd = -1;
 }
 
@@ -586,7 +586,7 @@
 		 * we don't want to take an ex lock here.
 		 */
 		if (!_touch_newhints())
-			stack;
+			log_stack;
 	}
 
 	return ret;
@@ -1079,7 +1079,7 @@
 
  out_flush:
 	if (fflush(fp))
-		stack;
+		log_stack;
 
 	log_debug("Wrote hint file with devs_hash %u count %u", hash, count);
 
@@ -1159,15 +1159,15 @@
 
 	/* limit potential delay blocking on hints lock next */
 	if (!_touch_nohints())
-		stack;
+		log_stack;
 
 	if (!_lock_hints(cmd, LOCK_EX, 0))
-		stack;
+		log_stack;
 
 	_unlink_nohints();
 
 	if (!_clear_hints(cmd))
-		stack;
+		log_stack;
 
 	/*
 	 * Creating a newhints file here is not necessary, since
@@ -1175,7 +1175,7 @@
 	 * is more efficient if it sees a newhints file first.
 	 */
 	if (!_touch_newhints())
-		stack;
+		log_stack;
 }
 
 /*
@@ -1191,21 +1191,21 @@
 	log_debug("pvscan_recreate_hints_begin");
 
 	if (!_touch_hints()) {
-		stack;
+		log_stack;
 		return;
 	}
 
 	/* limit potential delay blocking on hints lock next */
 	if (!_touch_nohints())
-		stack;
+		log_stack;
 
 	if (!_lock_hints(cmd, LOCK_EX, 0))
-		stack;
+		log_stack;
 
 	_unlink_nohints();
 
 	if (!_clear_hints(cmd))
-		stack;
+		log_stack;
 }
 
 /*
@@ -1220,7 +1220,7 @@
 		return;
 
 	if (!_touch_newhints())
-		stack;
+		log_stack;
 }
 
 /*
diff -u -r ../LVM2.2.03.16.orig/lib/label/label.c ./lib/label/label.c
--- ../LVM2.2.03.16.orig/lib/label/label.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/label/label.c	2022-06-30 16:18:12.180036025 +0200
@@ -2042,7 +2042,7 @@
 	unsigned int bs;
 
 	if (!dev_get_direct_block_sizes(dev, &physical_block_size, &logical_block_size)) {
-		stack;
+		log_stack;
 		return; /* FIXME: error path ? */
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/locking/locking.c ./lib/locking/locking.c
--- ../LVM2.2.03.16.orig/lib/locking/locking.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/locking/locking.c	2022-06-30 16:18:10.563335911 +0200
@@ -187,7 +187,7 @@
 		/* ensure signals are blocked while VG_GLOBAL lock is held */
 		_update_vg_lock_count(resource, flags);
 	else
-		stack;
+		log_stack;
 
 	_unblock_signals();
 
@@ -314,7 +314,7 @@
 			dm_list_uniterate(lvh, lvs, &lvl->list) {
 				lvl = dm_list_item(lvh, struct lv_list);
 				if (!deactivate_lv(cmd, lvl->lv))
-					stack;
+					log_stack;
 			}
 			return 0;
 		}
diff -u -r ../LVM2.2.03.16.orig/lib/locking/locking.h ./lib/locking/locking.h
--- ../LVM2.2.03.16.orig/lib/locking/locking.h	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/locking/locking.h	2022-06-30 16:18:10.513334877 +0200
@@ -58,11 +58,11 @@
 	do { \
 		if (is_real_vg(vol)) { \
 			if (!sync_local_dev_names(cmd)) \
-				stack; \
+				log_stack; \
 			vg_backup_if_needed(vg); \
 		} \
 		if (!lock_vol(cmd, vol, LCK_VG_UNLOCK, NULL)) \
-			stack;	\
+			log_stack;	\
 	} while (0)
 #define unlock_and_release_vg(cmd, vg, vol) \
 	do { \
diff -u -r ../LVM2.2.03.16.orig/lib/locking/lvmlockd.c ./lib/locking/lvmlockd.c
--- ../LVM2.2.03.16.orig/lib/locking/lvmlockd.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/locking/lvmlockd.c	2022-06-30 16:18:10.513334877 +0200
@@ -965,7 +965,7 @@
 		_deactivate_sanlock_lv(cmd, vg);
 		_remove_sanlock_lv(cmd, vg);
 		if (!vg_write(vg) || !vg_commit(vg))
-			stack;
+			log_stack;
 	}
 
 	daemon_reply_destroy(reply);
diff -u -r ../LVM2.2.03.16.orig/lib/log/log.h ./lib/log/log.h
--- ../LVM2.2.03.16.orig/lib/log/log.h	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/log/log.h	2022-06-30 16:18:12.106701175 +0200
@@ -109,7 +107,7 @@
 #define log_err_once(x...) LOG_LINE_WITH_ERRNO(_LOG_ERR | _LOG_ONCE, EUNCLASSIFIED, x)
 #define log_fatal(x...) LOG_LINE_WITH_ERRNO(_LOG_FATAL, EUNCLASSIFIED, x)
 
-#define stack log_debug("<backtrace>")	/* Backtrace on error */
+#define log_stack log_debug("<backtrace>")	/* Backtrace on error */
 #define log_very_verbose(args...) log_info(args)
 #define log_verbose(args...) log_notice(args)
 #define log_print(args...) LOG_LINE(_LOG_WARN, args)
@@ -127,12 +127,12 @@
 #define log_sys_debug(x, y) \
 		log_debug("%s: %s failed: %s", y, x, strerror(errno))
 
-#define return_0	do { stack; return 0; } while (0)
-#define return_NULL	do { stack; return NULL; } while (0)
+#define return_0	do { log_stack; return 0; } while (0)
+#define return_NULL	do { log_stack; return NULL; } while (0)
 #define return_EINVALID_CMD_LINE \
-			do { stack; return EINVALID_CMD_LINE; } while (0)
-#define return_ECMD_FAILED do { stack; return ECMD_FAILED; } while (0)
-#define goto_out	do { stack; goto out; } while (0)
-#define goto_bad	do { stack; goto bad; } while (0)
+			do { log_stack; return EINVALID_CMD_LINE; } while (0)
+#define return_ECMD_FAILED do { log_stack; return ECMD_FAILED; } while (0)
+#define goto_out	do { log_stack; goto out; } while (0)
+#define goto_bad	do { log_stack; goto bad; } while (0)
 
 #endif
diff -u -r ../LVM2.2.03.16.orig/lib/lvmpolld/lvmpolld-client.c ./lib/lvmpolld/lvmpolld-client.c
--- ../LVM2.2.03.16.orig/lib/lvmpolld/lvmpolld-client.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/lvmpolld/lvmpolld-client.c	2022-06-30 16:18:10.483334256 +0200
@@ -180,7 +180,7 @@
 		ret.error = 0;
 	} else {
 		_process_error_response(rep);
-		stack;
+		log_stack;
 	}
 
 out_rep:
@@ -266,7 +266,7 @@
 		r = 1;
 	else {
 		_process_error_response(rep);
-		stack;
+		log_stack;
 	}
 
 out_rep:
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/cache_manip.c ./lib/metadata/cache_manip.c
--- ../LVM2.2.03.16.orig/lib/metadata/cache_manip.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/cache_manip.c	2022-06-30 16:18:11.610024233 +0200
@@ -476,7 +476,7 @@
 				cache_seg->cleaner_policy = 0;
 				/* Restore normal table */
 				if (!lv_update_and_reload_origin(cache_lv))
-					stack;
+					log_stack;
 			}
 			return 0;
 		}
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/integrity_manip.c ./lib/metadata/integrity_manip.c
--- ../LVM2.2.03.16.orig/lib/metadata/integrity_manip.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/integrity_manip.c	2022-06-30 16:18:12.003365703 +0200
@@ -638,7 +638,7 @@
 			goto bad;
 		}
 		if (!sync_local_dev_names(cmd))
-			stack;
+			log_stack;
 	}
 
 	/*
@@ -648,7 +648,7 @@
 	 */
 	if (!_set_integrity_block_size(cmd, lv, is_active, settings, lbs_4k, lbs_512, pbs_4k, pbs_512)) {
 		if (!is_active && !deactivate_lv(cmd, lv))
-			stack;
+			log_stack;
 		goto_bad;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/lv.c ./lib/metadata/lv.c
--- ../LVM2.2.03.16.orig/lib/metadata/lv.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/lv.c	2022-06-30 16:18:11.816695175 +0200
@@ -277,7 +277,7 @@
 		goto_bad;
 
 	if (!(ret = lvseg_kernel_discards_dup_with_info_and_seg_status(mem, &status)))
-		stack;
+		log_stack;
 bad:
 	dm_pool_destroy(status.seg_status.mem);
 
@@ -663,7 +663,7 @@
 		 (lv_is_cache_pool_data(lv) || lv_is_cache_pool_metadata(lv)) ||
 		 (lv_is_thin_pool_data(lv) || lv_is_thin_pool_metadata(lv))) {
 		if (!(seg = get_only_segment_using_this_lv(lv)))
-			stack;
+			log_stack;
 		else
 			parent_lv = seg->lv;
 	}
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/lv_manip.c ./lib/metadata/lv_manip.c
--- ../LVM2.2.03.16.orig/lib/metadata/lv_manip.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/lv_manip.c	2022-06-30 16:18:10.683338394 +0200
@@ -2267,10 +2267,10 @@
 					       (top_level_area_index != -1) ? top_level_area_index : (int) (s * stripes_per_mimage),
 					       only_single_area_segments, fn,
 					       data)))
-				stack;
+				log_stack;
 		} else if (seg_type(seg, s) == AREA_PV)
 			if (!(r = fn(cmd, seg_pvseg(seg, s), top_level_area_index != -1 ? (uint32_t) top_level_area_index + s : s, data)))
-				stack;
+				log_stack;
 		if (r != 1)
 			return r;
 	}
@@ -2280,7 +2280,7 @@
 		if (!(r = _for_each_pv(cmd, seg->log_lv, 0, seg->log_lv->le_count, NULL,
 				       NULL, 0, 0, 0, only_single_area_segments,
 				       fn, data)))
-			stack;
+			log_stack;
 		if (r != 1)
 			return r;
 	}
@@ -2293,7 +2293,7 @@
 			if (seg_metalv(seg, s))
 				if (!(r = _for_each_pv(cmd, seg_metalv(seg, s), 0, seg_metalv(seg, s)->le_count, NULL,
 						       NULL, 0, 0, 0, 0, fn, data)))
-					stack;
+					log_stack;
 			if (r != 1)
 				return r;
 		}
@@ -2711,7 +2711,7 @@
 	if (!(r = _for_each_pv(ah->cmd, prev_lvseg->lv, le, len, NULL, NULL,
 			       0, 0, -1, 1,
 			       _is_condition, &pvmatch)))
-		stack;
+		log_stack;
 
 	if (r != 2)
 		return 0;
@@ -2740,7 +2740,7 @@
 			       prev_lvseg->le + prev_lvseg->len - 1, 1, NULL, NULL,
 			       0, 0, -1, 1,
 			       _is_condition, &pvmatch)))
-		stack;
+		log_stack;
 
 	if (r != 2)
 		return 0;
@@ -3406,7 +3406,7 @@
 		return_0;
 
 	if (!_log_parallel_areas(ah->mem, ah->parallel_areas, ah->cling_tag_list_cn))
-		stack;
+		log_stack;
 
 	alloc_state.areas_size = dm_list_size(pvms);
 	if (alloc_state.areas_size &&
@@ -4526,11 +4526,11 @@
 
 	if (segtype_is_pool(segtype)) {
 		if (!(r = create_pool(lv, segtype, ah, stripes, stripe_size)))
-			stack;
+			log_stack;
 	} else if (!segtype_is_mirror(segtype) && !segtype_is_raid(segtype)) {
 		if (!(r = lv_add_segment(ah, 0, ah->area_count, lv, segtype,
 					 stripe_size, 0u, 0)))
-			stack;
+			log_stack;
 	} else {
 		/*
 		 * For RAID, all the devices are AREA_LV.
@@ -5418,11 +5418,11 @@
 
 	/* Top-level LV first */
 	if (!_add_pes(lv, &pe_total))
-		stack;
+		log_stack;
 
 	/* Any sub-LVs */
 	if (!for_each_sub_lv(lv, _add_pes, &pe_total))
-		stack;
+		log_stack;
 
 	return pe_total;
 }
@@ -6175,7 +6175,7 @@
 
 	if (lv_is_cow_covering_origin(lv))
 		if (!monitor_dev_for_events(cmd, lv, 0, 0))
-			stack;
+			log_stack;
 
 	if (lv_is_thin_pool(lock_lv)) {
 		/* Update lvm pool metadata (drop messages). */
@@ -6369,7 +6369,7 @@
 	int historical;
 
 	if (vg_max_lv_reached(vg))
-		stack;
+		log_stack;
 
 	if (strstr(name, "%d") &&
 	    !(name = generate_lv_name(vg, name, dname, sizeof(dname)))) {
@@ -7048,7 +7048,7 @@
 				  display_lvname(lock_lv));
 		return 0;
 	} else if (!(r = vg_commit(vg)))
-		stack; /* !vg_commit() has implict vg_revert() */
+		log_stack; /* !vg_commit() has implict vg_revert() */
 
 	log_very_verbose("Updating logical volume %s in kernel.",
 			 display_lvname(lock_lv));
@@ -7239,7 +7239,7 @@
 		}
 	}
 	if (lv_changed && !lv_merge_segments(lv))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -8514,7 +8514,7 @@
 				      lp->cache_mode,
 				      lp->policy_name,
 				      lp->policy_settings)) {
-			stack;
+			log_stack;
 			goto revert_new_lv;
 		}
 	} else if (lv_is_raid(lv) && !seg_is_any_raid0(first_seg(lv))) {
@@ -8527,7 +8527,7 @@
 		if ((first_seg(lv)->crop_metadata = lp->crop_metadata) == THIN_CROP_METADATA_NO)
 			lv->status |= LV_CROP_METADATA;
 		if (!recalculate_pool_chunk_size_with_dev_hints(lv, lp->thin_chunk_size_calc_policy)) {
-			stack;
+			log_stack;
 			goto revert_new_lv;
 		}
 		if (lp->error_when_full)
@@ -8567,7 +8567,7 @@
 		if (!add_mirror_log(cmd, lv, lp->log_count,
 				    first_seg(lv)->region_size,
 				    lp->pvh, lp->alloc)) {
-			stack;
+			log_stack;
 			goto revert_new_lv;
 		}
 	}
@@ -8678,7 +8678,7 @@
 			}
 			/* At this point remove pool messages, snapshot is active */
 			if (!update_pool_lv(pool_lv, 0)) {
-				stack;
+				log_stack;
 				goto revert_new_lv;
 			}
 		} else if (!dm_list_empty(&first_seg(pool_lv)->thin_messages)) {
@@ -8700,7 +8700,7 @@
 			}
 			/* Keep thin pool active until thin volume is activated */
 			if (!update_pool_lv(pool_lv, 1)) {
-				stack;
+				log_stack;
 				goto revert_new_lv;
 			}
 		}
@@ -8756,7 +8756,7 @@
 	if (seg_is_vdo_pool(lp)) {
 		if (!convert_vdo_pool_lv(lv, &lp->vdo_params, &lp->virtual_extents,
 					 1, lp->vdo_pool_header_size)) {
-			stack;
+			log_stack;
 			goto deactivate_and_revert_new_lv;
 		}
 		if ((lv->status & LV_ACTIVATION_SKIP) &&
@@ -8778,7 +8778,7 @@
 		} else {
 			if (!(tmp_lv = lv_cache_create(pool_lv, lv))) {
 				/* 'lv' still keeps created new LV */
-				stack;
+				log_stack;
 				goto deactivate_and_revert_new_lv;
 			}
 		}
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/metadata.c ./lib/metadata/metadata.c
--- ../LVM2.2.03.16.orig/lib/metadata/metadata.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/metadata.c	2022-06-30 16:18:11.113347290 +0200
@@ -376,7 +376,7 @@
 	if (find_pv_in_vg(vg, pv_name) ||
 	    find_pv_in_vg_by_uuid(vg, &pv->id)) {
 		if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-			stack;
+			log_stack;
 			uuid[0] = '\0';
 		}
 		log_error("Physical volume '%s (%s)' already in the VG.",
@@ -673,7 +673,7 @@
 	set_vg_notify(vg->cmd);
 
 	if (!backup_remove(vg->cmd, vg->name))
-		stack;
+		log_stack;
 
 	if (ret)
 		log_print_unless_silent("Volume group \"%s\" successfully removed", vg->name);
@@ -2002,7 +2002,7 @@
 
 	dm_list_iterate_items(lvl, &vg->lvs)
 		if (!_lv_postorder_visit(lvl->lv, fn, data)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
@@ -2307,7 +2307,7 @@
 					  sizeof(pvl->pv->id))) {
 			if (!id_write_format(&pvl->pv->id, uuid,
 					     sizeof(uuid)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Duplicate PV id "
 				  "%s detected for %s in %s.",
 				  uuid, pv_dev_name(pvl->pv),
@@ -2374,10 +2374,10 @@
 		if (!id_equal(&lvl->lv->lvid.id[0], &lvl->lv->vg->id)) {
 			if (!id_write_format(&lvl->lv->lvid.id[0], uuid,
 					     sizeof(uuid)))
-				stack;
+				log_stack;
 			if (!id_write_format(&lvl->lv->vg->id, uuid2,
 					     sizeof(uuid2)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "LV %s has VG UUID %s but its VG %s has UUID %s",
 				  lvl->lv->name, uuid, lvl->lv->vg->name, uuid2);
 			r = 0;
@@ -2474,7 +2474,7 @@
 					  sizeof(lvl->lv->lvid.id[1]))) {
 			if (!id_write_format(&lvl->lv->lvid.id[1], uuid,
 					     sizeof(uuid)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Duplicate LV id "
 				  "%s detected for %s in %s.",
 				  uuid, lvl->lv->name, vg->name);
@@ -2502,7 +2502,7 @@
 	}
 
 	if (!_lv_postorder_vg(vg, _lv_validate_references_single, &vhash)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -2541,7 +2541,7 @@
 	}
 
 	if (vg_max_lv_reached(vg))
-		stack;
+		log_stack;
 
 	if (!(vhash.lv_lock_args = dm_hash_create(lv_count))) {
 		log_error("Failed to allocate lv_lock_args hash");
@@ -2697,9 +2697,9 @@
 
 		if (!id_equal(&hlv->lvid.id[0], &hlv->vg->id)) {
 			if (!id_write_format(&hlv->lvid.id[0], uuid, sizeof(uuid)))
-				stack;
+				log_stack;
 			if (!id_write_format(&hlv->vg->id, uuid2, sizeof(uuid2)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Historical LV %s has VG UUID %s but its VG %s has UUID %s",
 				  hlv->name, uuid, hlv->vg->name, uuid2);
 			r = 0;
@@ -2708,7 +2708,7 @@
 
 		if (dm_hash_lookup_binary(vhash.historical_lvid, &hlv->lvid.id[1], sizeof(hlv->lvid.id[1]))) {
 			if (!id_write_format(&hlv->lvid.id[1], uuid,sizeof(uuid)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Duplicate historical LV id %s detected for %s in %s",
 				  uuid, hlv->name, vg->name);
                         r = 0;
@@ -3047,7 +3047,7 @@
 				log_warn("WARNING: Failed to write an MDA of VG %s.", vg->name);
 				mda->status |= MDA_FAILED;
 			} else {
-				stack;
+				log_stack;
 				revert = 1;
 				break;
 			}
@@ -3065,7 +3065,7 @@
 
 			if (mda->ops->vg_revert &&
 			    !mda->ops->vg_revert(vg->fid, vg, mda)) {
-				stack;
+				log_stack;
 			}
 		}
 		return 0;
@@ -3077,14 +3077,14 @@
 			continue;
 		if (mda->ops->vg_precommit &&
 		    !mda->ops->vg_precommit(vg->fid, vg, mda)) {
-			stack;
+			log_stack;
 			/* Revert */
 			dm_list_iterate_items(mda, &vg->fid->metadata_areas_in_use) {
 				if (mda->status & MDA_FAILED)
 					continue;
 				if (mda->ops->vg_revert &&
 				    !mda->ops->vg_revert(vg->fid, vg, mda)) {
-					stack;
+					log_stack;
 				}
 			}
 			return 0;
@@ -3116,7 +3116,7 @@
 			continue;
 		if (mda->ops->vg_commit &&
 		    !mda->ops->vg_commit(vg->fid, vg, mda)) {
-			stack;
+			log_stack;
 		} else
 			good++;
 	}
@@ -3179,7 +3179,7 @@
 	dm_list_iterate_items(mda, &vg->fid->metadata_areas_in_use) {
 		if (mda->ops->vg_revert &&
 		    !mda->ops->vg_revert(vg->fid, vg, mda)) {
-			stack;
+			log_stack;
 		}
 	}
 }
@@ -3199,7 +3199,7 @@
 	uint32_t ext_flags;
 
 	if (!(pv = _pv_read(b->cmd, b->fmt, b->vg, info))) {
-		stack;
+		log_stack;
 		return 1;
 	}
 
@@ -3226,7 +3226,7 @@
 
 	/*
 	if (!_check_or_repair_orphan_pv_ext(pv, info, baton)) {
-		stack;
+		log_stack;
 		return 0;
 	}
 	*/
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/mirror.c ./lib/metadata/mirror.c
--- ../LVM2.2.03.16.orig/lib/metadata/mirror.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/mirror.c	2022-06-30 16:18:12.003365703 +0200
@@ -1811,7 +1811,7 @@
 					  (region_size > lv->vg->extent_size) ?
 					  lv->vg->extent_size : region_size,
 					  alloc, mirror_in_sync()))) {
-		stack;
+		log_stack;
 		goto out_remove_images;
 	}
 
@@ -1823,7 +1823,7 @@
 		goto out_remove_log;
 
 	if (log_count && !attach_mirror_log(first_seg(lv), log_lv))
-		stack;
+		log_stack;
 
 	alloc_destroy(ah);
 	return 1;
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/raid_manip.c ./lib/metadata/raid_manip.c
--- ../LVM2.2.03.16.orig/lib/metadata/raid_manip.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/raid_manip.c	2022-06-30 16:18:11.390019682 +0200
@@ -675,7 +675,7 @@
 			  display_lvname(lock_lv));
 		vg_revert(vg);
 	} else if (!(r = vg_commit(vg)))
-		stack; /* !vg_commit() has implicit vg_revert() */
+		log_stack; /* !vg_commit() has implicit vg_revert() */
 
 	if (r && lv_list) {
 		dm_list_iterate_items(lvl, lv_list) {
@@ -2208,7 +2208,7 @@
 			  display_lvname(lv));
 		vg_revert(lv->vg);
 	} else if (!(r = vg_commit(vg)))
-		stack; /* !vg_commit() has implicit vg_revert() */
+		log_stack; /* !vg_commit() has implicit vg_revert() */
 
 	return r;
 }
@@ -4816,7 +4816,7 @@
 			  (new_stripes == 1)) ? SEG_TYPE_NAME_LINEAR : new_segtype->name);
 
 	if (!_log_possible_conversion_types(lv, new_segtype))
-		stack;
+		log_stack;
 
 	return 0;
 }
@@ -4829,7 +4829,7 @@
 		   (new_stripes == 1)) ? SEG_TYPE_NAME_LINEAR : new_segtype->name);
 
 	if (!_log_possible_conversion_types(lv, new_segtype))
-		stack;
+		log_stack;
 
 	return 0;
 }
@@ -7074,21 +7074,21 @@
 					lv_iorig = seg_lv(seg_image, 0);
 
 					if (dm_snprintf(tmp_name_buf, NAME_LEN, "%s_imeta", lv_image->name) < 0) {
-						stack;
+						log_stack;
 						continue;
 					}
 					if (!(tmp_name_dup = dm_pool_strdup(lv->vg->vgmem, tmp_name_buf))) {
-						stack;
+						log_stack;
 						continue;
 					}
 					lv_imeta->name = tmp_name_dup;
 
 					if (dm_snprintf(tmp_name_buf, NAME_LEN, "%s_iorig", lv_image->name) < 0) {
-						stack;
+						log_stack;
 						continue;
 					}
 					if (!(tmp_name_dup = dm_pool_strdup(lv->vg->vgmem, tmp_name_buf))) {
-						stack;
+						log_stack;
 						continue;
 					}
 					lv_iorig->name = tmp_name_dup;
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/thin_manip.c ./lib/metadata/thin_manip.c
--- ../LVM2.2.03.16.orig/lib/metadata/thin_manip.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/thin_manip.c	2022-06-30 16:18:11.070013061 +0200
@@ -565,7 +565,7 @@
 			activate = 0; /* Was already active */
 
 		if (!(ret = _check_pool_create(lv)))
-			stack; /* Safety guard, needs local presence of thin-pool target */
+			log_stack; /* Safety guard, needs local presence of thin-pool target */
 		else {
 			if (!(ret = suspend_lv_origin(lv->vg->cmd, lv)))
 				/* Send messages */
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/vg.c ./lib/metadata/vg.c
--- ../LVM2.2.03.16.orig/lib/metadata/vg.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/vg.c	2022-06-30 16:18:10.566669314 +0200
@@ -112,7 +112,7 @@
 	struct lv_list *lvl;
 
 	if (vg_max_lv_reached(vg))
-		stack;
+		log_stack;
 
 	if (!(lvl = dm_pool_zalloc(vg->vgmem, sizeof(*lvl))))
 		return_0;
diff -u -r ../LVM2.2.03.16.orig/lib/metadata/writecache_manip.c ./lib/metadata/writecache_manip.c
--- ../LVM2.2.03.16.orig/lib/metadata/writecache_manip.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/metadata/writecache_manip.c	2022-06-30 16:18:10.683338394 +0200
@@ -161,7 +161,7 @@
 	}
 
 	if (!(cvol_name_dup = dm_pool_strdup(vg->vgmem, cvol_name))) {
-		stack;
+		log_stack;
 		return;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/mirror/mirrored.c ./lib/mirror/mirrored.c
--- ../LVM2.2.03.16.orig/lib/mirror/mirrored.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/mirror/mirrored.c	2022-06-30 16:18:12.106701175 +0200
@@ -380,7 +380,7 @@
 		return_0;
 
 	if ((r = _add_log(mem, seg, laopts, node, area_count, region_size)) <= 0) {
-		stack;
+		log_stack;
 		return r;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/lib/misc/lvm-exec.c ./lib/misc/lvm-exec.c
--- ../LVM2.2.03.16.orig/lib/misc/lvm-exec.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/misc/lvm-exec.c	2022-06-30 16:18:12.283371495 +0200
@@ -171,7 +171,7 @@
 	if (pdata->pid == 0) {
 		/* Child -> writer, convert pipe[0] to STDOUT */
 		if (!_reopen_fd_to_null(STDIN_FILENO))
-			stack;
+			log_stack;
 		else if (close(pipefd[0 /*read*/]))
 			log_sys_error("close", "pipe[0]");
 		else if (close(STDOUT_FILENO))
diff -u -r ../LVM2.2.03.16.orig/lib/misc/lvm-file.c ./lib/misc/lvm-file.c
--- ../LVM2.2.03.16.orig/lib/misc/lvm-file.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/misc/lvm-file.c	2022-06-30 16:18:12.280038093 +0200
@@ -213,7 +213,7 @@
 		if (warn_if_read_only || (errno != EROFS && errno != EACCES))
 			log_sys_error("open", file);
 		else
-			stack;
+			log_stack;
 
 		return -1;
 	}
diff -u -r ../LVM2.2.03.16.orig/lib/misc/lvm-flock.c ./lib/misc/lvm-flock.c
--- ../LVM2.2.03.16.orig/lib/misc/lvm-flock.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/misc/lvm-flock.c	2022-06-30 16:18:12.340039335 +0200
@@ -241,7 +241,7 @@
 	else {
 		free(ll->res);
 		free(ll);
-		stack;
+		log_stack;
 	}
 
 	return r;
diff -u -r ../LVM2.2.03.16.orig/lib/misc/lvm-wrappers.c ./lib/misc/lvm-wrappers.c
--- ../LVM2.2.03.16.orig/lib/misc/lvm-wrappers.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/misc/lvm-wrappers.c	2022-06-30 16:18:12.233370461 +0200
@@ -123,12 +123,12 @@
 	if (read(fd, buf, len) != (ssize_t) len) {
 		log_sys_error("read", "read_urandom: /dev/urandom");
 		if (close(fd))
-			stack;
+			log_stack;
 		return 0;
 	}
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	return 1;
 }
diff -u -r ../LVM2.2.03.16.orig/lib/mm/memlock.c ./lib/mm/memlock.c
--- ../LVM2.2.03.16.orig/lib/mm/memlock.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/mm/memlock.c	2022-06-30 16:18:10.506668073 +0200
@@ -79,7 +79,7 @@
 
 #else				/* DEVMAPPER_SUPPORT */
 
-static size_t _size_stack;
+static size_t _size_log_stack;
 static size_t _size_malloc_tmp;
 static size_t _size_malloc = 2000000;
 
@@ -542,11 +542,11 @@
 		}
 
 		if (!_disable_mmap())
-			stack;
+			log_stack;
 	}
 
 	if (!_memlock_maps(cmd, LVM_MLOCK, &_mstats))
-		stack;
+		log_stack;
 }
 
 static void _unlock_mem(struct cmd_context *cmd)
@@ -556,7 +556,7 @@
 	log_very_verbose("Unlocking memory");
 
 	if (!_memlock_maps(cmd, LVM_MUNLOCK, &unlock_mstats))
-		stack;
+		log_stack;
 
 	if (!_use_mlockall) {
 		_restore_mmap();
diff -u -r ../LVM2.2.03.16.orig/lib/raid/raid.c ./lib/raid/raid.c
--- ../LVM2.2.03.16.orig/lib/raid/raid.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/raid/raid.c	2022-06-30 16:18:10.503334670 +0200
@@ -723,7 +723,7 @@
 		if ((segtype = _init_raid_segtype(cmd, &_raid_types[i], dso, monitored)) &&
 		    !lvm_register_segtype(seglib, segtype)) {
 			/* segtype is already destroyed */
-			stack;
+			log_stack;
 			r = 0;
 			break;
 		}
diff -u -r ../LVM2.2.03.16.orig/lib/report/properties.c ./lib/report/properties.c
--- ../LVM2.2.03.16.orig/lib/report/properties.c	2022-05-18 18:24:20.000000000 +0200
+++ ./lib/report/properties.c	2022-06-30 16:18:12.176702623 +0200
@@ -155,21 +155,21 @@
 
 	if (lv_is_cache(lv) || lv_is_used_cache_pool(lv)) {
 		if (!lv_cache_status(lv, &cache_status))
-			stack;
+			log_stack;
 		else {
 			percent = cache_status->data_usage;
 			dm_pool_destroy(cache_status->mem);
 		}
 	} else  if (lv_is_thin_volume(lv)) {
 		if (!lv_thin_status(lv, 0, &thin_status))
-			stack;
+			log_stack;
 		else {
 			percent = thin_status->usage;
 			dm_pool_destroy(thin_status->mem);
 		}
 	} else if (lv_is_thin_pool(lv)) {
 		if (!lv_thin_pool_status(lv, 0, &thin_pool_status))
-			stack;
+			log_stack;
 		else {
 			percent = thin_pool_status->data_usage;
 			dm_pool_destroy(thin_pool_status->mem);
@@ -187,14 +187,14 @@
 
 	if (lv_is_cache(lv) || lv_is_used_cache_pool(lv)) {
 		if (!lv_cache_status(lv, &cache_status))
-			stack;
+			log_stack;
 		else {
 			percent = cache_status->metadata_usage;
 			dm_pool_destroy(cache_status->mem);
 		}
 	} else if (lv_is_thin_pool(lv)) {
 		if (!lv_thin_pool_status(lv, 0, &thin_pool_status))
-			stack;
+			log_stack;
 		else {
 			percent = thin_pool_status->metadata_usage;
 			dm_pool_destroy(thin_pool_status->mem);
diff -u -r ../LVM2.2.03.16.orig/libdm/dm-tools/dmsetup.c ./libdm/dm-tools/dmsetup.c
--- ../LVM2.2.03.16.orig/libdm/dm-tools/dmsetup.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/dm-tools/dmsetup.c	2022-06-30 16:18:16.326788476 +0200
@@ -656,7 +656,7 @@
 	/* Final interval? */
 	if (_count == 2) {
 		if (close(_timer_fd))
-			stack;
+			log_stack;
 		/* Tell _update_interval_times() to shut down. */
 		_timer_fd = TIMER_STOPPED;
 	}
@@ -727,7 +727,7 @@
 		else if (errno == EINVAL)
 			log_error("Report interval too short.");
 		else
-			stack; /* other reason */
+			log_stack; /* other reason */
 		return 0;
 	}
 
@@ -3364,7 +3364,7 @@
 	if (private) {
 		if (!dm_device_get_name(info->major, info->minor,
 					1, buf, PATH_MAX)) {
-			stack;
+			log_stack;
 			goto out_abandon;
 		}
 	}
@@ -7253,9 +7253,9 @@
 		dm_log_init_verbose(_switches[VERBOSE_ARG] - 1);
 		if (_switches[VERBOSE_ARG] > 2) {
 			if (!(_initial_timestamp = dm_timestamp_alloc()))
-				stack;
+				log_stack;
 			else if (!dm_timestamp_get(_initial_timestamp))
-				stack;
+				log_stack;
 			else
 				log_debug("Timestamp:       0.000000000 seconds");
 		}
diff -u -r ../LVM2.2.03.16.orig/libdm/ioctl/libdm-iface.c ./libdm/ioctl/libdm-iface.c
--- ../LVM2.2.03.16.orig/libdm/ioctl/libdm-iface.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/ioctl/libdm-iface.c	2022-06-30 16:18:16.636794890 +0200
@@ -558,7 +558,7 @@
 
 	r = dm_task_run(task);
 	if (!dm_task_get_driver_version(task, version, size))
-		stack;
+		log_stack;
 	dm_task_destroy(task);
 	_log_suppress = 0;
 
@@ -1377,12 +1377,12 @@
 			continue;
 		if (!dm_task_set_name(dmt, dirent->d_name)) {
 			r = 0;
-			stack;
+			log_stack;
 			continue; /* try next name */
 		}
 		if (!dm_task_run(dmt)) {
 			r = 0;
-			stack;  /* keep going */
+			log_stack;  /* keep going */
 		}
 	}
 
@@ -1507,14 +1507,14 @@
 
 	/* Next load the table */
 	if (!(task = dm_task_create(DM_DEVICE_RELOAD))) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
 
 	/* Copy across relevant fields */
 	if (dmt->dev_name && !dm_task_set_name(task, dmt->dev_name)) {
-		stack;
+		log_stack;
 		dm_task_destroy(task);
 		_udev_complete(dmt);
 		goto revert;
@@ -1535,7 +1535,7 @@
 	dm_task_destroy(task);
 
 	if (!r) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
@@ -1569,7 +1569,7 @@
 		if (!dm_task_set_cookie(dmt, &cookie,
 					(dmt->event_nr & DM_UDEV_FLAGS_MASK) >>
 					DM_UDEV_FLAGS_SHIFT))
-			stack; /* keep going */
+			log_stack; /* keep going */
 	}
 
 	if (!dm_task_run(dmt))
@@ -1954,7 +1954,7 @@
 
 	if (dmt->record_timestamp)
 		if (!dm_timestamp_get(_dm_ioctl_timestamp))
-			stack;
+			log_stack;
 
 	if (r < 0 && dmt->expected_errno != errno) {
 		dmt->ioctl_errno = errno;
diff -u -r ../LVM2.2.03.16.orig/libdm/libdm-common.c ./libdm/libdm-common.c
--- ../LVM2.2.03.16.orig/libdm/libdm-common.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/libdm-common.c	2022-06-30 16:18:16.510125603 +0200
@@ -1810,7 +1810,7 @@
 	while (!feof(minfo) && fgets(buffer, sizeof(buffer), minfo))
 		if (!_mountinfo_parse_line(buffer, &maj, &min, target) ||
 		    !read_fn(buffer, maj, min, target, cb_data)) {
-			stack;
+			log_stack;
 			r = 0;
 			break;
 		}
@@ -2056,7 +2056,7 @@
 		if (_sysfs_get_dm_name(major, minor, buf, buf_size))
 			return 1;
 		else
-			stack;
+			log_stack;
 	}
 
 	/*
@@ -2150,7 +2150,7 @@
 	if ((major == data->maj) && (minor == data->min)) {
 		if (!dm_device_get_name(major, minor, 1, kernel_dev_name,
 					sizeof(kernel_dev_name))) {
-			stack;
+			log_stack;
 			*kernel_dev_name = '\0';
 		}
 		log_verbose("Device %s (%u:%u) appears to be mounted on %s.",
@@ -2170,7 +2170,7 @@
 	};
 
 	if (!dm_mountinfo_read(_device_has_mounted_fs, &data))
-		stack;
+		log_stack;
 
 	if (data.mounted)
 		return 1;
@@ -2573,7 +2573,7 @@
 			     gen_cookie, gen_semid, val);
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*semid = gen_semid;
 	*cookie = gen_cookie;
@@ -2582,7 +2582,7 @@
 
 bad:
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*cookie = 0;
 
diff -u -r ../LVM2.2.03.16.orig/libdm/libdm-deptree.c ./libdm/libdm-deptree.c
--- ../LVM2.2.03.16.orig/libdm/libdm-deptree.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/libdm-deptree.c	2022-06-30 16:18:16.583460454 +0200
@@ -602,7 +602,7 @@
 			"%s (" FMTu32 ":" FMTu32 ")",
 			dnode->name ? dnode->name : "",
 			dnode->info.major, dnode->info.minor) < 0) {
-		stack;
+		log_stack;
 		return dnode->name;
 	}
 
@@ -727,7 +727,7 @@
 
 	dm_list_iterate_items(dlink, list) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -946,7 +946,7 @@
 	/* Iterate through parents of this node */
 	dm_list_iterate_items(dlink, &node->used_by) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1209,7 +1209,7 @@
 	/* Can't recurse if not a mapped device or there are no dependencies */
 	if (!node->info.exists || !deps || !deps->count) {
 		if (!_add_to_bottomlevel(node)) {
-			stack;
+			log_stack;
 			node = NULL;
 		}
 		goto out;
@@ -1323,7 +1323,7 @@
 		dec_suspended();
 
 	if (!(r = dm_task_get_info(dmt, newinfo)))
-		stack;
+		log_stack;
 
 out:
 	dm_task_destroy(dmt);
@@ -1637,17 +1637,17 @@
 
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1677,7 +1677,7 @@
 
 			/* Check toplevel node for holders/mounted fs */
 			if (!_check_device_not_in_use(name, &info)) {
-				stack;
+				log_stack;
 				r = 0;
 				continue;
 			}
@@ -1717,7 +1717,7 @@
 		if (child->callback &&
 		    !child->callback(child, DM_NODE_CALLBACK_DEACTIVATED,
 				     child->callback_data))
-			stack;
+			log_stack;
 			/* FIXME Deactivation must currently ignore failure
 			 * here so that lvremove can continue: we need an
 			 * alternative way to handle this state without 
@@ -1754,17 +1754,17 @@
 	/* Suspend nodes at this level of the tree */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1785,7 +1785,7 @@
 		/* If child has some real messages send them */
 		if ((child->props.send_messages > 1) && r) {
 			if (!(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 			else {
 				log_debug_activation("Sent messages to thin-pool %s and "
 						     "skipping suspend of its children.",
@@ -1816,7 +1816,7 @@
 			continue;
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1864,7 +1864,7 @@
 			continue;
 
 		if (!(sibling_name = dm_tree_node_get_name(sibling))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1893,7 +1893,7 @@
 	/* Activate children first */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1914,7 +1914,7 @@
 				continue;
 
 			if (!(uuid = dm_tree_node_get_uuid(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -1922,7 +1922,7 @@
 				continue;
 
 			if (!(name = dm_tree_node_get_name(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -1965,7 +1965,7 @@
 			 */
 			if (r && (child->props.send_messages > 1) &&
 			    !(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 		}
 		if (awaiting_peer_rename)
 			priority--; /* redo priority level */
@@ -2049,7 +2049,7 @@
 do {\
 	int w;\
 	if ((w = dm_snprintf(params + p, paramsize - (size_t) p, str)) < 0) {\
-		stack; /* Out of space */\
+		log_stack; /* Out of space */\
 		return -1;\
 	}\
 	p += w;\
@@ -2686,7 +2686,7 @@
 		dm_free(params);
 
 		if (!ret)
-			stack;
+			log_stack;
 
 		if (ret >= 0)
 			return ret;
@@ -2814,7 +2814,7 @@
 static int _dm_tree_wait_and_revert_activated(struct dm_tree_node *dnode)
 {
 	if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-		stack;
+		log_stack;
 
 	dm_tree_set_cookie(dnode, 0);
 
@@ -2860,13 +2860,13 @@
 		if (!child->info.inactive_table &&
 		    child->props.segment_count &&
 		    !_load_node(child)) {
-			stack;
+			log_stack;
 			/*
 			 * If the table load fails, try to device in the kernel
 			 * together with other created and preloaded devices.
 			 */
 			if (!_dm_tree_wait_and_revert_activated(dnode))
-				stack;
+				log_stack;
 			r = 0;
 			continue;
 		}
@@ -2884,7 +2884,7 @@
 				  child->info.suspended)) {
 			log_error("Unable to resume %s.", _node_name(child));
 			if (!_dm_tree_wait_and_revert_activated(dnode))
-				stack;
+				log_stack;
 			r = 0;
 			continue;
 		}
@@ -2893,9 +2893,9 @@
 			/* When creating new node also check transaction_id. */
 			if (child->props.send_messages &&
 			    !_node_send_messages(child, uuid_prefix, uuid_prefix_len, 0)) {
-				stack;
+				log_stack;
 				if (!_dm_tree_wait_and_revert_activated(dnode))
-					stack;
+					log_stack;
 				r = 0;
 				continue;
 			}
@@ -2913,7 +2913,7 @@
 	if (update_devs_flag ||
 	    (r && !dnode->info.exists && dnode->callback)) {
 		if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-			stack;
+			log_stack;
 		dm_tree_set_cookie(dnode, 0);
 
 		if (r && !dnode->info.exists && dnode->callback &&
diff -u -r ../LVM2.2.03.16.orig/libdm/libdm-file.c ./libdm/libdm-file.c
--- ../LVM2.2.03.16.orig/libdm/libdm-file.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/libdm-file.c	2022-06-30 16:18:16.446790959 +0200
@@ -251,12 +251,12 @@
                log_error("Cannot check lock status of lockfile [%s], error was [%s]",
                          lockfile, strerror(errno));
                if (close(fd))
-                       stack;
+                       log_stack;
                return 0;
        }
 
        if (close(fd))
-               stack;
+               log_stack;
 
        return (lock.l_type == F_UNLCK) ? 0 : 1;
 }
diff -u -r ../LVM2.2.03.16.orig/libdm/libdm-report.c ./libdm/libdm-report.c
--- ../LVM2.2.03.16.orig/libdm/libdm-report.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/libdm-report.c	2022-06-30 16:18:16.440124155 +0200
@@ -835,7 +835,7 @@
 	}
 
 	if (!_copy_field(rh, fp, field_num, implicit)) {
-		stack;
+		log_stack;
 		dm_pool_free(rh->mem, fp);
 		return NULL;
 	}
diff -u -r ../LVM2.2.03.16.orig/libdm/libdm-stats.c ./libdm/libdm-stats.c
--- ../LVM2.2.03.16.orig/libdm/libdm-stats.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/libdm-stats.c	2022-06-30 16:18:16.446790959 +0200
@@ -148,12 +148,12 @@
 	if (!fgets(buf, sizeof(buf), comm)) {
 		log_error("Could not read from %s", PROC_SELF_COMM);
 		if (fclose(comm))
-			stack;
+			log_stack;
 		return NULL;
 	}
 
 	if (fclose(comm))
-		stack;
+		log_stack;
 
 	return dm_strdup(buf);
 }
@@ -838,7 +838,7 @@
 			if (*c == *v)
 				break;
 		if (!*v) {
-			stack;
+			log_stack;
 			goto badchar;
 		}
 
@@ -862,7 +862,7 @@
 			if (*c == ',')
 				c++;
 			else if (*c || (*c == ' ')) { /* Expected ',' or NULL. */
-				stack;
+				log_stack;
 				goto badchar;
 			}
 
@@ -1078,13 +1078,13 @@
 	_stats_update_groups(dms);
 
 	if (fclose(list_rows))
-		stack;
+		log_stack;
 
 	return 1;
 
 bad:
 	if (fclose(list_rows))
-		stack;
+		log_stack;
 	dm_pool_abandon_object(mem);
 	dm_pool_abandon_object(group_mem);
 
@@ -1347,14 +1347,14 @@
 	region->counters = dm_pool_end_object(mem);
 
 	if (fclose(stats_rows))
-		stack;
+		log_stack;
 
 	return 1;
 
 bad:
 	if (stats_rows)
 		if (fclose(stats_rows))
-			stack;
+			log_stack;
 	dm_pool_abandon_object(mem);
 
 	return 0;
@@ -3543,7 +3543,7 @@
 				break;
 
 		if (!*v) {
-			stack;
+			log_stack;
 			goto badchar;
 		}
 
@@ -3573,14 +3573,14 @@
 				else if (*c == 'n')
 					mult = 1;
 				else {
-					stack;
+					log_stack;
 					goto badchar;
 				}
 				c += 2; /* Advance over 'ms', 'us', or 'ns'. */
 			} else if (*c == ',')
 				c++;
 			else if (*c) { /* Expected ',' or NULL. */
-				stack;
+				log_stack;
 				goto badchar;
 			}
 
@@ -3649,7 +3649,7 @@
 	if (bounds->dms || bounds->region) {
 		log_error("Freeing invalid histogram bounds pointer %p.",
 			  (void *) bounds);
-		stack;
+		log_stack;
 	}
 	/* dm_free() expects a (void *). */
 	dm_free((void *) bounds);
diff -u -r ../LVM2.2.03.16.orig/libdm/libdm-timestamp.c ./libdm/libdm-timestamp.c
--- ../LVM2.2.03.16.orig/libdm/libdm-timestamp.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/libdm-timestamp.c	2022-06-30 16:18:16.383456316 +0200
@@ -54,7 +54,7 @@
 	struct dm_timestamp *ts = NULL;
 
 	if (!(ts = dm_zalloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
@@ -102,7 +102,7 @@
 	struct dm_timestamp *ts;
 
 	if (!(ts = dm_malloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
diff -u -r ../LVM2.2.03.16.orig/libdm/regex/parse_rx.c ./libdm/regex/parse_rx.c
--- ../LVM2.2.03.16.orig/libdm/regex/parse_rx.c	2022-05-18 18:24:20.000000000 +0200
+++ ./libdm/regex/parse_rx.c	2022-06-30 16:18:16.636794890 +0200
@@ -377,7 +377,7 @@
 		return l;
 
 	if (!(n = _node(ps->mem, CAT, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
@@ -400,7 +400,7 @@
 	}
 
 	if (!(n = _node(ps->mem, OR, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
diff -u -r ../LVM2.2.03.16.orig/tools/command.c ./tools/command.c
--- ../LVM2.2.03.16.orig/tools/command.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/command.c	2022-06-30 16:18:16.266787236 +0200
@@ -41,7 +41,7 @@
  */
 #ifdef MAN_PAGE_GENERATOR
 
-#define stack
+#define log_stack
 
 struct cmd_context {
 	void *libmem;
@@ -764,7 +764,7 @@
 
 			if (!def->str) {
 				/* FIXME */
-				stack;
+				log_stack;
 				return;
 			}
 		}
@@ -1515,7 +1515,7 @@
 
 			if (!cmd->name) {
 				/* FIXME */
-				stack;
+				log_stack;
 				return 0;
 			}
 
@@ -1548,7 +1548,7 @@
 
 				if (!newdesc) {
 					/* FIXME */
-					stack;
+					log_stack;
 					return 0;
 				}
 
@@ -1559,7 +1559,7 @@
 				cmd->desc = newdesc;
 			} else if (!(cmd->desc = dm_pool_strdup(cmdtool->libmem, line_orig))) {
 				/* FIXME */
-				stack;
+				log_stack;
 				return 0;
 			}
 
@@ -1589,7 +1589,7 @@
 
 			if (!cmd->command_id) {
 				/* FIXME */
-				stack;
+				log_stack;
 				return 0;
 			}
 			continue;
diff -u -r ../LVM2.2.03.16.orig/tools/dumpconfig.c ./tools/dumpconfig.c
--- ../LVM2.2.03.16.orig/tools/dumpconfig.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/dumpconfig.c	2022-06-30 16:18:16.056782891 +0200
@@ -331,7 +331,7 @@
 	}
 
 	if (!config_write(cft, &tree_spec, file, argc, argv)) {
-		stack;
+		log_stack;
 		r = ECMD_FAILED;
 	}
 out:
diff -u -r ../LVM2.2.03.16.orig/tools/lvchange.c ./tools/lvchange.c
--- ../LVM2.2.03.16.orig/tools/lvchange.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvchange.c	2022-06-30 16:18:15.996781651 +0200
@@ -404,7 +404,7 @@
 
 	if (!_vg_write_commit(lv, "intermediate")) {
 		if (!_reactivate_lv(lv, active, exclusive))
-			stack;
+			log_stack;
 		return 0;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/tools/lvconvert.c ./tools/lvconvert.c
--- ../LVM2.2.03.16.orig/tools/lvconvert.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvconvert.c	2022-06-30 16:18:16.186785581 +0200
@@ -685,7 +685,7 @@
 
 	if (removed) {
 		if (!vg_write(vg) || !vg_commit(vg)) {
-			stack;
+			log_stack;
 			return;
 		}
 		log_warn("WARNING: %d missing and now unallocated Physical Volumes removed from VG.", removed);
@@ -2492,7 +2492,7 @@
 
 	/* Try to allocate new pool metadata spare LV */
 	if (!handle_pool_metadata_spare(pool_lv->vg, 0, pvh, poolmetadataspare))
-		stack;
+		log_stack;
 
 	if (dm_snprintf(meta_path, sizeof(meta_path), "%s_meta%%d", pool_lv->name) < 0) {
 		log_error("Can't prepare new metadata name for %s.", pool_lv->name);
@@ -2681,7 +2681,7 @@
 
 	/* Try to allocate new pool metadata spare LV */
 	if (!handle_pool_metadata_spare(cache_lv->vg, 0, pvh, poolmetadataspare))
-		stack;
+		log_stack;
 
 	if (dm_snprintf(meta_path, sizeof(meta_path), "%s_meta%%d", cache_lv->name) < 0) {
 		log_error("Can't prepare new metadata name for %s.", cache_lv->name);
@@ -2814,7 +2814,7 @@
 	 */
 
 	if (!swap_lv_identifiers(cmd, thin_lv, lv)) {
-		stack;
+		log_stack;
 		goto revert_new_lv;
 	}
 
@@ -2822,12 +2822,12 @@
 	thin_lv->status |= (lv->status & LVM_WRITE);
 
 	if (!attach_thin_external_origin(first_seg(thin_lv), lv)) {
-		stack;
+		log_stack;
 		goto revert_new_lv;
 	}
 
 	if (!lv_update_and_reload(thin_lv)) {
-		stack;
+		log_stack;
 		goto deactivate_and_revert_new_lv;
 	}
 
@@ -2838,7 +2838,7 @@
 
 deactivate_and_revert_new_lv:
 	if (!swap_lv_identifiers(cmd, thin_lv, lv))
-		stack;
+		log_stack;
 
 	if (!deactivate_lv(cmd, thin_lv)) {
 		log_error("Unable to deactivate failed new LV. "
@@ -5632,7 +5632,7 @@
 			log_error("See lvchange --cachesettings cleaner=1");
 
 			if (!active_begin && active_clean && !deactivate_lv(cmd, lv))
-				stack;
+				log_stack;
 			return 0;
 		}
 
@@ -5675,7 +5675,7 @@
 	 * then deactivate before the detach.
 	 */
 	if (!active_begin && active_clean && !deactivate_lv(cmd, lv))
-		stack;
+		log_stack;
 
 	if (is_clean)
 		noflush = 1;
@@ -5763,7 +5763,7 @@
 		unlock_and_release_vg(cmd, vg, vg->name);
 
 		if (!lockd_vg(cmd, id->vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 
 		log_print_unless_silent("Detaching writecache cleaning %llu blocks", (unsigned long long)dirty);
 		log_print_unless_silent("This command can be cancelled and rerun to complete writecache detach.");
@@ -5778,7 +5778,7 @@
 		 * a flush message.
 		 */
 		if (!deactivate_lv(cmd, lv))
-			stack;
+			log_stack;
 	}
 
 	log_print("Detaching writecache completed cleaning.");
@@ -5816,7 +5816,7 @@
 
 out_lockd:
 	if (!lockd_vg(cmd, id->vg_name, "un", 0, &lockd_state))
-		stack;
+		log_stack;
 
 	return ret;
 }
@@ -5845,7 +5845,7 @@
 	}
 
 	if (!(ret = wipe_lv(lv, wp)))
-		stack;
+		log_stack;
 
 	if (!deactivate_lv(cmd, lv)) {
 		log_error("Failed to deactivate LV %s for zeroing.", display_lvname(lv));
@@ -6205,20 +6205,20 @@
 		if (!sync_local_dev_names(cmd)) {
 			log_error("Failed to sync local dev names.");
 			if (!deactivate_lv(cmd, lv))
-				stack;
+				log_stack;
 			goto bad;
 		}
 	}
 
 	if (!_set_writecache_block_size(cmd, lv, &block_size_sectors)) {
 		if (!is_active && !deactivate_lv(cmd, lv))
-			stack;
+			log_stack;
 		goto_bad;
 	}
 
 	if (!_check_writecache_memory(cmd, lv_fast, block_size_sectors)) {
 		if (!is_active && !deactivate_lv(cmd, lv))
-			stack;
+			log_stack;
 		goto_bad;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/tools/lvconvert_poll.c ./tools/lvconvert_poll.c
--- ../LVM2.2.03.16.orig/tools/lvconvert_poll.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvconvert_poll.c	2022-06-30 16:18:16.186785581 +0200
@@ -183,7 +183,7 @@
 		return PROGRESS_FINISHED_ALL; /* Already merged by someone else */
 
 	if (!lv_thin_device_id(lv, &device_id)) {
-		stack;
+		log_stack;
 		return PROGRESS_CHECK_FAILED;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/tools/lvcreate.c ./tools/lvcreate.c
--- ../LVM2.2.03.16.orig/tools/lvcreate.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvcreate.c	2022-06-30 16:18:16.056782891 +0200
@@ -1795,12 +1795,12 @@
 	int ret;
 
 	if (!_lvcreate_params(cmd, argc, argv, &lp, &lcp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
 	if (!_check_pool_parameters(cmd, NULL, &lp, &lcp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
@@ -1875,7 +1875,7 @@
 	};
 	int ret;
 	if (!_lvcreate_params(cmd, argc, argv, &lp, &lcp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
@@ -1948,7 +1948,7 @@
 	int ret;
 
 	if (!_lvcreate_params(cmd, argc, argv, &lp, &lcp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/tools/lvm.c ./tools/lvm.c
--- ../LVM2.2.03.16.orig/tools/lvm.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvm.c	2022-06-30 16:18:16.150118156 +0200
@@ -341,7 +341,7 @@
 
 	if (cmd->cmd_report.report_group) {
 		if (!dm_report_group_destroy(cmd->cmd_report.report_group))
-			stack;
+			log_stack;
 		cmd->cmd_report.report_group = NULL;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/tools/lvmcmdline.c ./tools/lvmcmdline.c
--- ../LVM2.2.03.16.orig/tools/lvmcmdline.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvmcmdline.c	2022-06-30 16:18:16.100117122 +0200
@@ -3225,7 +3225,7 @@
 
 	if ((ret = _process_common_commands(cmd))) {
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		goto out;
 	}
 
@@ -3316,10 +3316,10 @@
 	if (config_string_cft) {
 		/* Move this? */
 		if (!refresh_toolcontext(cmd))
-			stack;
+			log_stack;
 	} else if (config_profile_command_cft || config_profile_metadata_cft) {
 		if (!process_profilable_config(cmd))
-			stack;
+			log_stack;
 	}
 
 	if (ret == EINVALID_CMD_LINE && !cmd->is_interactive)
diff -u -r ../LVM2.2.03.16.orig/tools/lvmdevices.c ./tools/lvmdevices.c
--- ../LVM2.2.03.16.orig/tools/lvmdevices.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvmdevices.c	2022-06-30 16:18:16.150118156 +0200
@@ -265,7 +265,7 @@
 					log_print("Adding multipath device %s for multipath component %s.",
 						  dev_name(mpath_dev), dev_name(du->dev));
 					if (!device_id_add(cmd, mpath_dev, dev->pvid, NULL, NULL))
-						stack;
+						log_stack;
 				} else {
 					log_print("Missing multipath device %s for multipath component %s.",
 						  dev_name(mpath_dev), dev_name(du->dev));
diff -u -r ../LVM2.2.03.16.orig/tools/lvrename.c ./tools/lvrename.c
--- ../LVM2.2.03.16.orig/tools/lvrename.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvrename.c	2022-06-30 16:18:16.270120638 +0200
@@ -187,7 +187,7 @@
 	}
 
 	if (!apply_lvname_restrictions(lv_name_new)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/tools/lvresize.c ./tools/lvresize.c
--- ../LVM2.2.03.16.orig/tools/lvresize.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/lvresize.c	2022-06-30 16:18:16.150118156 +0200
@@ -203,7 +203,7 @@
 	int ret;
 
 	if (!_lvresize_params(cmd, argc, argv, &lp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
diff -u -r ../LVM2.2.03.16.orig/tools/polldaemon.c ./tools/polldaemon.c
--- ../LVM2.2.03.16.orig/tools/polldaemon.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/polldaemon.c	2022-06-30 16:18:16.100117122 +0200
@@ -228,7 +228,7 @@
 		unlock_and_release_vg(cmd, vg, vg->name);
 
 		if (!lockd_vg(cmd, id->vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 
 		wait_before_testing = 1;
 	}
@@ -239,7 +239,7 @@
 	if (vg)
 		unlock_and_release_vg(cmd, vg, vg->name);
 	if (!lockd_vg(cmd, id->vg_name, "un", 0, &lockd_state))
-		stack;
+		log_stack;
 
 	return ret;
 }
@@ -613,7 +613,7 @@
 
 	if (id) {
 		if (!wait_for_single_lv(cmd, id, parms)) {
-			stack;
+			log_stack;
 			ret = ECMD_FAILED;
 		}
 	} else {
diff -u -r ../LVM2.2.03.16.orig/tools/pvck.c ./tools/pvck.c
--- ../LVM2.2.03.16.orig/tools/pvck.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/pvck.c	2022-06-30 16:18:16.056782891 +0200
@@ -308,7 +308,7 @@
 	uint64_t mda2_offset;
 
 	if (dev_get_size(dev, &dev_sectors))
-		stack;
+		log_stack;
 
 	dev_bytes = dev_sectors * 512;
 	extra_bytes = dev_bytes % ONE_MB_IN_BYTES;
@@ -329,7 +329,7 @@
 	uint64_t mda2_size;
 
 	if (dev_get_size(dev, &dev_sectors))
-		stack;
+		log_stack;
 
 	dev_bytes = dev_sectors * 512;
 	extra_bytes = dev_bytes % ONE_MB_IN_BYTES;
@@ -640,9 +640,9 @@
 
 	if (fp) {
 		if (fflush(fp))
-			stack;
+			log_stack;
 		if (fclose(fp))
-			stack;
+			log_stack;
 	}
 
 	return 1;
@@ -877,9 +877,9 @@
 	free(meta_buf);
 
 	if (fflush(fp))
-		stack;
+		log_stack;
 	if (fclose(fp))
-		stack;
+		log_stack;
 	return ret;
 }
 
@@ -995,9 +995,9 @@
 		fprintf(fp, "%s", meta_buf);
 
 		if (fflush(fp))
-			stack;
+			log_stack;
 		if (fclose(fp))
-			stack;
+			log_stack;
 	}
 
  out:
@@ -1705,7 +1705,7 @@
 		uint64_t extra_bytes;
 
 		if (dev_get_size(dev, &dev_sectors))
-			stack;
+			log_stack;
 
 		dev_bytes = dev_sectors * 512;
 		extra_bytes = dev_bytes % ONE_MB_IN_BYTES;
@@ -2833,7 +2833,7 @@
 	}
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	if (!_is_backup_file(cmd, back_buf, back_size)) {
 		log_error("File does not appear to contain a metadata backup.");
@@ -2861,9 +2861,9 @@
 		fprintf(fp, "%s", text_buf);
 
 		if (fflush(fp))
-			stack;
+			log_stack;
 		if (fclose(fp))
-			stack;
+			log_stack;
 	}
 	ret = 1;
 out:
@@ -2873,7 +2873,7 @@
 
 fail_close:
 	if (close(fd))
-		stack;
+		log_stack;
 	return 0;
 }
 
@@ -2971,7 +2971,7 @@
 	text_buf[text_size++] = 0; /* null terminating byte */
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	if (_is_backup_file(cmd, text_buf, text_size)) {
 		char *back_buf = text_buf;
@@ -2999,7 +2999,7 @@
 
 out:
 	if (close(fd))
-		stack;
+		log_stack;
 	return 0;
 }
 
diff -u -r ../LVM2.2.03.16.orig/tools/pvmove.c ./tools/pvmove.c
--- ../LVM2.2.03.16.orig/tools/pvmove.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/pvmove.c	2022-06-30 16:18:16.186785581 +0200
@@ -547,7 +547,7 @@
 	r = activate_lv(cmd, lv_mirr);
 
 	if (!r)
-		stack;
+		log_stack;
 
 	return r;
 }
@@ -910,12 +910,12 @@
 
 		if (!is_abort) {
 			if (!pp.found_pv) {
-				stack;
+				log_stack;
 				return EINVALID_CMD_LINE;
 			}
 
 			if (pp.setup_result != ECMD_PROCESSED) {
-				stack;
+				log_stack;
 				return pp.setup_result;
 			}
 		} else {
diff -u -r ../LVM2.2.03.16.orig/tools/pvscan.c ./tools/pvscan.c
--- ../LVM2.2.03.16.orig/tools/pvscan.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/pvscan.c	2022-06-30 16:18:15.996781651 +0200
@@ -76,7 +76,7 @@
 
 	if (arg_is_set(cmd, uuid_ARG)) {
 		if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-			stack;
+			log_stack;
 			return ECMD_FAILED;
 		}
 
@@ -1264,7 +1264,7 @@
 			} else {
 				log_print_pvscan(cmd, "PV %s online, VG %s is complete.", dev_name(dev), vgname);
 				if (!str_list_add(cmd->mem, complete_vgnames, dm_pool_strdup(cmd->mem, vgname)))
-					stack;
+					log_stack;
 				vg_complete = 1;
 			}
 		}
@@ -1795,7 +1795,7 @@
 		ret = ECMD_FAILED;
 
 	if (!sync_local_dev_names(cmd))
-		stack;
+		log_stack;
 	return ret;
 }
 
diff -u -r ../LVM2.2.03.16.orig/tools/reporter.c ./tools/reporter.c
--- ../LVM2.2.03.16.orig/tools/reporter.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/reporter.c	2022-06-30 16:18:16.100117122 +0200
@@ -1186,7 +1186,7 @@
 out:
 	if (report_handle) {
 		if (report_in_group && !dm_report_group_pop(cmd->cmd_report.report_group))
-			stack;
+			log_stack;
 		dm_report_free(report_handle);
 	}
 
@@ -1214,14 +1214,14 @@
 	if (orphan) {
 		if (((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVSEGS])) != ECMD_PROCESSED))
-			stack;
+			log_stack;
 	} else {
 		if (((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_VGS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_LVS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVSEGS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_SEGS])) != ECMD_PROCESSED))
-			stack;
+			log_stack;
 	}
 
 	if (!args->log_only && !dm_report_group_pop(cmd->cmd_report.report_group))
@@ -1525,7 +1525,7 @@
 	return 1;
 bad:
 	if (!dm_report_group_destroy(new_report_group))
-		stack;
+		log_stack;
 	if (tmp_log_rh)
 		dm_report_free(tmp_log_rh);
 	return 0;
diff -u -r ../LVM2.2.03.16.orig/tools/toollib.c ./tools/toollib.c
--- ../LVM2.2.03.16.orig/tools/toollib.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/toollib.c	2022-06-30 16:18:16.270120638 +0200
@@ -332,7 +332,7 @@
 	if (dm_list_empty(&pv->segments)) {
 		ret = process_single_pvseg(cmd, NULL, &_free_pv_segment, handle);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		if (ret > ret_max)
 			ret_max = ret;
 	} else {
@@ -343,7 +343,7 @@
 			ret = process_single_pvseg(cmd, vg, pvseg, handle);
 			_update_selection_result(handle, &whole_selected);
 			if (ret != ECMD_PROCESSED)
-				stack;
+				log_stack;
 			if (ret > ret_max)
 				ret_max = ret;
 		}
@@ -371,7 +371,7 @@
 		ret = process_single_seg(cmd, seg, handle);
 		_update_selection_result(handle, &whole_selected);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		if (ret > ret_max)
 			ret_max = ret;
 	}
@@ -879,13 +879,13 @@
 	dm_list_iterate_items(lvl, &vg->lvs) {
 		if (sigint_caught()) {
 			r = 0;
-			stack;
+			log_stack;
 			break;
 		}
 
 		if (lv_is_visible(lvl->lv) && !lv_refresh(cmd, lvl->lv)) {
 			r = 0;
-			stack;
+			log_stack;
 		}
 	}
 
@@ -2029,7 +2029,7 @@
 
 		if (!cmd->is_interactive) {
 			if (!dm_report_group_destroy(cmd->cmd_report.report_group))
-				stack;
+				log_stack;
 			cmd->cmd_report.report_group = NULL;
 
 			if (cmd->cmd_report.log_rh) {
@@ -2149,7 +2149,7 @@
 			log_set_report_object_name_and_id(vg_name + sizeof(VG_ORPHANS), uuid);
 		} else {
 			if (vg_uuid && !id_write_format((const struct id*)vg_uuid, uuid, sizeof(uuid)))
-				stack;
+				log_stack;
 			log_set_report_object_name_and_id(vg_name, uuid);
 		}
 
@@ -2161,7 +2161,7 @@
 		log_very_verbose("Processing VG %s %s", vg_name, uuid);
 
 		if (!lockd_vg(cmd, vg_name, NULL, 0, &lockd_state)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			continue;
@@ -2169,7 +2169,7 @@
 
 		vg = vg_read(cmd, vg_name, vg_uuid, read_flags, lockd_state, &error_flags, &error_vg);
 		if (_ignore_vg(cmd, error_flags, error_vg, vg_name, arg_vgnames, read_flags, &skip, &notfound)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			if (error_vg)
@@ -2193,7 +2193,7 @@
 			ret = process_single_vg(cmd, vg_name, vg, handle);
 			_update_selection_result(handle, &whole_selected);
 			if (ret != ECMD_PROCESSED)
-				stack;
+				log_stack;
 			report_log_ret_code(ret);
 			if (ret > ret_max)
 				ret_max = ret;
@@ -2203,7 +2203,7 @@
 endvg:
 		release_vg(vg);
 		if (!lockd_vg(cmd, vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(NULL, NULL);
 	}
@@ -2262,7 +2262,7 @@
 			 */
 			if (lvmcache_vg_is_foreign(cmd, vgnl->vg_name, vgnl->vgid)) {
 				if (!id_write_format((const struct id*)vgnl->vgid, uuid, sizeof(uuid)))
-					stack;
+					log_stack;
 				dm_list_del(&vgnl->list);
 			} else {
 				found++;
@@ -3219,7 +3219,7 @@
 
 	vg_uuid[0] = '\0';
 	if (!id_write_format(&vg->id, vg_uuid, sizeof(vg_uuid)))
-		stack;
+		log_stack;
 
 	dm_list_init(&final_lvs);
 	dm_list_init(&found_arg_lvnames);
@@ -3252,7 +3252,7 @@
 	dm_list_iterate_items(lvl, &vg->lvs) {
 		lv_uuid[0] = '\0';
 		if (!id_write_format(&lvl->lv->lvid.id[1], lv_uuid, sizeof(lv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(lvl->lv->name, lv_uuid);
 
@@ -3354,7 +3354,7 @@
 	dm_list_iterate_items(lvl, &final_lvs) {
 		lv_uuid[0] = '\0';
 		if (!id_write_format(&lvl->lv->lvid.id[1], lv_uuid, sizeof(lv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(lvl->lv->name, lv_uuid);
 
@@ -3409,7 +3409,7 @@
 		if (handle_supplied)
 			_update_selection_result(handle, &whole_selected);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		report_log_ret_code(ret);
 		if (ret > ret_max)
 			ret_max = ret;
@@ -3429,7 +3429,7 @@
 		dm_list_iterate_items_safe(glvl, tglvl, &vg->historical_lvs) {
 			lv_uuid[0] = '\0';
 			if (!id_write_format(&glvl->glv->historical->lvid.id[1], lv_uuid, sizeof(lv_uuid)))
-				stack;
+				log_stack;
 
 			log_set_report_object_name_and_id(glvl->glv->historical->name, lv_uuid);
 
@@ -3461,7 +3461,7 @@
 			if (handle_supplied)
 				_update_selection_result(handle, &whole_selected);
 			if (ret != ECMD_PROCESSED)
-				stack;
+				log_stack;
 			report_log_ret_code(ret);
 			if (ret > ret_max)
 				ret_max = ret;
@@ -3598,7 +3598,7 @@
 				lv_name++;
 			if (!(vgname = extract_vgname(cmd, vgname))) {
 				if (ret_max < ECMD_FAILED) {
-					stack;
+					log_stack;
 					ret_max = ECMD_FAILED;
 				}
 				continue;
@@ -3815,7 +3815,7 @@
 
 		uuid[0] = '\0';
 		if (vg_uuid && !id_write_format((const struct id*)vg_uuid, uuid, sizeof(uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(vg_name, uuid);
 
@@ -3865,7 +3865,7 @@
 
 		vg = vg_read(cmd, vg_name, vg_uuid, read_flags, lockd_state, &error_flags, &error_vg);
 		if (_ignore_vg(cmd, error_flags, error_vg, vg_name, arg_vgnames, read_flags, &skip, &notfound)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			if (error_vg)
@@ -3881,7 +3881,7 @@
 		ret = process_each_lv_in_vg(cmd, vg, &lvnames, tags_arg, 0,
 					    handle, check_single_lv, process_single_lv);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		report_log_ret_code(ret);
 		if (ret > ret_max)
 			ret_max = ret;
@@ -3890,7 +3890,7 @@
 endvg:
 		release_vg(vg);
 		if (!lockd_vg(cmd, vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 		log_set_report_object_name_and_id(NULL, NULL);
 	}
 	do_report_ret_code = 0;
@@ -4330,7 +4330,7 @@
 
 	vg_uuid[0] = '\0';
 	if (!id_write_format(&vg->id, vg_uuid, sizeof(vg_uuid)))
-		stack;
+		log_stack;
 
 	if (!handle && (!(handle = init_processing_handle(cmd, NULL)))) {
 		ret_max = ECMD_FAILED;
@@ -4351,7 +4351,7 @@
 		pv_name = pv_dev_name(pv);
 		pv_uuid[0]='\0';
 		if (!id_write_format(&pv->id, pv_uuid, sizeof(pv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(pv_name, pv_uuid);
 
@@ -4406,7 +4406,7 @@
 			if (!skip) {
 				ret = process_single_pv(cmd, vg, pv, handle);
 				if (ret != ECMD_PROCESSED)
-					stack;
+					log_stack;
 				report_log_ret_code(ret);
 				if (ret > ret_max)
 					ret_max = ret;
@@ -4482,7 +4482,7 @@
 			log_set_report_object_name_and_id(vg_name + sizeof(VG_ORPHANS), uuid);
 		} else {
 			if (vg_uuid && !id_write_format((const struct id*)vg_uuid, uuid, sizeof(uuid)))
-				stack;
+				log_stack;
 			log_set_report_object_name_and_id(vg_name, uuid);
 		}
 
@@ -4503,7 +4503,7 @@
 
 		vg = vg_read(cmd, vg_name, vg_uuid, read_flags, lockd_state, &error_flags, &error_vg);
 		if (_ignore_vg(cmd, error_flags, error_vg, vg_name, NULL, read_flags, &skip, &notfound)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			if (!skip)
@@ -4522,7 +4522,7 @@
 					 process_all_pvs, skip, error_flags,
 					 handle, process_single_pv);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 
 		report_log_ret_code(ret);
 
@@ -4536,7 +4536,7 @@
 			unlock_and_release_vg(cmd, error_vg, vg_name);
 		release_vg(vg);
 		if (!lockd_vg(cmd, vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 
 		/* Quit early when possible. */
 		if (!process_all_pvs && dm_list_empty(arg_tags) && dm_list_empty(arg_devices)) {
@@ -4643,7 +4643,7 @@
 				  &arg_devices, &arg_tags, process_all_pvs,
 				  handle, process_single_pv);
 	if (ret != ECMD_PROCESSED)
-		stack;
+		log_stack;
 	if (ret > ret_max)
 		ret_max = ret;
 
@@ -4693,7 +4693,7 @@
 
 	vg_uuid[0] = '\0';
 	if (!id_write_format(&vg->id, vg_uuid, sizeof(vg_uuid)))
-		stack;
+		log_stack;
 
 	if (!is_orphan_vg(vg->name))
 		log_set_report_object_group_and_group_id(vg->name, vg_uuid);
@@ -4701,7 +4701,7 @@
 	dm_list_iterate_items(pvl, &vg->pvs) {
 		pv_uuid[0] = '\0';
 		if (!id_write_format(&pvl->pv->id, pv_uuid, sizeof(pv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(pv_dev_name(pvl->pv), pv_uuid);
 
@@ -4713,7 +4713,7 @@
 		ret = process_single_pv(cmd, vg, pvl->pv, handle);
 		_update_selection_result(handle, &whole_selected);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		report_log_ret_code(ret);
 		if (ret > ret_max)
 			ret_max = ret;
@@ -5926,7 +5926,7 @@
 
 	/* TODO: when vgcreate uses only existing PVs this doesn't change and can be skipped */
 	if (!device_ids_write(cmd))
-		stack;
+		log_stack;
 
 	/*
 	 * Don't keep devs open excl in bcache because the excl will prevent
diff -u -r ../LVM2.2.03.16.orig/tools/vgchange.c ./tools/vgchange.c
--- ../LVM2.2.03.16.orig/tools/vgchange.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/vgchange.c	2022-06-30 16:18:16.223453006 +0200
@@ -127,7 +127,7 @@
 		expected_count++;
 
 		if (!lv_change_activate(cmd, lv, activate)) {
-			stack;
+			log_stack;
 			r = 0;
 			continue;
 		}
@@ -150,7 +150,7 @@
 	 */
 	if (count && is_change_activating(activate) &&
 	    !vgchange_background_polling(cmd, vg)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -275,7 +275,7 @@
 	}
 
 	if (!_activate_lvs_in_vg(cmd, vg, activate)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -1362,7 +1362,7 @@
 		const char *start_opt = arg_str_value(cmd, lockopt_ARG, NULL);
 
 		if (!lockd_global(cmd, "un"))
-			stack;
+			log_stack;
 
 		if (!start_opt || !strcmp(start_opt, "auto")) {
 			if (vp.lock_start_sanlock)
diff -u -r ../LVM2.2.03.16.orig/tools/vgremove.c ./tools/vgremove.c
--- ../LVM2.2.03.16.orig/tools/vgremove.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/vgremove.c	2022-06-30 16:18:16.056782891 +0200
@@ -60,7 +60,7 @@
 
 		if ((ret = process_each_lv_in_vg(cmd, vg, NULL, NULL, 1, &void_handle,
 						 NULL, (process_single_lv_fn_t)lvremove_single)) != ECMD_PROCESSED) {
-			stack;
+			log_stack;
 			return ret;
 		}
 	}
diff -u -r ../LVM2.2.03.16.orig/tools/vgrename.c ./tools/vgrename.c
--- ../LVM2.2.03.16.orig/tools/vgrename.c	2022-05-18 18:24:20.000000000 +0200
+++ ./tools/vgrename.c	2022-06-30 16:18:16.153451558 +0200
@@ -108,7 +108,7 @@
 	dev_dir = cmd->dev_dir;
 
 	if (!lockd_rename_vg_before(cmd, vg)) {
-		stack;
+		log_stack;
 		goto error;
 	}
 
@@ -146,7 +146,7 @@
 	lockd_rename_vg_final(cmd, vg, 1);
 
 	if (!backup_remove(cmd, vg_name))
-		stack;
+		log_stack;
 
 	unlock_vg(cmd, vg, vp->vg_name_new);
 	vp->unlock_new_name = 0;
