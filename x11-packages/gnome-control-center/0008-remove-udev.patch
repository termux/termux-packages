--- a/meson.build
+++ b/meson.build
@@ -208,7 +208,14 @@ libxml_dep = dependency('libxml-2.0')
 pulse_dep = dependency('libpulse', version: pulse_req_version)
 pulse_mainloop_dep = dependency('libpulse-mainloop-glib', version: pulse_req_version)
 upower_glib_dep = dependency('upower-glib', version: '>= 1.90.6')
-gudev_dep = dependency('gudev-1.0', version: '>= 232')
+enable_udev = get_option('udev')
+if enable_udev.enabled()
+  gudev_dep = dependency('gudev-1.0', version: '>= 232')
+else
+   gudev_dep = dependency('', required: false)
+endif
+config_h.set('HAVE_UDEV', enable_udev.enabled(),
+             description: 'Defined if to build with udev support')
 epoxy_dep = dependency('epoxy')
 gcr_dep = dependency('gcr-4', version: '>= 4.1.0')
 
diff --git a/meson_options.txt b/meson_options.txt
index 8ea5c57..17f03ea 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -11,3 +11,4 @@ option('malcontent', type: 'boolean', value: false, description: 'build with mal
 option('distributor_logo', type: 'string', description: 'absolute path to distributor logo for the About panel')
 option('dark_mode_distributor_logo', type: 'string', description: 'absolute path to distributor logo dark mode variant')
 option('polkit', type: 'boolean', value: true, description: 'Enable polkit support')
+option('udev', type: 'feature', value: 'enabled', description: 'Enable udev support')
diff --git a/panels/common/gsd-device-manager.c b/panels/common/gsd-device-manager.c
index 5a5002e..f0d893a 100644
--- a/panels/common/gsd-device-manager.c
+++ b/panels/common/gsd-device-manager.c
@@ -22,7 +22,9 @@
 #include "config.h"
 
 #include <string.h>
+#ifdef HAVE_UDEV
 #include <gudev/gudev.h>
+#endif
 
 #include "gsd-device-manager.h"
 #include "gsd-common-enums.h"
@@ -53,8 +55,10 @@ G_DEFINE_TYPE_WITH_PRIVATE (GsdDevice, gsd_device, G_TYPE_OBJECT)
 typedef struct
 {
         GObject parent_instance;
+#ifdef HAVE_UDEV
 	GHashTable *devices;
 	GUdevClient *udev_client;
+#endif
 } GsdDeviceManagerPrivate;
 
 enum {
@@ -75,6 +79,7 @@ enum {
 	N_SIGNALS
 };
 
+#ifdef HAVE_UDEV
 /* Index matches GsdDeviceType */
 const gchar *udev_ids[] = {
 	"ID_INPUT_MOUSE",
@@ -84,6 +89,7 @@ const gchar *udev_ids[] = {
 	"ID_INPUT_TOUCHSCREEN",
 	"ID_INPUT_TABLET_PAD",
 };
+#endif
 
 static guint signals[N_SIGNALS] = { 0 };
 
@@ -272,10 +278,10 @@ gsd_device_manager_finalize (GObject *object)
 {
 	GsdDeviceManager *manager = GSD_DEVICE_MANAGER (object);
         GsdDeviceManagerPrivate *priv = gsd_device_manager_get_instance_private (manager);
-
+#ifdef HAVE_UDEV
 	g_hash_table_destroy (priv->devices);
 	g_object_unref (priv->udev_client);
-
+#endif
 	G_OBJECT_CLASS (gsd_device_manager_parent_class)->finalize (object);
 }
 
@@ -283,6 +289,7 @@ static GList *
 gsd_device_manager_real_list_devices (GsdDeviceManager *manager,
 				      GsdDeviceType	type)
 {
+#ifdef HAVE_UDEV
         GsdDeviceManagerPrivate *priv = gsd_device_manager_get_instance_private (manager);
 	GsdDeviceType device_type;
 	GList *devices = NULL;
@@ -299,12 +306,16 @@ gsd_device_manager_real_list_devices (GsdDeviceManager *manager,
 	}
 
 	return devices;
+#else
+	return NULL;
+#endif
 }
 
 static GsdDevice *
 gsd_device_manager_real_lookup_device (GsdDeviceManager *manager,
                                        GdkDevice	*gdk_device)
 {
+#ifdef HAVE_UDEV
 	GsdDeviceManagerPrivate *priv = gsd_device_manager_get_instance_private (manager);
 	GdkDisplay *display = gdk_device_get_display (gdk_device);
 	const gchar *node_path = NULL;
@@ -351,6 +362,9 @@ gsd_device_manager_real_lookup_device (GsdDeviceManager *manager,
 	}
 
 	return NULL;
+#else
+	return NULL;
+#endif
 }
 
 static void
@@ -391,6 +405,7 @@ gsd_device_manager_class_init (GsdDeviceManagerClass *klass)
 			      GSD_TYPE_DEVICE | G_SIGNAL_TYPE_STATIC_SCOPE);
 }
 
+#ifdef HAVE_UDEV
 static GsdDeviceType
 udev_device_get_device_type (GUdevDevice *device)
 {
@@ -505,10 +520,12 @@ udev_event_cb (GUdevClient	*client,
 		remove_device (manager, device);
 	}
 }
+#endif
 
 static void
 gsd_device_manager_init (GsdDeviceManager *manager)
 {
+#ifdef HAVE_UDEV
         GsdDeviceManagerPrivate *priv = gsd_device_manager_get_instance_private (manager);
 	const gchar *subsystems[] = { "input", NULL };
 	g_autoptr(GList) devices = NULL;
@@ -531,6 +548,7 @@ gsd_device_manager_init (GsdDeviceManager *manager)
 		if (device_is_evdev (device))
 			add_device (manager, device);
 	}
+#endif
 }
 
 GsdDeviceManager *
diff --git a/panels/system/about/cc-system-details-window.c b/panels/system/about/cc-system-details-window.c
index 028ed1d..05c87f5 100644
--- a/panels/system/about/cc-system-details-window.c
+++ b/panels/system/about/cc-system-details-window.c
@@ -34,7 +34,9 @@
 #include <glibtop/mem.h>
 #include <glibtop/sysinfo.h>
 #include <udisks/udisks.h>
+#ifdef HAVE_UDEV
 #include <gudev/gudev.h>
+#endif
 
 #include <gdk/gdk.h>
 
@@ -623,6 +625,7 @@ get_ram_size_libgtop (void)
   return mem.total;
 }
 
+#ifdef HAVE_UDEV
 guint64
 get_ram_size_dmi (void)
 {
@@ -646,6 +649,14 @@ get_ram_size_dmi (void)
   }
   return ram_total;
 }
+#else
+guint64
+get_ram_size_dmi (void)
+{
+  /* udev not available, return 0 to fall back to libgtop */
+  return 0;
+}
+#endif
 
 static void
 system_details_window_title_print_padding (const gchar *title, GString *dst_string, gsize maxlen)
