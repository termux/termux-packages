From 8b6d4e7552132d1c536d39ae7111ef1692fafe5a Mon Sep 17 00:00:00 2001
From: Chongyun Lee <licy183@termux.dev>
Date: Wed, 29 Jan 2025 22:54:37 +0800
Subject: [PATCH] Fixes for jumbo build

Based on https://github.com/qt/qtwebengine-chromium/commit/93e068edee318bb23af7a5a85b12d629123491fc

---
 base/BUILD.gn                                 |  11 ++
 base/task/sequence_manager/task_order.cc      |  10 +-
 base/task/single_thread_task_runner.cc        |  18 +--
 build/config/jumbo.gni                        |   2 +-
 cc/metrics/compositor_frame_reporter.cc       |  16 +-
 .../compositor_frame_reporting_controller.cc  |  14 +-
 cc/metrics/frame_sequence_tracker.cc          |   6 +-
 cc/metrics/jank_injector.cc                   |   4 +-
 cc/metrics/jank_metrics.cc                    |   8 +-
 components/guest_view/browser/BUILD.gn        |   4 +-
 components/guest_view/renderer/BUILD.gn       |   4 +-
 components/metrics/metrics_log.cc             |   4 +-
 components/metrics/metrics_state_manager.cc   |   4 +-
 components/performance_manager/BUILD.gn       |   4 +-
 .../decorators/page_live_state_decorator.cc   |   4 +-
 .../decorators/page_load_tracker_decorator.cc |   4 +-
 .../frame_audible_voter.cc                    |   8 +-
 .../frame_visibility_voter.cc                 |  16 +-
 .../inherit_client_priority_voter.cc          |  36 ++---
 .../graph/frame_node_impl_describer.cc        |   4 +-
 .../graph/page_node_impl_describer.cc         |   4 +-
 .../graph/process_node_impl_describer.cc      |   4 +-
 .../graph/worker_node_impl_describer.cc       |   4 +-
 .../performance_manager_registry_impl.cc      |  14 +-
 .../site_data/site_data_cache_factory.cc      |  12 +-
 .../core/common/policy_proto_decoders.cc      |   4 +-
 components/printing/browser/BUILD.gn          |   4 +-
 components/storage_monitor/BUILD.gn           |   3 +-
 components/viz/common/BUILD.gn                |   1 +
 components/viz/service/BUILD.gn               |  14 ++
 .../display/display_resource_provider.h       |   2 +-
 .../skia_output_device_webview.cc             |   8 +-
 .../transferable_resource_tracker.cc          |   2 +-
 content/browser/BUILD.gn                      | 152 +++++++++++-------
 .../attribution_internals_handler_impl.cc     |  10 +-
 .../attribution_storage_sql.cc                |   4 +-
 .../cookie_change_subscription.cc             |   7 +-
 content/browser/devtools/BUILD.gn             |   2 +-
 .../browser/devtools/protocol/page_handler.cc |   4 +-
 .../web_contents_devtools_agent_host.cc       |  18 +--
 .../first_party_set_parser.cc                 |   2 +-
 .../first_party_sets_handler_impl.cc          |   6 +-
 content/browser/gpu/compositor_util.cc        |  16 +-
 content/browser/gpu/gpu_process_host.cc       |   2 +-
 .../interest_group_manager_impl.cc            |   4 +-
 .../interest_group_permissions_checker.cc     |   4 +-
 .../media/media_internals_cdm_helper.cc       |   4 +-
 .../cross_origin_embedder_policy_reporter.cc  |   6 +-
 .../prerender/prerender_host_registry.cc      |   2 +-
 .../push_messaging/push_messaging_router.cc   |   4 +-
 .../agent_scheduling_group_host.cc            |  32 ++--
 .../renderer_host/code_cache_host_impl.h      |   6 +-
 .../media/media_stream_manager.cc             |  88 +++++-----
 .../media/media_stream_power_logger.cc        |  10 +-
 .../pepper_internal_file_ref_backend.cc       |   4 +-
 .../renderer_host/render_frame_proxy_host.cc  |  12 +-
 .../embedded_worker_instance.cc               |   4 +-
 .../service_worker_context_wrapper.cc         |   6 +-
 ...rvice_worker_controllee_request_handler.cc |  16 +-
 content/child/BUILD.gn                        |   5 +-
 content/common/BUILD.gn                       |   8 +-
 .../pepper/pepper_plugin_instance_impl.h      |   5 +
 .../web_service_worker_provider_impl.cc       |   8 +-
 dbus/message.cc                               |   4 +-
 device/fido/cable/cable_discovery_data.h      |   2 +-
 .../fido/public_key_credential_descriptor.h   |   4 +-
 device/fido/public_key_credential_params.h    |   4 +-
 device/fido/public_key_credential_rp_entity.h |   4 +-
 .../fido/public_key_credential_user_entity.h  |   4 +-
 .../webrequest_condition.cc                   |  16 +-
 .../webrequest_condition_attribute.cc         |  82 +++++-----
 .../api/hid/hid_connection_resource.cc        |   4 +-
 .../browser/api/hid/hid_device_manager.cc     |   6 +-
 .../browser/api/usb/usb_device_manager.cc     |   4 +-
 .../browser/api/usb/usb_device_resource.cc    |   4 +-
 .../api/web_request/upload_data_presenter.cc  |   6 +-
 .../api/web_request/web_request_api.cc        | 134 +++++++--------
 .../api/web_request/web_request_info.cc       |   8 +-
 ...web_request_proxying_url_loader_factory.cc |  18 +--
 .../web_request_proxying_url_loader_factory.h |   2 +-
 extensions/browser/app_window/app_window.cc   |   4 +-
 .../browser/extension_message_filter.cc       |  20 +--
 ...extension_service_worker_message_filter.cc |  20 +--
 extensions/common/BUILD.gn                    |   5 +
 .../manifest_handlers/shared_module_info.cc   |  10 +-
 gpu/command_buffer/service/BUILD.gn           |   7 +-
 gpu/config/BUILD.gn                           |   3 +-
 .../h265_to_annex_b_bitstream_converter.cc    |  30 ++--
 .../mac/audio_toolbox_audio_encoder.cc        |   8 +-
 media/filters/media_file_checker.cc           |   4 +-
 .../services/gpu_mojo_media_client_cros.cc    |   5 +-
 .../services/gpu_mojo_media_client_mac.cc     |   3 +-
 .../services/gpu_mojo_media_client_stubs.cc   |   4 +-
 .../services/gpu_mojo_media_client_win.cc     |   3 +-
 mojo/public/tools/bindings/mojom.gni          |   5 +-
 services/network/public/cpp/BUILD.gn          |   5 +
 .../web_bundle_url_loader_factory.cc          |   4 +-
 storage/browser/BUILD.gn                      |   4 +
 storage/browser/blob/blob_url_registry.cc     |   8 +-
 storage/browser/quota/quota_settings.cc       |   9 +-
 .../common/frame/user_activation_state.cc     |   4 +-
 .../common/user_agent/user_agent_metadata.cc  |   6 +-
 .../scripts/bind_gen/callback_interface.py    |   1 +
 .../bindings/scripts/bind_gen/interface.py    |  33 +++-
 third_party/blink/renderer/core/BUILD.gn      |  13 +-
 .../blink/renderer/core/animation/BUILD.gn    |   3 +
 .../css_shadow_list_interpolation_type.cc     |   2 +-
 .../css/box_shadow_paint_image_generator.cc   |  10 +-
 .../css/clip_path_paint_image_generator.cc    |  10 +-
 .../core/frame/local_frame_mojo_handler.cc    |   4 +-
 .../renderer/core/frame/sticky_ad_detector.cc |   8 +-
 .../core/html/forms/html_input_element.cc     |   6 +-
 .../core/html/forms/html_text_area_element.cc |   6 +-
 .../core/html/parser/html_tree_builder.cc     |   4 +-
 .../renderer/core/html/track/cue_timeline.cc  |   2 +-
 .../renderer/core/html/track/text_track.cc    |   4 +-
 .../core/imagebitmap/image_bitmap_source.cc   |   4 +-
 .../core/layout/flexible_box_algorithm.cc     |   8 +-
 .../core/layout/flexible_box_algorithm.h      |   4 +-
 .../ng/flex/ng_flex_layout_algorithm.cc       |  50 +++---
 .../core/layout/ng/grid/ng_grid_item.cc       |   4 +-
 .../core/layout/ng/grid/ng_grid_item.h        |   6 +-
 .../ng/grid/ng_grid_layout_algorithm.cc       |  18 +--
 .../ng_math_scripts_layout_algorithm.cc       |   4 +-
 .../core/layout/ng/ng_baseline_utils.h        |  10 +-
 .../blink/renderer/core/page/drag_image.cc    |   3 +
 .../core/paint/ng/ng_highlight_painter.cc     |  14 +-
 .../core/paint/pre_paint_tree_walk.cc         |   4 +-
 .../speculation_rules/speculation_rule_set.cc |  44 ++---
 .../core/timing/performance_timing.cc         |   6 +-
 .../inspector_type_builder_helper.cc          |   6 +-
 .../modules/bluetooth/bluetooth_device.cc     |   6 +-
 ...edia_stream_video_track_underlying_sink.cc |   6 +-
 .../blink/renderer/modules/canvas/BUILD.gn    |   4 +
 .../credentials_container.cc                  |  30 ++--
 .../federated_credential.cc                   |   4 +-
 .../identity_credential.cc                    |   4 +-
 .../credentialmanagement/otp_credential.cc    |   6 +-
 .../blink/renderer/modules/hid/hid_device.cc  |   6 +-
 .../modules/mediarecorder/h264_encoder.cc     |  12 +-
 .../modules/mediarecorder/vpx_encoder.cc      |  58 ++++---
 .../renderer/modules/mediastream/BUILD.gn     |   7 +
 .../modules/payments/payment_instruments.cc   |  14 +-
 .../renderer/modules/peerconnection/BUILD.gn  |   6 +
 .../peerconnection/rtc_peer_connection.cc     |   6 +-
 .../renderer/modules/permissions/BUILD.gn     |   1 +
 .../modules/webaudio/analyser_handler.cc      |   8 +-
 .../webaudio/audio_buffer_source_handler.cc   |   4 +-
 .../modules/webaudio/audio_worklet_handler.cc |   4 +-
 .../modules/webaudio/biquad_filter_node.cc    |   4 +-
 .../webaudio/constant_source_handler.cc       |   4 +-
 .../modules/webaudio/convolver_handler.cc     |   4 +-
 .../webaudio/dynamics_compressor_handler.cc   |   6 +-
 .../modules/webaudio/iir_filter_handler.cc    |   4 +-
 .../media_element_audio_source_handler.cc     |   4 +-
 .../modules/webaudio/oscillator_handler.cc    |   4 +-
 .../webaudio/realtime_audio_worklet_thread.cc |  16 +-
 .../semi_realtime_audio_worklet_thread.cc     |  16 +-
 .../modules/webaudio/stereo_panner_handler.cc |  16 +-
 .../modules/webaudio/wave_shaper_handler.cc   |   4 +-
 .../blink/renderer/modules/webcodecs/BUILD.gn |   5 +
 .../modules/webcodecs/decoder_template.cc     |  18 +--
 .../modules/webcodecs/encoder_base.cc         |  20 +--
 .../webcodecs/gpu_factories_retriever.cc      |   6 +-
 .../blink/renderer/modules/webgpu/BUILD.gn    |   2 +
 third_party/blink/renderer/platform/BUILD.gn  |   9 ++
 .../cpu/x86/audio_delay_dsp_kernel_sse2.cc    |   2 +
 .../renderer/platform/audio/hrtf_panner.cc    |  16 +-
 .../platform/fonts/shaping/harfbuzz_shaper.cc |  22 +--
 .../compositing/paint_artifact_compositor.cc  |   2 +-
 .../image-decoders/jpeg/jpeg_image_decoder.cc |   4 +
 .../platform/loader/web_url_request_util.cc   |   1 +
 .../stats_collecting_decoder.cc               |  12 +-
 .../widget/compositing/layer_tree_view.cc     |   4 +-
 .../input/elastic_overscroll_controller.cc    |   2 +-
 .../widget/input/widget_base_input_handler.cc |   4 +-
 ui/base/BUILD.gn                              |   4 +
 ui/base/ime/win/BUILD.gn                      |   1 +
 ui/base/x/BUILD.gn                            |   3 +-
 ui/color/BUILD.gn                             |   7 +-
 ui/gfx/geometry/transform_operations.cc       |   6 +-
 ui/gl/BUILD.gn                                |   4 +
 ui/gl/direct_composition_surface_win.cc       |   6 +-
 ui/native_theme/BUILD.gn                      |   9 +-
 184 files changed, 1035 insertions(+), 878 deletions(-)

diff --git a/base/BUILD.gn b/base/BUILD.gn
index e0139a879..8eb16b4fc 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -1404,6 +1404,11 @@ jumbo_component("base") {
     ]
   }
 
+  jumbo_excluded_sources = [
+      "logging.cc",
+      "strings/string_piece.cc",
+  ]
+
   if (is_linux || is_chromeos) {
     sources += [
       "debug/proc_maps_linux.cc",
@@ -1421,6 +1426,7 @@ jumbo_component("base") {
       "threading/thread_type_delegate.cc",
       "threading/thread_type_delegate.h",
     ]
+    jumbo_excluded_sources += [ "process/memory_linux.cc" ]
   }
 
   if (is_linux || is_chromeos || is_android || is_fuchsia) {
@@ -2097,6 +2103,11 @@ jumbo_component("base") {
       "file_descriptor_store.h",
     ]
 
+    # winternl.h and NTSecAPI.h have different definitions of UNICODE_STRING.
+    # There's only one client of NTSecAPI.h in base but several of winternl.h,
+    # so exclude the NTSecAPI.h one.
+    jumbo_excluded_sources += [ "rand_util_win.cc" ]
+
     deps += [ "//base/win:base_win_buildflags" ]
 
     data_deps += [ "//build/win:runtime_libs" ]
diff --git a/base/task/sequence_manager/task_order.cc b/base/task/sequence_manager/task_order.cc
index b2bdae4e9..1e9635b28 100644
--- a/base/task/sequence_manager/task_order.cc
+++ b/base/task/sequence_manager/task_order.cc
@@ -17,7 +17,7 @@ namespace {
 // Returns true iff `task_order1` Comparator{} `task_order2`. Used to
 // implement other comparison operators.
 template <typename Comparator>
-static bool Compare(const base::sequence_manager::TaskOrder& task_order1,
+static bool CompareTO(const base::sequence_manager::TaskOrder& task_order1,
                     const base::sequence_manager::TaskOrder& task_order2) {
   Comparator cmp{};
 
@@ -60,19 +60,19 @@ TaskOrder& TaskOrder::operator=(const TaskOrder& other) = default;
 TaskOrder::~TaskOrder() = default;
 
 bool TaskOrder::operator>(const TaskOrder& other) const {
-  return Compare<std::greater<>>(*this, other);
+  return CompareTO<std::greater<>>(*this, other);
 }
 
 bool TaskOrder::operator<(const TaskOrder& other) const {
-  return Compare<std::less<>>(*this, other);
+  return CompareTO<std::less<>>(*this, other);
 }
 
 bool TaskOrder::operator<=(const TaskOrder& other) const {
-  return Compare<std::less_equal<>>(*this, other);
+  return CompareTO<std::less_equal<>>(*this, other);
 }
 
 bool TaskOrder::operator>=(const TaskOrder& other) const {
-  return Compare<std::greater_equal<>>(*this, other);
+  return CompareTO<std::greater_equal<>>(*this, other);
 }
 
 bool TaskOrder::operator==(const TaskOrder& other) const {
diff --git a/base/task/single_thread_task_runner.cc b/base/task/single_thread_task_runner.cc
index ebf286712..ca1f9279e 100644
--- a/base/task/single_thread_task_runner.cc
+++ b/base/task/single_thread_task_runner.cc
@@ -21,7 +21,7 @@ namespace base {
 namespace {
 
 ThreadLocalPointer<SingleThreadTaskRunner::CurrentDefaultHandle>&
-CurrentDefaultHandleTls() {
+CurrentDefaultHandleTls2() {
   static NoDestructor<
       ThreadLocalPointer<SingleThreadTaskRunner::CurrentDefaultHandle>>
       instance;
@@ -34,7 +34,7 @@ CurrentDefaultHandleTls() {
 const scoped_refptr<SingleThreadTaskRunner>&
 SingleThreadTaskRunner::GetCurrentDefault() {
   const SingleThreadTaskRunner::CurrentDefaultHandle* current_default =
-      CurrentDefaultHandleTls().Get();
+      CurrentDefaultHandleTls2().Get();
   CHECK(current_default)
       << "Error: This caller requires a single-threaded context (i.e. the "
          "current task needs to run from a SingleThreadTaskRunner). If you're "
@@ -50,7 +50,7 @@ SingleThreadTaskRunner::GetCurrentDefault() {
 
 // static
 bool SingleThreadTaskRunner::HasCurrentDefault() {
-  return !!CurrentDefaultHandleTls().Get();
+  return !!CurrentDefaultHandleTls2().Get();
 }
 
 SingleThreadTaskRunner::CurrentDefaultHandle::CurrentDefaultHandle(
@@ -58,14 +58,14 @@ SingleThreadTaskRunner::CurrentDefaultHandle::CurrentDefaultHandle(
     : task_runner_(std::move(task_runner)),
       sequenced_task_runner_current_default_(task_runner_) {
   DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK(!CurrentDefaultHandleTls().Get());
-  CurrentDefaultHandleTls().Set(this);
+  DCHECK(!CurrentDefaultHandleTls2().Get());
+  CurrentDefaultHandleTls2().Set(this);
 }
 
 SingleThreadTaskRunner::CurrentDefaultHandle::~CurrentDefaultHandle() {
   DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK_EQ(CurrentDefaultHandleTls().Get(), this);
-  CurrentDefaultHandleTls().Set(nullptr);
+  DCHECK_EQ(CurrentDefaultHandleTls2().Get(), this);
+  CurrentDefaultHandleTls2().Set(nullptr);
 }
 
 SingleThreadTaskRunner::CurrentHandleOverride::CurrentHandleOverride(
@@ -89,7 +89,7 @@ SingleThreadTaskRunner::CurrentHandleOverride::CurrentHandleOverride(
   expected_task_runner_before_restore_ = overriding_task_runner.get();
 #endif
   SingleThreadTaskRunner::CurrentDefaultHandle* current_default =
-      CurrentDefaultHandleTls().Get();
+      CurrentDefaultHandleTls2().Get();
   SequencedTaskRunner::SetCurrentDefaultHandleTaskRunner(
       current_default->sequenced_task_runner_current_default_,
       overriding_task_runner);
@@ -108,7 +108,7 @@ SingleThreadTaskRunner::CurrentHandleOverride::CurrentHandleOverride(
 SingleThreadTaskRunner::CurrentHandleOverride::~CurrentHandleOverride() {
   if (task_runner_to_restore_) {
     SingleThreadTaskRunner::CurrentDefaultHandle* current_default =
-        CurrentDefaultHandleTls().Get();
+        CurrentDefaultHandleTls2().Get();
 
 #if DCHECK_IS_ON()
     DCHECK_EQ(expected_task_runner_before_restore_,
diff --git a/build/config/jumbo.gni b/build/config/jumbo.gni
index dd8972423..025314908 100644
--- a/build/config/jumbo.gni
+++ b/build/config/jumbo.gni
@@ -78,7 +78,7 @@ template("internal_jumbo_target") {
   if (defined(invoker.never_build_jumbo) && invoker.never_build_jumbo) {
     use_jumbo_build_for_target = false
   }
-  if (is_nacl_irt || is_nacl_nonsfi) {
+  if (is_nacl_irt) {
     # The code is barely compatible with the nacl toolchain anymore and we
     # don't want to stress it further with jumbo compilation units.
     use_jumbo_build_for_target = false
diff --git a/cc/metrics/compositor_frame_reporter.cc b/cc/metrics/compositor_frame_reporter.cc
index 2187f7f62..1fcb907be 100644
--- a/cc/metrics/compositor_frame_reporter.cc
+++ b/cc/metrics/compositor_frame_reporter.cc
@@ -172,7 +172,7 @@ void ReportEventLatencyMetric(
   }
 }
 
-constexpr char kTraceCategory[] =
+constexpr char kTraceCategory2[] =
     "cc,benchmark," TRACE_DISABLED_BY_DEFAULT("devtools.timeline.frame");
 
 base::TimeTicks ComputeSafeDeadlineForFrame(const viz::BeginFrameArgs& args) {
@@ -1145,7 +1145,7 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
   const auto trace_track =
       perfetto::Track(base::trace_event::GetNextGlobalTraceId());
   TRACE_EVENT_BEGIN(
-      kTraceCategory, "PipelineReporter", trace_track, args_.frame_time,
+      kTraceCategory2, "PipelineReporter", trace_track, args_.frame_time,
       [&](perfetto::EventContext context) {
         using perfetto::protos::pbzero::ChromeFrameReporter;
         ChromeFrameReporter::State state;
@@ -1226,7 +1226,7 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
 
     if (stage.stage_type == StageType::kSendBeginMainFrameToCommit) {
       TRACE_EVENT_BEGIN(
-          kTraceCategory, perfetto::StaticString{stage_name}, trace_track,
+          kTraceCategory2, perfetto::StaticString{stage_name}, trace_track,
           stage.start_time, [&](perfetto::EventContext context) {
             DCHECK(processed_blink_breakdown_);
             auto* reporter =
@@ -1276,7 +1276,7 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
             }
           });
     } else {
-      TRACE_EVENT_BEGIN(kTraceCategory, perfetto::StaticString{stage_name},
+      TRACE_EVENT_BEGIN(kTraceCategory2, perfetto::StaticString{stage_name},
                         trace_track, stage.start_time);
     }
 
@@ -1290,16 +1290,16 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
         if (start_time >= end_time)
           continue;
         const char* breakdown_name = GetVizBreakdownName(it.GetBreakdown());
-        TRACE_EVENT_BEGIN(kTraceCategory,
+        TRACE_EVENT_BEGIN(kTraceCategory2,
                           perfetto::StaticString{breakdown_name}, trace_track,
                           start_time);
-        TRACE_EVENT_END(kTraceCategory, trace_track, end_time);
+        TRACE_EVENT_END(kTraceCategory2, trace_track, end_time);
       }
     }
-    TRACE_EVENT_END(kTraceCategory, trace_track, stage.end_time);
+    TRACE_EVENT_END(kTraceCategory2, trace_track, stage.end_time);
   }
 
-  TRACE_EVENT_END(kTraceCategory, trace_track, frame_termination_time_);
+  TRACE_EVENT_END(kTraceCategory2, trace_track, frame_termination_time_);
 }
 
 void CompositorFrameReporter::ReportScrollJankMetrics() const {
diff --git a/cc/metrics/compositor_frame_reporting_controller.cc b/cc/metrics/compositor_frame_reporting_controller.cc
index b14a9e941..e599d0350 100644
--- a/cc/metrics/compositor_frame_reporting_controller.cc
+++ b/cc/metrics/compositor_frame_reporting_controller.cc
@@ -22,10 +22,10 @@ using SmoothThread = CompositorFrameReporter::SmoothThread;
 using StageType = CompositorFrameReporter::StageType;
 using FrameTerminationStatus = CompositorFrameReporter::FrameTerminationStatus;
 
-constexpr char kTraceCategory[] = "cc,benchmark";
-constexpr int kNumOfCompositorStages =
+constexpr char kTraceCategory3[] = "cc,benchmark";
+constexpr int kNumOfCompositorStages3 =
     static_cast<int>(StageType::kStageTypeCount) - 1;
-constexpr int kNumDispatchStages =
+constexpr int kNumDispatchStages3 =
     static_cast<int>(EventMetrics::DispatchStage::kMaxValue);
 constexpr base::TimeDelta kDefaultLatencyPredictionDeviationThreshold =
     viz::BeginFrameArgs::DefaultInterval() / 2;
@@ -41,8 +41,8 @@ CompositorFrameReportingController::CompositorFrameReportingController(
       previous_latency_predictions_main_(base::Microseconds(-1)),
       previous_latency_predictions_impl_(base::Microseconds(-1)),
       event_latency_predictions_(
-          CompositorFrameReporter::EventLatencyInfo(kNumDispatchStages,
-                                                    kNumOfCompositorStages)) {
+          CompositorFrameReporter::EventLatencyInfo(kNumDispatchStages3,
+                                                    kNumOfCompositorStages3)) {
   if (should_report_ukm) {
     // UKM metrics should be reported if and only if `latency_ukm_reporter` is
     // set on `global_trackers_`.
@@ -446,9 +446,9 @@ void CompositorFrameReportingController::ReportMultipleSwaps(
 
       const auto trace_track =
           perfetto::Track(base::trace_event::GetNextGlobalTraceId());
-      TRACE_EVENT_BEGIN(kTraceCategory, "MultipleSwaps", trace_track,
+      TRACE_EVENT_BEGIN(kTraceCategory3, "MultipleSwaps", trace_track,
                         latest_swap_times_.front());
-      TRACE_EVENT_END(kTraceCategory, trace_track, latest_swap_times_.back());
+      TRACE_EVENT_END(kTraceCategory3, trace_track, latest_swap_times_.back());
     }
   }
 }
diff --git a/cc/metrics/frame_sequence_tracker.cc b/cc/metrics/frame_sequence_tracker.cc
index 7d00a3869..640ad838b 100644
--- a/cc/metrics/frame_sequence_tracker.cc
+++ b/cc/metrics/frame_sequence_tracker.cc
@@ -38,7 +38,7 @@ namespace cc {
 
 namespace {
 
-constexpr char kTraceCategory[] =
+constexpr char kTraceCategoryFST[] =
     "cc,benchmark," TRACE_DISABLED_BY_DEFAULT("devtools.timeline.frame");
 
 }  // namespace
@@ -95,7 +95,7 @@ FrameSequenceTracker::FrameSequenceTracker(
   // TODO(crbug.com/1158439): remove the trace event once the validation is
   // completed.
   TRACE_EVENT_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP1(
-      kTraceCategory, "TrackerValidation", TRACE_ID_LOCAL(this),
+      kTraceCategoryFST, "TrackerValidation", TRACE_ID_LOCAL(this),
       base::TimeTicks::Now(), "name", GetFrameSequenceTrackerTypeName(type));
 }
 
@@ -112,7 +112,7 @@ FrameSequenceTracker::FrameSequenceTracker(
 
 FrameSequenceTracker::~FrameSequenceTracker() {
   TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP2(
-      kTraceCategory, "TrackerValidation", TRACE_ID_LOCAL(this),
+      kTraceCategoryFST, "TrackerValidation", TRACE_ID_LOCAL(this),
       base::TimeTicks::Now(), "aborted_main", aborted_main_frame_,
       "no_damage_main", no_damage_draw_main_frames_);
   CleanUp();
diff --git a/cc/metrics/jank_injector.cc b/cc/metrics/jank_injector.cc
index 659a87079..4bea2cec6 100644
--- a/cc/metrics/jank_injector.cc
+++ b/cc/metrics/jank_injector.cc
@@ -26,7 +26,7 @@ namespace cc {
 
 namespace {
 
-constexpr char kTraceCategory[] =
+constexpr char kTraceCategoryJI[] =
     "cc,benchmark," TRACE_DISABLED_BY_DEFAULT("devtools.timeline.frame");
 
 const char kJankInjectionAllowedURLs[] = "allowed_urls";
@@ -93,7 +93,7 @@ bool IsJankInjectionEnabledForURL(const GURL& url) {
 }
 
 void RunJank(JankInjectionParams params) {
-  TRACE_EVENT0(kTraceCategory, "Injected Jank");
+  TRACE_EVENT0(kTraceCategoryJI, "Injected Jank");
   if (params.busy_loop) {
     // Do some useless work, and prevent any weird compiler optimization from
     // doing anything here.
diff --git a/cc/metrics/jank_metrics.cc b/cc/metrics/jank_metrics.cc
index f2265296c..b11ac934d 100644
--- a/cc/metrics/jank_metrics.cc
+++ b/cc/metrics/jank_metrics.cc
@@ -21,10 +21,10 @@ namespace cc {
 namespace {
 
 constexpr uint64_t kMaxNoUpdateFrameQueueLength = 100;
-constexpr int kBuiltinSequenceNum =
+constexpr int kBuiltinJankSequenceNum =
     static_cast<int>(FrameSequenceTrackerType::kMaxType) + 1;
-constexpr int kMaximumJankHistogramIndex = 2 * kBuiltinSequenceNum;
-constexpr int kMaximumStaleHistogramIndex = kBuiltinSequenceNum;
+constexpr int kMaximumJankHistogramIndex = 2 * kBuiltinJankSequenceNum;
+constexpr int kMaximumStaleHistogramIndex = kBuiltinJankSequenceNum;
 
 constexpr base::TimeDelta kStaleHistogramMin = base::Microseconds(1);
 constexpr base::TimeDelta kStaleHistogramMax = base::Milliseconds(1000);
@@ -57,7 +57,7 @@ int GetIndexForJankMetric(FrameInfo::SmoothEffectDrivingThread thread_type,
     return static_cast<int>(type);
 
   DCHECK_EQ(thread_type, FrameInfo::SmoothEffectDrivingThread::kCompositor);
-  return static_cast<int>(type) + kBuiltinSequenceNum;
+  return static_cast<int>(type) + kBuiltinJankSequenceNum;
 }
 
 int GetIndexForStaleMetric(FrameSequenceTrackerType type) {
diff --git a/components/guest_view/browser/BUILD.gn b/components/guest_view/browser/BUILD.gn
index 522080d36..ca05994da 100644
--- a/components/guest_view/browser/BUILD.gn
+++ b/components/guest_view/browser/BUILD.gn
@@ -8,7 +8,9 @@
 # remove this assert.
 assert(!is_android && !is_ios)
 
-static_library("browser") {
+import("//build/config/jumbo.gni")
+
+jumbo_static_library("browser") {
   output_name = "guest_view_browser"
   sources = [
     "//components/guest_view/browser/bad_message.cc",
diff --git a/components/guest_view/renderer/BUILD.gn b/components/guest_view/renderer/BUILD.gn
index d12cd543e..b6d983891 100644
--- a/components/guest_view/renderer/BUILD.gn
+++ b/components/guest_view/renderer/BUILD.gn
@@ -8,7 +8,9 @@
 # remove this assert.
 assert(!is_android && !is_ios)
 
-static_library("renderer") {
+import("//build/config/jumbo.gni")
+
+jumbo_static_library("renderer") {
   sources = [
     "guest_view_container.cc",
     "guest_view_container.h",
diff --git a/components/metrics/metrics_log.cc b/components/metrics/metrics_log.cc
index a5710fd56..6a24d2f0e 100644
--- a/components/metrics/metrics_log.cc
+++ b/components/metrics/metrics_log.cc
@@ -305,8 +305,8 @@ void MetricsLog::RecordCoreSystemProfile(MetricsServiceClient* client,
   // Exclude these switches which are very frequently on the command line but
   // serve no meaningful purpose.
   static const char* const kSwitchesToFilter[] = {
-      switches::kFlagSwitchesBegin,
-      switches::kFlagSwitchesEnd,
+      ::switches::kFlagSwitchesBegin,
+      ::switches::kFlagSwitchesEnd,
   };
 
   for (const char* filter_switch : kSwitchesToFilter)
diff --git a/components/metrics/metrics_state_manager.cc b/components/metrics/metrics_state_manager.cc
index 7fdd69f29..ac83d6ebf 100644
--- a/components/metrics/metrics_state_manager.cc
+++ b/components/metrics/metrics_state_manager.cc
@@ -545,8 +545,8 @@ MetricsStateManager::CreateEntropyProviders() {
   return std::make_unique<variations::EntropyProviders>(
       GetHighEntropySource(),
       variations::ValueInRange{
-          .value = base::checked_cast<uint32_t>(GetLowEntropySource()),
-          .range = EntropyState::kMaxLowEntropySize},
+          /*.value =*/ base::checked_cast<uint32_t>(GetLowEntropySource()),
+          /*.range =*/ EntropyState::kMaxLowEntropySize},
       ShouldEnableBenchmarking(entropy_params_.force_benchmarking_mode));
 }
 
diff --git a/components/performance_manager/BUILD.gn b/components/performance_manager/BUILD.gn
index 76794b25e..70974514a 100644
--- a/components/performance_manager/BUILD.gn
+++ b/components/performance_manager/BUILD.gn
@@ -2,13 +2,14 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/jumbo.gni")
 import("//third_party/protobuf/proto_library.gni")
 
 proto_library("site_data_proto") {
   sources = [ "persistence/site_data/site_data.proto" ]
 }
 
-static_library("performance_manager") {
+jumbo_static_library("performance_manager") {
   sources = [
     "binders.cc",
     "browser_child_process_host_proxy.cc",
@@ -244,6 +245,7 @@ static_library("performance_manager") {
       "graph/policies/bfcache_policy.cc",
       "graph/policies/bfcache_policy.h",
     ]
+    jumbo_excluded_sources = [ "decorators/site_data_recorder.cc" ]
 
     public_deps += [
       ":site_data_proto",
diff --git a/components/performance_manager/decorators/page_live_state_decorator.cc b/components/performance_manager/decorators/page_live_state_decorator.cc
index 07c8c7b74..5869fe958 100644
--- a/components/performance_manager/decorators/page_live_state_decorator.cc
+++ b/components/performance_manager/decorators/page_live_state_decorator.cc
@@ -236,8 +236,6 @@ class PageLiveStateDataImpl
   const raw_ptr<const PageNode> page_node_;
 };
 
-const char kDescriberName[] = "PageLiveStateDecorator";
-
 }  // namespace
 
 void PageLiveStateDecorator::Delegate::GetContentSettingsAndReply(
@@ -356,7 +354,7 @@ void PageLiveStateDecorator::SetContentSettings(
 
 void PageLiveStateDecorator::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "PageLiveStateDecorator");
   graph->AddPageNodeObserver(this);
 }
 
diff --git a/components/performance_manager/decorators/page_load_tracker_decorator.cc b/components/performance_manager/decorators/page_load_tracker_decorator.cc
index 9323c673c..3d6b66eda 100644
--- a/components/performance_manager/decorators/page_load_tracker_decorator.cc
+++ b/components/performance_manager/decorators/page_load_tracker_decorator.cc
@@ -68,8 +68,6 @@ const char* ToString(LoadIdleState state) {
   }
 }
 
-const char kDescriberName[] = "PageLoadTrackerDecorator";
-
 }  // namespace
 
 // static
@@ -94,7 +92,7 @@ void PageLoadTrackerDecorator::OnNetworkAlmostIdleChanged(
 void PageLoadTrackerDecorator::OnPassedToGraph(Graph* graph) {
   RegisterObservers(graph);
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "PageLoadTrackerDecorator");
 }
 
 void PageLoadTrackerDecorator::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/execution_context_priority/frame_audible_voter.cc b/components/performance_manager/execution_context_priority/frame_audible_voter.cc
index c1ed0a54a..4eef64fef 100644
--- a/components/performance_manager/execution_context_priority/frame_audible_voter.cc
+++ b/components/performance_manager/execution_context_priority/frame_audible_voter.cc
@@ -13,7 +13,7 @@ namespace execution_context_priority {
 
 namespace {
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext2(
     const FrameNode* frame_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              frame_node->GetGraph())
@@ -43,16 +43,16 @@ void FrameAudibleVoter::SetVotingChannel(VotingChannel voting_channel) {
 
 void FrameAudibleVoter::OnFrameNodeAdded(const FrameNode* frame_node) {
   const Vote vote = GetVote(frame_node->IsAudible());
-  voting_channel_.SubmitVote(GetExecutionContext(frame_node), vote);
+  voting_channel_.SubmitVote(GetExecutionContext2(frame_node), vote);
 }
 
 void FrameAudibleVoter::OnBeforeFrameNodeRemoved(const FrameNode* frame_node) {
-  voting_channel_.InvalidateVote(GetExecutionContext(frame_node));
+  voting_channel_.InvalidateVote(GetExecutionContext2(frame_node));
 }
 
 void FrameAudibleVoter::OnIsAudibleChanged(const FrameNode* frame_node) {
   const Vote new_vote = GetVote(frame_node->IsAudible());
-  voting_channel_.ChangeVote(GetExecutionContext(frame_node), new_vote);
+  voting_channel_.ChangeVote(GetExecutionContext2(frame_node), new_vote);
 }
 
 }  // namespace execution_context_priority
diff --git a/components/performance_manager/execution_context_priority/frame_visibility_voter.cc b/components/performance_manager/execution_context_priority/frame_visibility_voter.cc
index 669177017..75a854150 100644
--- a/components/performance_manager/execution_context_priority/frame_visibility_voter.cc
+++ b/components/performance_manager/execution_context_priority/frame_visibility_voter.cc
@@ -14,7 +14,7 @@ namespace execution_context_priority {
 
 namespace {
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext5(
     const FrameNode* frame_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              frame_node->GetGraph())
@@ -23,7 +23,7 @@ const execution_context::ExecutionContext* GetExecutionContext(
 
 // Returns a vote with the appropriate priority depending on the frame's
 // |visibility|.
-Vote GetVote(FrameNode::Visibility visibility) {
+Vote GetVote2(FrameNode::Visibility visibility) {
   base::TaskPriority priority;
   switch (visibility) {
     case FrameNode::Visibility::kUnknown:
@@ -53,25 +53,25 @@ void FrameVisibilityVoter::SetVotingChannel(VotingChannel voting_channel) {
 }
 
 void FrameVisibilityVoter::OnFrameNodeAdded(const FrameNode* frame_node) {
-  const Vote vote = GetVote(frame_node->GetVisibility());
-  voting_channel_.SubmitVote(GetExecutionContext(frame_node), vote);
+  const Vote vote = GetVote2(frame_node->GetVisibility());
+  voting_channel_.SubmitVote(GetExecutionContext5(frame_node), vote);
 }
 
 void FrameVisibilityVoter::OnBeforeFrameNodeRemoved(
     const FrameNode* frame_node) {
-  voting_channel_.InvalidateVote(GetExecutionContext(frame_node));
+  voting_channel_.InvalidateVote(GetExecutionContext5(frame_node));
 }
 
 void FrameVisibilityVoter::OnFrameVisibilityChanged(
     const FrameNode* frame_node,
     FrameNode::Visibility previous_value) {
-  const Vote new_vote = GetVote(frame_node->GetVisibility());
+  const Vote new_vote = GetVote2(frame_node->GetVisibility());
 
   // Nothing to change if the new priority is the same as the old one.
-  if (new_vote == GetVote(previous_value))
+  if (new_vote == GetVote2(previous_value))
     return;
 
-  voting_channel_.ChangeVote(GetExecutionContext(frame_node), new_vote);
+  voting_channel_.ChangeVote(GetExecutionContext5(frame_node), new_vote);
 }
 
 }  // namespace execution_context_priority
diff --git a/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc b/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc
index 3b637f8d0..54a877287 100644
--- a/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc
+++ b/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc
@@ -16,14 +16,14 @@ namespace execution_context_priority {
 
 namespace {
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext_ICPV(
     const FrameNode* frame_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              frame_node->GetGraph())
       ->GetExecutionContextForFrameNode(frame_node);
 }
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext_ICPV(
     const WorkerNode* worker_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              worker_node->GetGraph())
@@ -50,7 +50,7 @@ void InheritClientPriorityVoter::SetVotingChannel(
 
 void InheritClientPriorityVoter::OnFrameNodeAdded(const FrameNode* frame_node) {
   bool inserted = voting_channels_
-                      .emplace(GetExecutionContext(frame_node),
+                      .emplace(GetExecutionContext_ICPV(frame_node),
                                max_vote_aggregator_.GetVotingChannel())
                       .second;
   DCHECK(inserted);
@@ -60,7 +60,7 @@ void InheritClientPriorityVoter::OnFrameNodeAdded(const FrameNode* frame_node) {
 void InheritClientPriorityVoter::OnBeforeFrameNodeRemoved(
     const FrameNode* frame_node) {
   DCHECK(frame_node->GetChildWorkerNodes().empty());
-  size_t removed = voting_channels_.erase(GetExecutionContext(frame_node));
+  size_t removed = voting_channels_.erase(GetExecutionContext_ICPV(frame_node));
   DCHECK_EQ(removed, 1u);
 }
 
@@ -70,7 +70,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
   // The priority of a frame changed. All its children must inherit the new
   // priority.
 
-  auto it = voting_channels_.find(GetExecutionContext(frame_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(frame_node));
 
   // Unknown |frame_node|. Just ignore it until we get notified of its existence
   // via OnFrameNodeAdded(). This can happen because another voter received the
@@ -86,7 +86,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
   for (const WorkerNode* child_worker_node :
        frame_node->GetChildWorkerNodes()) {
     const ExecutionContext* child_execution_context =
-        GetExecutionContext(child_worker_node);
+        GetExecutionContext_ICPV(child_worker_node);
     voting_channel.ChangeVote(child_execution_context, inherited_vote);
   }
 }
@@ -94,7 +94,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
 void InheritClientPriorityVoter::OnWorkerNodeAdded(
     const WorkerNode* worker_node) {
   bool inserted = voting_channels_
-                      .emplace(GetExecutionContext(worker_node),
+                      .emplace(GetExecutionContext_ICPV(worker_node),
                                max_vote_aggregator_.GetVotingChannel())
                       .second;
   DCHECK(inserted);
@@ -104,7 +104,7 @@ void InheritClientPriorityVoter::OnWorkerNodeAdded(
 void InheritClientPriorityVoter::OnBeforeWorkerNodeRemoved(
     const WorkerNode* worker_node) {
   DCHECK(worker_node->GetChildWorkers().empty());
-  size_t removed = voting_channels_.erase(GetExecutionContext(worker_node));
+  size_t removed = voting_channels_.erase(GetExecutionContext_ICPV(worker_node));
   DCHECK_EQ(removed, 1u);
 }
 
@@ -115,14 +115,14 @@ void InheritClientPriorityVoter::OnClientFrameAdded(
   // priority.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_frame_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_frame_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
   const Vote inherited_vote(
       client_frame_node->GetPriorityAndReason().priority(),
       kPriorityInheritedReason);
-  voting_channel->SubmitVote(GetExecutionContext(worker_node), inherited_vote);
+  voting_channel->SubmitVote(GetExecutionContext_ICPV(worker_node), inherited_vote);
 }
 
 void InheritClientPriorityVoter::OnBeforeClientFrameRemoved(
@@ -132,11 +132,11 @@ void InheritClientPriorityVoter::OnBeforeClientFrameRemoved(
   // vote must be invalidated.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_frame_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_frame_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
-  voting_channel->InvalidateVote(GetExecutionContext(worker_node));
+  voting_channel->InvalidateVote(GetExecutionContext_ICPV(worker_node));
 }
 
 void InheritClientPriorityVoter::OnClientWorkerAdded(
@@ -146,14 +146,14 @@ void InheritClientPriorityVoter::OnClientWorkerAdded(
   // priority.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_worker_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_worker_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
   const Vote inherited_vote(
       client_worker_node->GetPriorityAndReason().priority(),
       kPriorityInheritedReason);
-  voting_channel->SubmitVote(GetExecutionContext(worker_node), inherited_vote);
+  voting_channel->SubmitVote(GetExecutionContext_ICPV(worker_node), inherited_vote);
 }
 
 void InheritClientPriorityVoter::OnBeforeClientWorkerRemoved(
@@ -163,11 +163,11 @@ void InheritClientPriorityVoter::OnBeforeClientWorkerRemoved(
   // vote must be invalidated.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_worker_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_worker_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
-  voting_channel->InvalidateVote(GetExecutionContext(worker_node));
+  voting_channel->InvalidateVote(GetExecutionContext_ICPV(worker_node));
 }
 
 void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
@@ -176,7 +176,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
   // The priority of a worker changed. All its children must inherit the new
   // priority.
 
-  auto it = voting_channels_.find(GetExecutionContext(worker_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(worker_node));
 
   // Unknown |worker_node|. Just ignore it until we get notified of its
   // existence via OnWorkerNodeAdded().
@@ -189,7 +189,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
                             kPriorityInheritedReason);
   for (const WorkerNode* child_worker_node : worker_node->GetChildWorkers()) {
     const ExecutionContext* child_execution_context =
-        GetExecutionContext(child_worker_node);
+        GetExecutionContext_ICPV(child_worker_node);
     voting_channel.ChangeVote(child_execution_context, inherited_vote);
   }
 }
diff --git a/components/performance_manager/graph/frame_node_impl_describer.cc b/components/performance_manager/graph/frame_node_impl_describer.cc
index 9cc282c2b..6b49ef634 100644
--- a/components/performance_manager/graph/frame_node_impl_describer.cc
+++ b/components/performance_manager/graph/frame_node_impl_describer.cc
@@ -17,8 +17,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "FrameNodeImpl";
-
 std::string ViewportIntersectionToString(
     const absl::optional<gfx::Rect>& viewport_intersection) {
   if (!viewport_intersection.has_value())
@@ -45,7 +43,7 @@ FrameNodeImplDescriber::~FrameNodeImplDescriber() = default;
 
 void FrameNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "FrameNodeImpl");
 }
 
 void FrameNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/graph/page_node_impl_describer.cc b/components/performance_manager/graph/page_node_impl_describer.cc
index 46049ddc0..6af5d681a 100644
--- a/components/performance_manager/graph/page_node_impl_describer.cc
+++ b/components/performance_manager/graph/page_node_impl_describer.cc
@@ -15,8 +15,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "PageNodeImpl";
-
 const char* FreezingVoteToString(
     absl::optional<freezing::FreezingVote> freezing_vote) {
   if (!freezing_vote)
@@ -32,7 +30,7 @@ PageNodeImplDescriber::~PageNodeImplDescriber() = default;
 
 void PageNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "PageNodeImpl");
 }
 
 void PageNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/graph/process_node_impl_describer.cc b/components/performance_manager/graph/process_node_impl_describer.cc
index 31cd844d9..d27751643 100644
--- a/components/performance_manager/graph/process_node_impl_describer.cc
+++ b/components/performance_manager/graph/process_node_impl_describer.cc
@@ -26,8 +26,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "ProcessNodeImpl";
-
 std::string ContentTypeToString(ProcessNode::ContentType content_type) {
   switch (content_type) {
     case ProcessNode::ContentType::kExtension:
@@ -125,7 +123,7 @@ base::Time TicksToTime(base::TimeTicks ticks) {
 
 void ProcessNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "ProcessNodeImpl");
 }
 
 void ProcessNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/graph/worker_node_impl_describer.cc b/components/performance_manager/graph/worker_node_impl_describer.cc
index 72db192b3..383019b7e 100644
--- a/components/performance_manager/graph/worker_node_impl_describer.cc
+++ b/components/performance_manager/graph/worker_node_impl_describer.cc
@@ -12,8 +12,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "WorkerNode";
-
 const char* WorkerTypeToString(WorkerNode::WorkerType state) {
   switch (state) {
     case WorkerNode::WorkerType::kDedicated:
@@ -29,7 +27,7 @@ const char* WorkerTypeToString(WorkerNode::WorkerType state) {
 
 void WorkerNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "WorkerNode");
 }
 
 void WorkerNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/performance_manager_registry_impl.cc b/components/performance_manager/performance_manager_registry_impl.cc
index 51bd4bb57..4fead7728 100644
--- a/components/performance_manager/performance_manager_registry_impl.cc
+++ b/components/performance_manager/performance_manager_registry_impl.cc
@@ -27,15 +27,15 @@
 
 namespace performance_manager {
 
-namespace {
+namespace performance_manager_registry_impl {
 
 PerformanceManagerRegistryImpl* g_instance = nullptr;
 
 }  // namespace
 
 PerformanceManagerRegistryImpl::PerformanceManagerRegistryImpl() {
-  DCHECK(!g_instance);
-  g_instance = this;
+  DCHECK(!performance_manager_registry_impl::g_instance);
+  performance_manager_registry_impl::g_instance = this;
 
   // The registry should be created after the PerformanceManager.
   DCHECK(PerformanceManager::IsAvailable());
@@ -46,7 +46,7 @@ PerformanceManagerRegistryImpl::~PerformanceManagerRegistryImpl() {
   // TearDown() should have been invoked to reset |g_instance| and clear
   // |web_contents_| and |render_process_user_data_| prior to destroying the
   // registry.
-  DCHECK(!g_instance);
+  DCHECK(!performance_manager_registry_impl::g_instance);
   DCHECK(web_contents_.empty());
   DCHECK(render_process_hosts_.empty());
   DCHECK(pm_owned_.empty());
@@ -57,7 +57,7 @@ PerformanceManagerRegistryImpl::~PerformanceManagerRegistryImpl() {
 
 // static
 PerformanceManagerRegistryImpl* PerformanceManagerRegistryImpl::GetInstance() {
-  return g_instance;
+  return performance_manager_registry_impl::g_instance;
 }
 
 void PerformanceManagerRegistryImpl::AddObserver(
@@ -241,8 +241,8 @@ void PerformanceManagerRegistryImpl::TearDown() {
   for (auto& observer : observers_)
     observer.OnBeforePerformanceManagerDestroyed();
 
-  DCHECK_EQ(g_instance, this);
-  g_instance = nullptr;
+  DCHECK_EQ(performance_manager_registry_impl::g_instance, this);
+  performance_manager_registry_impl::g_instance = nullptr;
 
   // Destroy WorkerNodes before ProcessNodes, because ProcessNode checks that it
   // has no associated WorkerNode when torn down.
diff --git a/components/performance_manager/persistence/site_data/site_data_cache_factory.cc b/components/performance_manager/persistence/site_data/site_data_cache_factory.cc
index 9c8f5f591..ecdc53171 100644
--- a/components/performance_manager/persistence/site_data/site_data_cache_factory.cc
+++ b/components/performance_manager/persistence/site_data/site_data_cache_factory.cc
@@ -18,29 +18,29 @@
 
 namespace performance_manager {
 
-namespace {
+namespace site_data_cache_factory {
 SiteDataCacheFactory* g_instance = nullptr;
 }  // namespace
 
 SiteDataCacheFactory::SiteDataCacheFactory() {
-  DCHECK(!g_instance);
-  g_instance = this;
+  DCHECK(!site_data_cache_factory::g_instance);
+  site_data_cache_factory::g_instance = this;
 }
 
 SiteDataCacheFactory::~SiteDataCacheFactory() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  DCHECK_EQ(this, g_instance);
+  DCHECK_EQ(this, site_data_cache_factory::g_instance);
   // Clear the cache map before unsetting |g_instance| as this will cause some
   // calls to |SetDataCacheInspectorForBrowserContext|.
   data_cache_map_.clear();
   for (const auto& iter : data_cache_map_)
     DCHECK_EQ(0, iter.second->Size());
-  g_instance = nullptr;
+  site_data_cache_factory::g_instance = nullptr;
 }
 
 // static
 SiteDataCacheFactory* SiteDataCacheFactory::GetInstance() {
-  return g_instance;
+  return site_data_cache_factory::g_instance;
 }
 
 SiteDataCache* SiteDataCacheFactory::GetDataCacheForBrowserContext(
diff --git a/components/policy/core/common/policy_proto_decoders.cc b/components/policy/core/common/policy_proto_decoders.cc
index 36ad07831..24cd0c900 100644
--- a/components/policy/core/common/policy_proto_decoders.cc
+++ b/components/policy/core/common/policy_proto_decoders.cc
@@ -29,7 +29,7 @@ namespace {
 
 const char kValue[] = "Value";
 const char kLevel[] = "Level";
-const char kRecommended[] = "Recommended";
+const char kRecommendedLocal[] = "Recommended";
 
 // Returns true and sets |level| to a PolicyLevel if the policy has been set
 // at that level. Returns false if the policy is not set, or has been set at
@@ -254,7 +254,7 @@ bool ParseComponentPolicy(base::Value json,
 
     PolicyLevel level = POLICY_LEVEL_MANDATORY;
     const std::string* level_string = description.FindStringKey(kLevel);
-    if (level_string && *level_string == kRecommended)
+    if (level_string && *level_string == kRecommendedLocal)
       level = POLICY_LEVEL_RECOMMENDED;
 
     policy->Set(policy_name, level, scope, source, std::move(value.value()),
diff --git a/components/printing/browser/BUILD.gn b/components/printing/browser/BUILD.gn
index cd2f244c1..a5f46dda2 100644
--- a/components/printing/browser/BUILD.gn
+++ b/components/printing/browser/BUILD.gn
@@ -2,7 +2,9 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-static_library("browser") {
+import("//build/config/jumbo.gni")
+
+jumbo_static_library("browser") {
   sources = [
     "print_composite_client.cc",
     "print_composite_client.h",
diff --git a/components/storage_monitor/BUILD.gn b/components/storage_monitor/BUILD.gn
index 546f194a2..4b2302105 100644
--- a/components/storage_monitor/BUILD.gn
+++ b/components/storage_monitor/BUILD.gn
@@ -4,8 +4,9 @@
 
 import("//build/config/chromeos/ui_mode.gni")
 import("//build/config/features.gni")
+import("//build/config/jumbo.gni")
 
-static_library("storage_monitor") {
+jumbo_static_library("storage_monitor") {
   sources = [
     "media_storage_util.cc",
     "media_storage_util.h",
diff --git a/components/viz/common/BUILD.gn b/components/viz/common/BUILD.gn
index d8075e84c..6052363c5 100644
--- a/components/viz/common/BUILD.gn
+++ b/components/viz/common/BUILD.gn
@@ -48,6 +48,7 @@ viz_component("resource_format_utils") {
     "viz_resource_format_export.h",
   ]
 
+  jumbo_excluded_sources = [ "resources/resource_format_utils.cc" ]
   configs = [ "//third_party/khronos:khronos_headers" ]
 
   public_deps = [ ":resource_format" ]
diff --git a/components/viz/service/BUILD.gn b/components/viz/service/BUILD.gn
index bebc21404..c980881f5 100644
--- a/components/viz/service/BUILD.gn
+++ b/components/viz/service/BUILD.gn
@@ -222,6 +222,17 @@ viz_component("service") {
     "viz_service_export.h",
   ]
 
+  jumbo_excluded_sources = [
+    "display/display.cc",
+    "display/overlay_processor_on_gpu.cc",
+    "display_embedder/compositor_gpu_thread.cc",
+    "display_embedder/skia_output_device_gl.cc",
+    "display_embedder/skia_output_device_webview.cc",
+    "display_embedder/skia_output_surface_impl_on_gpu.cc",
+    "frame_sinks/frame_sink_manager_impl.cc",
+    "frame_sinks/video_capture/frame_sink_video_capturer_impl.cc",
+  ]
+
   defines = [ "VIZ_SERVICE_IMPLEMENTATION" ]
 
   deps = [
@@ -377,6 +388,9 @@ viz_component("service") {
       "gl/info_collection_gpu_service_impl.cc",
       "gl/info_collection_gpu_service_impl.h",
     ]
+    jumbo_excluded_sources += [
+      "display_embedder/skia_output_device_dcomp.cc",
+    ]
 
     # SkiaOutputDeviceBufferQueue doesn't support Windows.
     sources -= [
diff --git a/components/viz/service/display/display_resource_provider.h b/components/viz/service/display/display_resource_provider.h
index effa9bca4..b054841de 100644
--- a/components/viz/service/display/display_resource_provider.h
+++ b/components/viz/service/display/display_resource_provider.h
@@ -28,7 +28,7 @@
 #include "components/viz/service/display/resource_fence.h"
 #include "components/viz/service/viz_service_export.h"
 #include "gpu/command_buffer/common/sync_token.h"
-#include "third_party/khronos/GLES2/gl2.h"
+//#include "third_party/khronos/GLES2/gl2.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/geometry/size.h"
 
diff --git a/components/viz/service/display_embedder/skia_output_device_webview.cc b/components/viz/service/display_embedder/skia_output_device_webview.cc
index 9ad49445e..756d8bb02 100644
--- a/components/viz/service/display_embedder/skia_output_device_webview.cc
+++ b/components/viz/service/display_embedder/skia_output_device_webview.cc
@@ -18,7 +18,7 @@
 namespace viz {
 
 namespace {
-constexpr auto kSurfaceColorType = kRGBA_8888_SkColorType;
+constexpr auto kMySurfaceColorType = kRGBA_8888_SkColorType;
 }
 
 SkiaOutputDeviceWebView::SkiaOutputDeviceWebView(
@@ -43,9 +43,9 @@ SkiaOutputDeviceWebView::SkiaOutputDeviceWebView(
   DCHECK(context_state_->context());
 
   capabilities_.sk_color_types[static_cast<int>(gfx::BufferFormat::RGBA_8888)] =
-      kSurfaceColorType;
+      kMySurfaceColorType;
   capabilities_.sk_color_types[static_cast<int>(gfx::BufferFormat::BGRA_8888)] =
-      kSurfaceColorType;
+      kMySurfaceColorType;
 }
 
 SkiaOutputDeviceWebView::~SkiaOutputDeviceWebView() = default;
@@ -104,7 +104,7 @@ void SkiaOutputDeviceWebView::InitSkiaSurface(unsigned int fbo) {
   GrGLFramebufferInfo framebuffer_info;
   framebuffer_info.fFBOID = fbo;
   framebuffer_info.fFormat = GL_RGBA8;
-  SkColorType color_type = kSurfaceColorType;
+  SkColorType color_type = kMySurfaceColorType;
 
   GrBackendRenderTarget render_target(size_.width(), size_.height(),
                                       /*sampleCnt=*/0,
diff --git a/components/viz/service/transitions/transferable_resource_tracker.cc b/components/viz/service/transitions/transferable_resource_tracker.cc
index a60e0b588..d801bee73 100644
--- a/components/viz/service/transitions/transferable_resource_tracker.cc
+++ b/components/viz/service/transitions/transferable_resource_tracker.cc
@@ -4,7 +4,7 @@
 
 #include "components/viz/service/transitions/transferable_resource_tracker.h"
 
-#include <GLES2/gl2.h>
+#include "third_party/khronos/GLES2/gl2.h"
 
 #include <limits>
 #include <memory>
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 24283757c..41136221f 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -37,6 +37,88 @@ buildflag_header("buildflags") {
   flags = [ "USE_SOCKET_BROKER=$use_socket_broker" ]
 }
 
+jumbo_static_library("devtools_protocol") {
+  configs += [
+    "//build/config:precompiled_headers",
+    "//content:content_implementation",
+  ]
+
+  deps = [
+    "//base",
+    "//content/browser/devtools:devtools_background_services_proto",
+    "//content/browser/devtools:protocol_sources",
+    "//content/common:buildflags",
+    "//services/viz/privileged/mojom",
+    "//third_party/blink/public/mojom:mojom_platform",
+    "//third_party/inspector_protocol:crdtp",
+  ]
+
+  sources = [
+    "$target_gen_dir/devtools/protocol/audits.cc",
+    "$target_gen_dir/devtools/protocol/audits.h",
+    "$target_gen_dir/devtools/protocol/background_service.cc",
+    "$target_gen_dir/devtools/protocol/background_service.h",
+    "$target_gen_dir/devtools/protocol/browser.cc",
+    "$target_gen_dir/devtools/protocol/browser.h",
+    "$target_gen_dir/devtools/protocol/dom.cc",
+    "$target_gen_dir/devtools/protocol/dom.h",
+    "$target_gen_dir/devtools/protocol/emulation.cc",
+    "$target_gen_dir/devtools/protocol/emulation.h",
+    "$target_gen_dir/devtools/protocol/fetch.cc",
+    "$target_gen_dir/devtools/protocol/fetch.h",
+    "$target_gen_dir/devtools/protocol/forward.h",
+    "$target_gen_dir/devtools/protocol/input.cc",
+    "$target_gen_dir/devtools/protocol/input.h",
+    "$target_gen_dir/devtools/protocol/inspector.cc",
+    "$target_gen_dir/devtools/protocol/inspector.h",
+    "$target_gen_dir/devtools/protocol/io.cc",
+    "$target_gen_dir/devtools/protocol/io.h",
+    "$target_gen_dir/devtools/protocol/log.cc",
+    "$target_gen_dir/devtools/protocol/log.h",
+    "$target_gen_dir/devtools/protocol/memory.cc",
+    "$target_gen_dir/devtools/protocol/memory.h",
+    "$target_gen_dir/devtools/protocol/network.cc",
+    "$target_gen_dir/devtools/protocol/network.h",
+    "$target_gen_dir/devtools/protocol/overlay.cc",
+    "$target_gen_dir/devtools/protocol/overlay.h",
+    "$target_gen_dir/devtools/protocol/page.cc",
+    "$target_gen_dir/devtools/protocol/page.h",
+    "$target_gen_dir/devtools/protocol/protocol.h",
+    "$target_gen_dir/devtools/protocol/runtime.cc",
+    "$target_gen_dir/devtools/protocol/runtime.h",
+    "$target_gen_dir/devtools/protocol/schema.cc",
+    "$target_gen_dir/devtools/protocol/schema.h",
+    "$target_gen_dir/devtools/protocol/security.cc",
+    "$target_gen_dir/devtools/protocol/security.h",
+    "$target_gen_dir/devtools/protocol/service_worker.cc",
+    "$target_gen_dir/devtools/protocol/service_worker.h",
+    "$target_gen_dir/devtools/protocol/storage.cc",
+    "$target_gen_dir/devtools/protocol/storage.h",
+    "$target_gen_dir/devtools/protocol/system_info.cc",
+    "$target_gen_dir/devtools/protocol/system_info.h",
+    "$target_gen_dir/devtools/protocol/target.cc",
+    "$target_gen_dir/devtools/protocol/target.h",
+    "$target_gen_dir/devtools/protocol/tethering.cc",
+    "$target_gen_dir/devtools/protocol/tethering.h",
+    "$target_gen_dir/devtools/protocol/tracing.cc",
+    "$target_gen_dir/devtools/protocol/tracing.h",
+  ]
+  if (!is_android) {
+    # The WebAuthn devtools protocol API is not supported in Android yet.
+    sources += [
+      "$target_gen_dir/devtools/protocol/web_authn.cc",
+      "$target_gen_dir/devtools/protocol/web_authn.h",
+    ]
+  }
+
+  if (use_viz_debugger) {
+    sources += [
+      "$target_gen_dir/devtools/protocol/visual_debugger.cc",
+      "$target_gen_dir/devtools/protocol/visual_debugger.h",
+    ]
+  }
+}
+
 jumbo_source_set("browser") {
   # Only the public target should depend on this. All other targets (even
   # internal content ones) should depend on the public one.
@@ -134,8 +218,6 @@ jumbo_source_set("browser") {
     "//content/browser/cache_storage:cache_storage_proto",
     "//content/browser/content_index:content_index_proto",
     "//content/browser/cookie_store:cookie_store_proto",
-    "//content/browser/devtools:devtools_background_services_proto",
-    "//content/browser/devtools:protocol_sources",
     "//content/browser/download:proto",
     "//content/browser/file_system_access:proto",
     "//content/browser/indexed_db:mojo_bindings",
@@ -292,6 +374,7 @@ jumbo_source_set("browser") {
     "//ui/strings:ax_strings",
     "//ui/touch_selection",
     "//v8:v8_version",
+    ":devtools_protocol",
   ]
 
   public_deps = [
@@ -307,54 +390,6 @@ jumbo_source_set("browser") {
   ]
 
   sources = [
-    "$target_gen_dir/devtools/protocol/audits.cc",
-    "$target_gen_dir/devtools/protocol/audits.h",
-    "$target_gen_dir/devtools/protocol/background_service.cc",
-    "$target_gen_dir/devtools/protocol/background_service.h",
-    "$target_gen_dir/devtools/protocol/browser.cc",
-    "$target_gen_dir/devtools/protocol/browser.h",
-    "$target_gen_dir/devtools/protocol/dom.cc",
-    "$target_gen_dir/devtools/protocol/dom.h",
-    "$target_gen_dir/devtools/protocol/emulation.cc",
-    "$target_gen_dir/devtools/protocol/emulation.h",
-    "$target_gen_dir/devtools/protocol/fetch.cc",
-    "$target_gen_dir/devtools/protocol/fetch.h",
-    "$target_gen_dir/devtools/protocol/forward.h",
-    "$target_gen_dir/devtools/protocol/input.cc",
-    "$target_gen_dir/devtools/protocol/input.h",
-    "$target_gen_dir/devtools/protocol/inspector.cc",
-    "$target_gen_dir/devtools/protocol/inspector.h",
-    "$target_gen_dir/devtools/protocol/io.cc",
-    "$target_gen_dir/devtools/protocol/io.h",
-    "$target_gen_dir/devtools/protocol/log.cc",
-    "$target_gen_dir/devtools/protocol/log.h",
-    "$target_gen_dir/devtools/protocol/memory.cc",
-    "$target_gen_dir/devtools/protocol/memory.h",
-    "$target_gen_dir/devtools/protocol/network.cc",
-    "$target_gen_dir/devtools/protocol/network.h",
-    "$target_gen_dir/devtools/protocol/overlay.cc",
-    "$target_gen_dir/devtools/protocol/overlay.h",
-    "$target_gen_dir/devtools/protocol/page.cc",
-    "$target_gen_dir/devtools/protocol/page.h",
-    "$target_gen_dir/devtools/protocol/protocol.h",
-    "$target_gen_dir/devtools/protocol/runtime.cc",
-    "$target_gen_dir/devtools/protocol/runtime.h",
-    "$target_gen_dir/devtools/protocol/schema.cc",
-    "$target_gen_dir/devtools/protocol/schema.h",
-    "$target_gen_dir/devtools/protocol/security.cc",
-    "$target_gen_dir/devtools/protocol/security.h",
-    "$target_gen_dir/devtools/protocol/service_worker.cc",
-    "$target_gen_dir/devtools/protocol/service_worker.h",
-    "$target_gen_dir/devtools/protocol/storage.cc",
-    "$target_gen_dir/devtools/protocol/storage.h",
-    "$target_gen_dir/devtools/protocol/system_info.cc",
-    "$target_gen_dir/devtools/protocol/system_info.h",
-    "$target_gen_dir/devtools/protocol/target.cc",
-    "$target_gen_dir/devtools/protocol/target.h",
-    "$target_gen_dir/devtools/protocol/tethering.cc",
-    "$target_gen_dir/devtools/protocol/tethering.h",
-    "$target_gen_dir/devtools/protocol/tracing.cc",
-    "$target_gen_dir/devtools/protocol/tracing.h",
     "about_url_loader_factory.cc",
     "about_url_loader_factory.h",
     "accessibility/accessibility_tree_formatter_blink.cc",
@@ -2326,6 +2361,8 @@ jumbo_source_set("browser") {
     ]
   }
 
+  jumbo_excluded_sources = []
+
   # TODO(crbug.com/1327384): Remove `permissions_common`.
   # DO NOT add unrelated entries to this block.
   deps += [ "//components/permissions:permissions_common" ]
@@ -2339,8 +2376,6 @@ jumbo_source_set("browser") {
 
   if (use_viz_debugger) {
     sources += [
-      "$target_gen_dir/devtools/protocol/visual_debugger.cc",
-      "$target_gen_dir/devtools/protocol/visual_debugger.h",
       "devtools/protocol/visual_debugger_handler.cc",
       "devtools/protocol/visual_debugger_handler.h",
     ]
@@ -2624,6 +2659,9 @@ jumbo_source_set("browser") {
       ]
       public_deps += [ "//ui/base/cursor" ]
       deps += [ "//third_party/webrtc_overrides:webrtc_component" ]
+      jumbo_excluded_sources += [
+        "media/capture/desktop_capture_device.cc",
+      ]
     }
     if (use_aura) {
       sources += [
@@ -3068,6 +3106,12 @@ jumbo_source_set("browser") {
       "webauth/web_authentication_delegate_android.cc",
     ]
 
+    jumbo_excluded_sources += [
+      # Files with kJavaLangClass and similar constants:
+      # Bug https://crbug.com/787557.
+      "android/java/java_method.cc",  # and in gin_java_bound_object.cc.
+    ]
+
     deps += [
       ":reflection_jni_headers",
       "//build/config/freetype",
@@ -3098,10 +3142,6 @@ jumbo_source_set("browser") {
   } else {
     # Not Android.
     sources += [
-      # The WebAuthn devtools protocol API is not supported in Android yet.
-      "$target_gen_dir/devtools/protocol/web_authn.cc",
-      "$target_gen_dir/devtools/protocol/web_authn.h",
-
       # Devtools frontend not included in Android
       "devtools/devtools_frontend_host_impl.cc",
       "devtools/devtools_frontend_host_impl.h",
diff --git a/content/browser/attribution_reporting/attribution_internals_handler_impl.cc b/content/browser/attribution_reporting/attribution_internals_handler_impl.cc
index 3f7ac7a50..c44d4a5c3 100644
--- a/content/browser/attribution_reporting/attribution_internals_handler_impl.cc
+++ b/content/browser/attribution_reporting/attribution_internals_handler_impl.cc
@@ -103,7 +103,7 @@ attribution_internals::mojom::WebUISourcePtr WebUISource(
       debug_reporting_enabled, attributability);
 }
 
-void ForwardSourcesToWebUI(
+void ForwardSourcesToWebUI2(
     attribution_internals::mojom::Handler::GetActiveSourcesCallback
         web_ui_callback,
     std::vector<StoredSource> active_sources) {
@@ -180,7 +180,7 @@ attribution_internals::mojom::WebUIReportPtr WebUIReport(
             return ai_mojom::WebUIReportData::NewAggregatableAttributionData(
                 ai_mojom::WebUIReportAggregatableAttributionData::New(
                     std::move(contributions), std::move(attestation_token),
-                    aggregation_service::SerializeAggregationCoordinator(
+                    ::aggregation_service::SerializeAggregationCoordinator(
                         aggregatable_data.aggregation_coordinator)));
           },
       },
@@ -194,7 +194,7 @@ attribution_internals::mojom::WebUIReportPtr WebUIReport(
       std::move(status), std::move(data));
 }
 
-void ForwardReportsToWebUI(
+void ForwardReportsToWebUI2(
     attribution_internals::mojom::Handler::GetReportsCallback web_ui_callback,
     std::vector<AttributionReport> pending_reports) {
   std::vector<attribution_internals::mojom::WebUIReportPtr> web_ui_reports;
@@ -242,7 +242,7 @@ void AttributionInternalsHandlerImpl::GetActiveSources(
   if (AttributionManager* manager =
           AttributionManager::FromWebContents(web_ui_->GetWebContents())) {
     manager->GetActiveSourcesForWebUI(
-        base::BindOnce(&ForwardSourcesToWebUI, std::move(callback)));
+        base::BindOnce(&ForwardSourcesToWebUI2, std::move(callback)));
   } else {
     std::move(callback).Run({});
   }
@@ -256,7 +256,7 @@ void AttributionInternalsHandlerImpl::GetReports(
     manager->GetPendingReportsForInternalUse(
         AttributionReport::Types{report_type},
         /*limit=*/1000,
-        base::BindOnce(&ForwardReportsToWebUI, std::move(callback)));
+        base::BindOnce(&ForwardReportsToWebUI2, std::move(callback)));
   } else {
     std::move(callback).Run({});
   }
diff --git a/content/browser/attribution_reporting/attribution_storage_sql.cc b/content/browser/attribution_reporting/attribution_storage_sql.cc
index 70ae8f52f..c8bd2311b 100644
--- a/content/browser/attribution_reporting/attribution_storage_sql.cc
+++ b/content/browser/attribution_reporting/attribution_storage_sql.cc
@@ -90,7 +90,7 @@ using EventLevelResult = ::content::AttributionTrigger::EventLevelResult;
 
 using ::attribution_reporting::SuitableOrigin;
 
-const base::FilePath::CharType kDatabasePath[] =
+const base::FilePath::CharType kDatabasePathAttr[] =
     FILE_PATH_LITERAL("Conversions");
 
 constexpr int64_t kUnsetReportId = -1;
@@ -429,7 +429,7 @@ absl::optional<StoredSourceData> ReadSourceToAttribute(
 }
 
 base::FilePath DatabasePath(const base::FilePath& user_data_directory) {
-  return user_data_directory.Append(kDatabasePath);
+  return user_data_directory.Append(kDatabasePathAttr);
 }
 
 }  // namespace
diff --git a/content/browser/cookie_store/cookie_change_subscription.cc b/content/browser/cookie_store/cookie_change_subscription.cc
index fd51ab0f7..3232ad7ba 100644
--- a/content/browser/cookie_store/cookie_change_subscription.cc
+++ b/content/browser/cookie_store/cookie_change_subscription.cc
@@ -14,14 +14,15 @@
 #include "net/cookies/cookie_util.h"
 #include "net/first_party_sets/same_party_context.h"
 #include "services/network/public/cpp/is_potentially_trustworthy.h"
+#include "third_party/blink/renderer/platform/wtf/assertions.h"
 
 namespace content {
 
 namespace {
 
-#define STATIC_ASSERT_ENUM(a, b)                            \
-  static_assert(static_cast<int>(a) == static_cast<int>(b), \
-                "mismatching enums: " #a)
+//#define STATIC_ASSERT_ENUM(a, b)                            \
+//  static_assert(static_cast<int>(a) == static_cast<int>(b), \
+//                "mismatching enums: " #a)
 
 STATIC_ASSERT_ENUM(network::mojom::CookieMatchType::EQUALS,
                    proto::CookieMatchType::EQUALS);
diff --git a/content/browser/devtools/BUILD.gn b/content/browser/devtools/BUILD.gn
index 85be27d29..a16c94dce 100644
--- a/content/browser/devtools/BUILD.gn
+++ b/content/browser/devtools/BUILD.gn
@@ -82,7 +82,7 @@ action("concatenate_protocols") {
 }
 
 inspector_protocol_generate("protocol_sources") {
-  visibility = [ "//content/browser" ]
+  visibility = [ "//content/browser:*" ]
   deps = [ ":concatenate_protocols" ]
   inspector_protocol_dir = "//third_party/inspector_protocol"
   out_dir = target_gen_dir
diff --git a/content/browser/devtools/protocol/page_handler.cc b/content/browser/devtools/protocol/page_handler.cc
index bbb8bc041..1206401de 100644
--- a/content/browser/devtools/protocol/page_handler.cc
+++ b/content/browser/devtools/protocol/page_handler.cc
@@ -83,7 +83,7 @@ namespace {
 constexpr const char* kMhtml = "mhtml";
 constexpr int kDefaultScreenshotQuality = 80;
 constexpr int kMaxScreencastFramesInFlight = 2;
-constexpr char kCommandIsOnlyAvailableAtTopTarget[] =
+constexpr char kCommandIsOnlyAvailableAtTopTarget2[] =
     "Command can only be executed on top-level targets";
 constexpr char kErrorNotAttached[] = "Not attached to a page";
 constexpr char kErrorInactivePage[] = "Not attached to an active page";
@@ -2018,7 +2018,7 @@ Response PageHandler::AssureTopLevelActiveFrame() {
     return Response::ServerError(kErrorNotAttached);
 
   if (host_->GetParentOrOuterDocument())
-    return Response::ServerError(kCommandIsOnlyAvailableAtTopTarget);
+    return Response::ServerError(kCommandIsOnlyAvailableAtTopTarget2);
 
   if (!host_->IsActive())
     return Response::ServerError(kErrorInactivePage);
diff --git a/content/browser/devtools/web_contents_devtools_agent_host.cc b/content/browser/devtools/web_contents_devtools_agent_host.cc
index 2b4276b51..28604a064 100644
--- a/content/browser/devtools/web_contents_devtools_agent_host.cc
+++ b/content/browser/devtools/web_contents_devtools_agent_host.cc
@@ -17,14 +17,14 @@ namespace content {
 namespace {
 using WebContentsDevToolsMap =
     std::map<WebContents*, WebContentsDevToolsAgentHost*>;
-base::LazyInstance<WebContentsDevToolsMap>::Leaky g_agent_host_instances =
+base::LazyInstance<WebContentsDevToolsMap>::Leaky g_agent_host_instances2 =
     LAZY_INSTANCE_INITIALIZER;
 
 WebContentsDevToolsAgentHost* FindAgentHost(WebContents* wc) {
-  if (!g_agent_host_instances.IsCreated())
+  if (!g_agent_host_instances2.IsCreated())
     return nullptr;
-  auto it = g_agent_host_instances.Get().find(wc);
-  return it == g_agent_host_instances.Get().end() ? nullptr : it->second;
+  auto it = g_agent_host_instances2.Get().find(wc);
+  return it == g_agent_host_instances2.Get().end() ? nullptr : it->second;
 }
 
 bool ShouldCreateDevToolsAgentHost(WebContents* wc) {
@@ -146,7 +146,7 @@ WebContentsDevToolsAgentHost::WebContentsDevToolsAgentHost(WebContents* wc)
       auto_attacher_(std::make_unique<AutoAttacher>(wc)) {
   DCHECK(web_contents());
   bool inserted =
-      g_agent_host_instances.Get().insert(std::make_pair(wc, this)).second;
+      g_agent_host_instances2.Get().insert(std::make_pair(wc, this)).second;
   DCHECK(inserted);
   // Once created, persist till underlying WC is destroyed, so that
   // the target id is retained.
@@ -160,10 +160,10 @@ void WebContentsDevToolsAgentHost::PortalActivated(const Portal& portal) {
     WebContents* new_wc = portal.GetPortalContents();
     // Assure instrumentation calls for the new WC would be routed here.
     DCHECK(new_wc->GetResponsibleWebContents() == new_wc);
-    DCHECK(g_agent_host_instances.Get()[old_wc] == this);
+    DCHECK(g_agent_host_instances2.Get()[old_wc] == this);
 
-    g_agent_host_instances.Get().erase(old_wc);
-    g_agent_host_instances.Get()[new_wc] = this;
+    g_agent_host_instances2.Get().erase(old_wc);
+    g_agent_host_instances2.Get()[new_wc] = this;
     Observe(portal.GetPortalContents());
   }
   DCHECK(auto_attacher_);
@@ -323,7 +323,7 @@ void WebContentsDevToolsAgentHost::WebContentsDestroyed() {
   DCHECK_EQ(this, FindAgentHost(web_contents()));
   ForceDetachAllSessions();
   auto_attacher_.reset();
-  g_agent_host_instances.Get().erase(web_contents());
+  g_agent_host_instances2.Get().erase(web_contents());
   Observe(nullptr);
   // We may or may not be destruced here, depending on embedders
   // potentially retaining references.
diff --git a/content/browser/first_party_sets/first_party_set_parser.cc b/content/browser/first_party_sets/first_party_set_parser.cc
index 9c15a7d2a..61f7ad8a1 100644
--- a/content/browser/first_party_sets/first_party_set_parser.cc
+++ b/content/browser/first_party_sets/first_party_set_parser.cc
@@ -307,7 +307,7 @@ base::expected<SetsAndAliases, ParseError> ParseSet(
                    exempt_from_limits
                        ? absl::nullopt
                        : absl::make_optional(
-                             features::kFirstPartySetsMaxAssociatedSites.Get()),
+                             ::features::kFirstPartySetsMaxAssociatedSites.Get()),
            },
            {
                .field_name = kFirstPartySetServiceSitesField,
diff --git a/content/browser/first_party_sets/first_party_sets_handler_impl.cc b/content/browser/first_party_sets/first_party_sets_handler_impl.cc
index 529537fef..c83ba73fe 100644
--- a/content/browser/first_party_sets/first_party_sets_handler_impl.cc
+++ b/content/browser/first_party_sets/first_party_sets_handler_impl.cc
@@ -262,7 +262,7 @@ absl::optional<net::FirstPartySetEntry> FirstPartySetsHandlerImpl::FindEntry(
     const net::SchemefulSite& site,
     const net::FirstPartySetsContextConfig& config) const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (!base::FeatureList::IsEnabled(features::kFirstPartySets) ||
+  if (!base::FeatureList::IsEnabled(::features::kFirstPartySets) ||
       !global_sets_.has_value()) {
     return absl::nullopt;
   }
@@ -283,7 +283,7 @@ void FirstPartySetsHandlerImpl::ClearSiteDataOnChangedSetsForContext(
                             net::FirstPartySetsCacheFilter)> callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
-  if (!enabled_ || !features::kFirstPartySetsClearSiteDataOnChangedSets.Get()) {
+  if (!enabled_ || !::features::kFirstPartySetsClearSiteDataOnChangedSets.Get()) {
     std::move(callback).Run(std::move(context_config),
                             net::FirstPartySetsCacheFilter());
     return;
@@ -312,7 +312,7 @@ void FirstPartySetsHandlerImpl::ClearSiteDataOnChangedSetsForContextInternal(
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(global_sets_.has_value());
   DCHECK(!browser_context_id.empty());
-  DCHECK(enabled_ && features::kFirstPartySetsClearSiteDataOnChangedSets.Get());
+  DCHECK(enabled_ && ::features::kFirstPartySetsClearSiteDataOnChangedSets.Get());
 
   if (db_helper_.is_null()) {
     VLOG(1) << "Invalid First-Party Sets database. Failed to clear site data "
diff --git a/content/browser/gpu/compositor_util.cc b/content/browser/gpu/compositor_util.cc
index 4c013275a..1cae7beb4 100644
--- a/content/browser/gpu/compositor_util.cc
+++ b/content/browser/gpu/compositor_util.cc
@@ -108,7 +108,7 @@ const GpuFeatureData GetGpuFeatureData(
     {"canvas_oop_rasterization",
      SafeGetFeatureStatus(gpu_feature_info,
                           gpu::GPU_FEATURE_TYPE_CANVAS_OOP_RASTERIZATION),
-     !base::FeatureList::IsEnabled(features::kCanvasOopRasterization) ||
+     !base::FeatureList::IsEnabled(::features::kCanvasOopRasterization) ||
          command_line.HasSwitch(switches::kDisableAccelerated2dCanvas),
 #if 0
      // TODO(crbug.com/1240756): Remove the "#if 0" once OOPR-Canvas is fully
@@ -184,7 +184,7 @@ const GpuFeatureData GetGpuFeatureData(
 #if BUILDFLAG(ENABLE_VULKAN)
     {"vulkan",
      SafeGetFeatureStatus(gpu_feature_info, gpu::GPU_FEATURE_TYPE_VULKAN),
-     !features::IsUsingVulkan() &&
+     !::features::IsUsingVulkan() &&
          !command_line.HasSwitch(switches::kUseVulkan) /* disabled */,
      DisableInfo::NotProblem(), false /* fallback_to_software */},
 #endif
@@ -195,7 +195,7 @@ const GpuFeatureData GetGpuFeatureData(
     {"surface_control",
      SafeGetFeatureStatus(gpu_feature_info,
                           gpu::GPU_FEATURE_TYPE_ANDROID_SURFACE_CONTROL),
-     !features::IsAndroidSurfaceControlEnabled(),
+     !::features::IsAndroidSurfaceControlEnabled(),
      DisableInfo::Problem(
          "Surface Control has been disabled by Finch trial or command line."),
      false},
@@ -208,15 +208,15 @@ const GpuFeatureData GetGpuFeatureData(
      DisableInfo::Problem(
          "WebGL2 has been disabled via blocklist or the command line."),
      false},
-    {"raw_draw", gpu::kGpuFeatureStatusEnabled, !features::IsUsingRawDraw(),
+    {"raw_draw", gpu::kGpuFeatureStatusEnabled, !::features::IsUsingRawDraw(),
      DisableInfo::NotProblem(), false},
     {"direct_rendering_display_compositor", gpu::kGpuFeatureStatusEnabled,
-     !features::IsDrDcEnabled(), DisableInfo::NotProblem(), false},
+     !::features::IsDrDcEnabled(), DisableInfo::NotProblem(), false},
     {"webgpu",
      SafeGetFeatureStatus(gpu_feature_info,
                           gpu::GPU_FEATURE_TYPE_ACCELERATED_WEBGPU),
      !command_line.HasSwitch(switches::kEnableUnsafeWebGPU) &&
-         !base::FeatureList::IsEnabled(features::kWebGPUService),
+         !base::FeatureList::IsEnabled(::features::kWebGPUService),
      DisableInfo::Problem(
          "WebGPU has been disabled via blocklist or the command line."),
      false},
@@ -448,7 +448,7 @@ bool IsZeroCopyUploadEnabled() {
 
 bool IsPartialRasterEnabled() {
   // Partial raster is not supported with RawDraw.
-  if (features::IsUsingRawDraw())
+  if (::features::IsUsingRawDraw())
     return false;
   const auto& command_line = *base::CommandLine::ForCurrentProcess();
   return !command_line.HasSwitch(blink::switches::kDisablePartialRaster);
@@ -457,7 +457,7 @@ bool IsPartialRasterEnabled() {
 bool IsGpuMemoryBufferCompositorResourcesEnabled() {
   // To use Raw Draw, the Raw Draw shared image backing should be used, so
   // not use GPU memory buffer shared image backings for compositor resources.
-  if (features::IsUsingRawDraw()) {
+  if (::features::IsUsingRawDraw()) {
     return false;
   }
   const base::CommandLine& command_line =
diff --git a/content/browser/gpu/gpu_process_host.cc b/content/browser/gpu/gpu_process_host.cc
index 9f1efcdd0..4c798248d 100644
--- a/content/browser/gpu/gpu_process_host.cc
+++ b/content/browser/gpu/gpu_process_host.cc
@@ -721,7 +721,7 @@ GpuProcessHost::GpuProcessHost(int host_id, GpuProcessKind kind)
 #if !BUILDFLAG(IS_ANDROID)
   if (!in_process_ && kind != GPU_PROCESS_KIND_INFO_COLLECTION &&
       base::FeatureList::IsEnabled(
-          features::kForwardMemoryPressureEventsToGpuProcess)) {
+          ::features::kForwardMemoryPressureEventsToGpuProcess)) {
     memory_pressure_listener_ = std::make_unique<base::MemoryPressureListener>(
         FROM_HERE, base::BindRepeating(&GpuProcessHost::OnMemoryPressure,
                                        base::Unretained(this)));
diff --git a/content/browser/interest_group/interest_group_manager_impl.cc b/content/browser/interest_group/interest_group_manager_impl.cc
index bd0493b0a..d3593bc84 100644
--- a/content/browser/interest_group/interest_group_manager_impl.cc
+++ b/content/browser/interest_group/interest_group_manager_impl.cc
@@ -43,7 +43,7 @@ constexpr base::TimeDelta kMaxReportingRoundDuration = base::Minutes(10);
 // The time interval to wait before sending the next report after sending one.
 constexpr base::TimeDelta kReportingInterval = base::Milliseconds(50);
 
-constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotation =
+constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotationIGMI =
     net::DefineNetworkTrafficAnnotation("auction_report_sender", R"(
         semantics {
           sender: "Interest group based Ad Auction report"
@@ -85,7 +85,7 @@ std::unique_ptr<network::SimpleURLLoader> BuildSimpleUrlLoader(
   resource_request->trusted_params->client_security_state =
       std::move(client_security_state);
   auto simple_url_loader = network::SimpleURLLoader::Create(
-      std::move(resource_request), kTrafficAnnotation);
+      std::move(resource_request), kTrafficAnnotationIGMI);
   simple_url_loader->SetTimeoutDuration(base::Seconds(30));
   return simple_url_loader;
 }
diff --git a/content/browser/interest_group/interest_group_permissions_checker.cc b/content/browser/interest_group/interest_group_permissions_checker.cc
index 476d997dc..1ef941343 100644
--- a/content/browser/interest_group/interest_group_permissions_checker.cc
+++ b/content/browser/interest_group/interest_group_permissions_checker.cc
@@ -28,7 +28,7 @@ namespace content {
 
 namespace {
 
-constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotation =
+constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotationIGPC =
     net::DefineNetworkTrafficAnnotation("interest_group_well_known_fetcher", R"(
         semantics {
           sender: "Interest group well-known fetcher"
@@ -142,7 +142,7 @@ void InterestGroupPermissionsChecker::CheckPermissions(
 
     active_request->second->simple_url_loader =
         network::SimpleURLLoader::Create(std::move(resource_request),
-                                         kTrafficAnnotation);
+                                         kTrafficAnnotationIGPC);
     active_request->second->simple_url_loader->SetTimeoutDuration(
         kRequestTimeout);
     active_request->second->simple_url_loader->SetRequestID(
diff --git a/content/browser/media/media_internals_cdm_helper.cc b/content/browser/media/media_internals_cdm_helper.cc
index 9b7e9b27c..2d6172898 100644
--- a/content/browser/media/media_internals_cdm_helper.cc
+++ b/content/browser/media/media_internals_cdm_helper.cc
@@ -116,7 +116,7 @@ base::Value::Dict CdmInfoToDict(const CdmInfo& cdm_info) {
   return dict;
 }
 
-std::u16string SerializeUpdate(base::StringPiece function,
+std::u16string SerializeUpdate2(base::StringPiece function,
                                const base::Value::List& value) {
   base::ValueView args[] = {value};
   return content::WebUI::GetJavascriptCall(function, args);
@@ -147,7 +147,7 @@ void MediaInternalsCdmHelper::OnKeySystemCapabilitiesUpdated(
   }
 
   return MediaInternals::GetInstance()->SendUpdate(
-      SerializeUpdate("media.updateRegisteredCdms", cdm_list));
+      SerializeUpdate2("media.updateRegisteredCdms", cdm_list));
 }
 
 }  // namespace content
diff --git a/content/browser/network/cross_origin_embedder_policy_reporter.cc b/content/browser/network/cross_origin_embedder_policy_reporter.cc
index c6e078400..3ad7a82a1 100644
--- a/content/browser/network/cross_origin_embedder_policy_reporter.cc
+++ b/content/browser/network/cross_origin_embedder_policy_reporter.cc
@@ -14,7 +14,7 @@ namespace content {
 
 namespace {
 
-constexpr char kType[] = "coep";
+constexpr char kTypeCoep[] = "coep";
 
 GURL StripUsernameAndPassword(const GURL& url) {
   GURL::Replacements replacements;
@@ -109,7 +109,7 @@ void CrossOriginEmbedderPolicyReporter::QueueAndNotify(
         blink::mojom::ReportBodyElement::New("disposition", disposition));
 
     observer_->Notify(blink::mojom::Report::New(
-        kType, context_url_, blink::mojom::ReportBody::New(std::move(list))));
+        kTypeCoep, context_url_, blink::mojom::ReportBody::New(std::move(list))));
   }
   if (endpoint) {
     base::Value::Dict body_to_pass;
@@ -120,7 +120,7 @@ void CrossOriginEmbedderPolicyReporter::QueueAndNotify(
 
     if (auto* storage_partition = storage_partition_.get()) {
       storage_partition->GetNetworkContext()->QueueReport(
-          kType, *endpoint, context_url_, reporting_source_,
+          kTypeCoep, *endpoint, context_url_, reporting_source_,
           network_anonymization_key_,
           /*user_agent=*/absl::nullopt, std::move(body_to_pass));
     }
diff --git a/content/browser/preloading/prerender/prerender_host_registry.cc b/content/browser/preloading/prerender/prerender_host_registry.cc
index 1061f157c..940f00897 100644
--- a/content/browser/preloading/prerender/prerender_host_registry.cc
+++ b/content/browser/preloading/prerender/prerender_host_registry.cc
@@ -235,7 +235,7 @@ int PrerenderHostRegistry::CreateAndStartHost(
         initiator_rfh &&
         RenderFrameDevToolsAgentHost::GetFor(initiator_rfh) != nullptr;
     if (!should_prerender2holdback_be_overridden &&
-        base::FeatureList::IsEnabled(features::kPrerender2Holdback)) {
+        base::FeatureList::IsEnabled(::features::kPrerender2Holdback)) {
       if (attempt)
         attempt->SetHoldbackStatus(PreloadingHoldbackStatus::kHoldback);
       return RenderFrameHost::kNoFrameTreeNodeId;
diff --git a/content/browser/push_messaging/push_messaging_router.cc b/content/browser/push_messaging/push_messaging_router.cc
index f88e11c5c..4a74837a5 100644
--- a/content/browser/push_messaging/push_messaging_router.cc
+++ b/content/browser/push_messaging/push_messaging_router.cc
@@ -257,7 +257,7 @@ void PushMessagingRouter::FireSubscriptionChangeEvent(
     blink::mojom::PushSubscriptionPtr old_subscription,
     PushEventCallback subscription_change_callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DCHECK(base::FeatureList::IsEnabled(features::kPushSubscriptionChangeEvent));
+  DCHECK(base::FeatureList::IsEnabled(::features::kPushSubscriptionChangeEvent));
 
   StartServiceWorkerForDispatch(
       ServiceWorkerMetrics::EventType::PUSH_SUBSCRIPTION_CHANGE,
@@ -276,7 +276,7 @@ void PushMessagingRouter::FireSubscriptionChangeEventToWorker(
     scoped_refptr<DevToolsBackgroundServicesContextImpl> devtools_context,
     blink::ServiceWorkerStatusCode status) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DCHECK(base::FeatureList::IsEnabled(features::kPushSubscriptionChangeEvent));
+  DCHECK(base::FeatureList::IsEnabled(::features::kPushSubscriptionChangeEvent));
 
   if (!service_worker) {
     DCHECK_NE(blink::ServiceWorkerStatusCode::kOk, status);
diff --git a/content/browser/renderer_host/agent_scheduling_group_host.cc b/content/browser/renderer_host/agent_scheduling_group_host.cc
index a6d974dce..d6a445355 100644
--- a/content/browser/renderer_host/agent_scheduling_group_host.cc
+++ b/content/browser/renderer_host/agent_scheduling_group_host.cc
@@ -31,14 +31,6 @@ namespace {
 using ::IPC::ChannelMojo;
 using ::IPC::ChannelProxy;
 using ::IPC::Listener;
-using ::mojo::AssociatedReceiver;
-using ::mojo::AssociatedRemote;
-using ::mojo::PendingAssociatedReceiver;
-using ::mojo::PendingAssociatedRemote;
-using ::mojo::PendingReceiver;
-using ::mojo::PendingRemote;
-using ::mojo::Receiver;
-using ::mojo::Remote;
 
 static constexpr char kAgentSchedulingGroupHostDataKey[] =
     "AgentSchedulingGroupHostUserDataKey";
@@ -63,10 +55,10 @@ struct AgentSchedulingGroupHostUserData : public base::SupportsUserData::Data {
 #endif
 };
 
-static features::MBIMode GetMBIMode() {
-  return base::FeatureList::IsEnabled(features::kMBIMode)
-             ? features::kMBIModeParam.Get()
-             : features::MBIMode::kLegacy;
+static ::features::MBIMode GetMBIMode() {
+  return base::FeatureList::IsEnabled(::features::kMBIMode)
+             ? ::features::kMBIModeParam.Get()
+             : ::features::MBIMode::kLegacy;
 }
 
 }  // namespace
@@ -88,8 +80,8 @@ AgentSchedulingGroupHost* AgentSchedulingGroupHost::GetOrCreate(
 
   DCHECK(data);
 
-  if (GetMBIMode() == features::MBIMode::kLegacy ||
-      GetMBIMode() == features::MBIMode::kEnabledPerRenderProcessHost) {
+  if (GetMBIMode() == ::features::MBIMode::kLegacy ||
+      GetMBIMode() == ::features::MBIMode::kEnabledPerRenderProcessHost) {
     // We don't use |data->site_instance_groups| at all when
     // AgentSchedulingGroupHost is 1:1 with RenderProcessHost.
 #if DCHECK_IS_ON()
@@ -113,7 +105,7 @@ AgentSchedulingGroupHost* AgentSchedulingGroupHost::GetOrCreate(
     return data->owned_host_set.begin()->get();
   }
 
-  DCHECK_EQ(GetMBIMode(), features::MBIMode::kEnabledPerSiteInstance);
+  DCHECK_EQ(GetMBIMode(), ::features::MBIMode::kEnabledPerSiteInstance);
 
   // If we're in an MBI mode that creates multiple AgentSchedulingGroupHosts
   // per RenderProcessHost, then this will be called whenever SiteInstance needs
@@ -231,7 +223,7 @@ void AgentSchedulingGroupHost::AddFilter(BrowserMessageFilter* filter) {
   DCHECK(filter);
   // When MBI mode is disabled, we forward these kinds of requests straight to
   // the underlying `RenderProcessHost`.
-  if (GetMBIMode() == features::MBIMode::kLegacy) {
+  if (GetMBIMode() == ::features::MBIMode::kLegacy) {
     process_->AddFilter(filter);
     return;
   }
@@ -272,7 +264,7 @@ base::SafeRef<AgentSchedulingGroupHost> AgentSchedulingGroupHost::GetSafeRef()
 ChannelProxy* AgentSchedulingGroupHost::GetChannel() {
   DCHECK_EQ(state_, LifecycleState::kBound);
 
-  if (GetMBIMode() == features::MBIMode::kLegacy)
+  if (GetMBIMode() == ::features::MBIMode::kLegacy)
     return process_->GetChannel();
 
   DCHECK(channel_);
@@ -284,7 +276,7 @@ bool AgentSchedulingGroupHost::Send(IPC::Message* message) {
 
   std::unique_ptr<IPC::Message> msg(message);
 
-  if (GetMBIMode() == features::MBIMode::kLegacy)
+  if (GetMBIMode() == ::features::MBIMode::kLegacy)
     return process_->Send(msg.release());
 
   // This DCHECK is too idealistic for now - messages that are handled by
@@ -414,7 +406,7 @@ void AgentSchedulingGroupHost::SetUpIPC() {
   // 3. All the ASGH's other associated interfaces can now be initialized via
   //    `mojo_remote_`, and will be transitively associated with the appropriate
   //    IPC channel/pipe.
-  if (GetMBIMode() == features::MBIMode::kLegacy) {
+  if (GetMBIMode() == ::features::MBIMode::kLegacy) {
     process_->GetRendererInterface()->CreateAssociatedAgentSchedulingGroup(
         mojo_remote_.BindNewEndpointAndPassReceiver(),
         broker_receiver_.BindNewPipeAndPassRemote());
@@ -422,7 +414,7 @@ void AgentSchedulingGroupHost::SetUpIPC() {
     auto io_task_runner = GetIOThreadTaskRunner({});
 
     // Empty interface endpoint to pass pipes more easily.
-    PendingRemote<IPC::mojom::ChannelBootstrap> bootstrap;
+    mojo::PendingRemote<IPC::mojom::ChannelBootstrap> bootstrap;
 
     process_->GetRendererInterface()->CreateAgentSchedulingGroup(
         bootstrap.InitWithNewPipeAndPassReceiver(),
diff --git a/content/browser/renderer_host/code_cache_host_impl.h b/content/browser/renderer_host/code_cache_host_impl.h
index d6742b024..b9f34730a 100644
--- a/content/browser/renderer_host/code_cache_host_impl.h
+++ b/content/browser/renderer_host/code_cache_host_impl.h
@@ -12,6 +12,8 @@
 #include "base/memory/weak_ptr.h"
 #include "build/build_config.h"
 #include "components/services/storage/public/mojom/cache_storage_control.mojom.h"
+#include "content/browser/code_cache/generated_code_cache.h"
+#include "content/browser/code_cache/generated_code_cache_context.h"
 #include "content/common/content_export.h"
 #include "mojo/public/cpp/base/big_buffer.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
@@ -28,8 +30,8 @@ class Origin;
 
 namespace content {
 
-class GeneratedCodeCache;
-class GeneratedCodeCacheContext;
+// class GeneratedCodeCache;
+// class GeneratedCodeCacheContext;
 
 // The implementation of a CodeCacheHost, which stores and retrieves resource
 // metadata, either bytecode or native code, generated by a renderer process.
diff --git a/content/browser/renderer_host/media/media_stream_manager.cc b/content/browser/renderer_host/media/media_stream_manager.cc
index b45f3f65a..f7c81e687 100644
--- a/content/browser/renderer_host/media/media_stream_manager.cc
+++ b/content/browser/renderer_host/media/media_stream_manager.cc
@@ -201,7 +201,7 @@ MediaDeviceType ConvertToMediaDeviceType(MediaStreamType stream_type) {
   return MediaDeviceType::NUM_MEDIA_DEVICE_TYPES;
 }
 
-const char* DeviceTypeToString(MediaDeviceType type) {
+const char* DeviceTypeToStringMSM(MediaDeviceType type) {
   switch (type) {
     case MediaDeviceType::MEDIA_AUDIO_INPUT:
       return "DEVICE_AUDIO_INPUT";
@@ -366,7 +366,7 @@ std::string GetStopStreamDeviceLogString(
       session_id.ToString().c_str());
 }
 
-void SendLogMessage(const std::string& message) {
+void SendLogMessageMSM(const std::string& message) {
   MediaStreamManager::SendMessageToNativeLog("MSM::" + message);
 }
 
@@ -762,7 +762,7 @@ class MediaStreamManager::DeviceRequest {
         video_type_(MediaStreamType::NO_SERVICE),
         target_process_id_(-1),
         target_frame_id_(-1) {
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::DeviceRequest({requesting_process_id=%d}, "
         "{requesting_frame_id=%d}, {requester_id=%d}, {request_type=%s})",
         requesting_process_id, requesting_frame_id, requester_id,
@@ -779,7 +779,7 @@ class MediaStreamManager::DeviceRequest {
   void SetAudioType(MediaStreamType audio_type) {
     DCHECK(blink::IsAudioInputMediaType(audio_type) ||
            audio_type == MediaStreamType::NO_SERVICE);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::SetAudioType([requester_id=%d] {audio_type=%s})", requester_id,
         StreamTypeToString(audio_type)));
     audio_type_ = audio_type;
@@ -800,7 +800,7 @@ class MediaStreamManager::DeviceRequest {
   void CreateUIRequest(const std::string& requested_audio_device_id,
                        const std::string& requested_video_device_id) {
     DCHECK(!ui_request_);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::CreateUIRequest([requester_id=%d] {requested_audio_device_id=%s}, "
         "{requested_video_device_id=%s})",
         requester_id, requested_audio_device_id.c_str(),
@@ -844,7 +844,7 @@ class MediaStreamManager::DeviceRequest {
 
   // Update the request state and notify observers.
   void SetState(MediaStreamType stream_type, MediaRequestState new_state) {
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::SetState([requester_id=%d] {stream_type=%s}, {new_state=%s})",
         requester_id, StreamTypeToString(stream_type),
         RequestStateToString(new_state)));
@@ -1136,7 +1136,7 @@ class MediaStreamManager::MediaAccessRequest
       const blink::mojom::StreamDevicesSet& stream_devices_set) override {
     DCHECK_CURRENTLY_ON(BrowserThread::IO);
     DCHECK(media_access_request_cb_);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "FinalizeMediaAccessRequest({label=%s}, {requester_id="
         "%d}, {request_type=%s})",
         label.c_str(), requester_id, RequestTypeToString(request_type())));
@@ -1202,7 +1202,7 @@ class MediaStreamManager::CreateDeviceRequest
     const blink::mojom::StreamDevices& new_devices =
         *stream_devices_set.stream_devices[0];
 
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "FinalizeChangeDevice({label=%s}, {requester_id="
         "%d}, {request_type=%s})",
         label.c_str(), requester_id, RequestTypeToString(request_type())));
@@ -1486,7 +1486,7 @@ class MediaStreamManager::OpenDeviceRequest
   void FinalizeRequest(const std::string& label) override {
     DCHECK_CURRENTLY_ON(BrowserThread::IO);
     DCHECK(open_device_cb_);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "FinalizeOpenDevice({label=%s}, {requester_id="
         "%d}, {request_type=%s})",
         label.c_str(), requester_id, RequestTypeToString(request_type())));
@@ -1530,7 +1530,7 @@ void MediaStreamManager::SendMessageToNativeLog(const std::string& message) {
 
 MediaStreamManager::MediaStreamManager(media::AudioSystem* audio_system)
     : MediaStreamManager(audio_system, nullptr) {
-  SendLogMessage(base::StringPrintf("MediaStreamManager([this=%p]))", this));
+  SendLogMessageMSM(base::StringPrintf("MediaStreamManager([this=%p]))", this));
 }
 
 MediaStreamManager::MediaStreamManager(
@@ -1709,7 +1709,7 @@ void MediaStreamManager::GenerateStreams(
     DeviceRequestStateChangeCallback device_request_state_change_cb,
     DeviceCaptureHandleChangeCallback device_capture_handle_change_cb) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(GetGenerateStreamsLogString(render_process_id, render_frame_id,
+  SendLogMessageMSM(GetGenerateStreamsLogString(render_process_id, render_frame_id,
                                              requester_id, page_request_id));
   std::unique_ptr<DeviceRequest> request =
       std::make_unique<GenerateStreamsRequest>(
@@ -1828,7 +1828,7 @@ void MediaStreamManager::CancelRequest(const std::string& label) {
 
   const DeviceRequests::const_iterator request_it = FindRequestIterator(label);
   if (request_it == requests_.end()) {
-    SendLogMessage(
+    SendLogMessageMSM(
         base::StringPrintf("CancelRequest({label=%s})", label.c_str()));
     LOG(ERROR) << "The request with label = " << label << " does not exist.";
     return;
@@ -1847,7 +1847,7 @@ void MediaStreamManager::CancelRequest(
   const std::string& label = request_it->first;
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("CancelRequest({label=%s})", label.c_str()));
 
   // This is a request for closing one or more devices.
@@ -1906,7 +1906,7 @@ void MediaStreamManager::StopStreamDevice(
     const std::string& device_id,
     const base::UnguessableToken& session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(GetStopStreamDeviceLogString(
+  SendLogMessageMSM(GetStopStreamDeviceLogString(
       render_process_id, render_frame_id, requester_id, device_id, session_id));
 
   // Find the first request for this |render_process_id| and |render_frame_id|
@@ -2007,7 +2007,7 @@ base::UnguessableToken MediaStreamManager::VideoDeviceIdToSessionId(
 void MediaStreamManager::StopDevice(MediaStreamType type,
                                     const base::UnguessableToken& session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("StopDevice({type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("StopDevice({type=%s}, {session_id=%s})",
                                     StreamTypeToString(type),
                                     session_id.ToString().c_str()));
   DeviceRequests::const_iterator request_it = requests_.begin();
@@ -2070,7 +2070,7 @@ void MediaStreamManager::StopDevice(MediaStreamType type,
 void MediaStreamManager::CloseDevice(MediaStreamType type,
                                      const base::UnguessableToken& session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("CloseDevice({type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("CloseDevice({type=%s}, {session_id=%s})",
                                     StreamTypeToString(type),
                                     session_id.ToString().c_str()));
   GetDeviceManager(type)->Close(session_id);
@@ -2127,7 +2127,7 @@ void MediaStreamManager::OpenDevice(int render_process_id,
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(type == MediaStreamType::DEVICE_AUDIO_CAPTURE ||
          type == MediaStreamType::DEVICE_VIDEO_CAPTURE);
-  SendLogMessage(GetOpenDeviceLogString(render_process_id, render_frame_id,
+  SendLogMessageMSM(GetOpenDeviceLogString(render_process_id, render_frame_id,
                                         requester_id, page_request_id,
                                         device_id, type));
   StreamControls controls;
@@ -2197,9 +2197,9 @@ void MediaStreamManager::StopRemovedDevice(
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(type == MediaDeviceType::MEDIA_AUDIO_INPUT ||
          type == MediaDeviceType::MEDIA_VIDEO_INPUT);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
                      "StopRemovedDevice({type=%s}, {device=[id: %s, name: %s]}",
-                     DeviceTypeToString(type),
+                     DeviceTypeToStringMSM(type),
                      media_device_info.device_id.c_str(),
                      media_device_info.label.c_str())
                      .c_str());
@@ -2289,7 +2289,7 @@ void MediaStreamManager::TranslateDeviceIdToSourceId(
 void MediaStreamManager::StartEnumeration(DeviceRequest* request,
                                           const std::string& label) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("StartEnumeration({requester_id=%d}, {label=%s})",
                          request->requester_id, label.c_str()));
 
@@ -2334,7 +2334,7 @@ MediaStreamManager::AddRequest(std::unique_ptr<DeviceRequest> request) {
     unique_label = base::GenerateGUID();
   } while (FindRequest(unique_label) != nullptr);
 
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("AddRequest([requester_id=%d]) => (label=%s)",
                          request->requester_id, unique_label.c_str()));
   request->SetLabel(unique_label);
@@ -2449,7 +2449,7 @@ void MediaStreamManager::DeleteRequest(
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(request_it != requests_.end());
 
-  SendLogMessage(base::StringPrintf("DeleteRequest([label=%s])",
+  SendLogMessageMSM(base::StringPrintf("DeleteRequest([label=%s])",
                                     request_it->first.c_str()));
 #if BUILDFLAG(IS_CHROMEOS)
   if (request_it->second->IsGetDisplayMediaSet()) {
@@ -2505,7 +2505,7 @@ void MediaStreamManager::PostRequestToUI(
     return;
   }
   DCHECK(request->HasUIRequest());
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("PostRequestToUI({label=%s}, ", label.c_str()));
 
   const MediaStreamType audio_type = request->audio_type();
@@ -2543,7 +2543,7 @@ void MediaStreamManager::SetUpRequest(const std::string& label) {
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("SetUpRequest([requester_id=%d] {label=%s})",
                          request->requester_id, label.c_str()));
 
@@ -2650,7 +2650,7 @@ bool MediaStreamManager::SetUpDeviceCaptureRequest(
           request->audio_type() == MediaStreamType::NO_SERVICE) &&
          (request->video_type() == MediaStreamType::DEVICE_VIDEO_CAPTURE ||
           request->video_type() == MediaStreamType::NO_SERVICE));
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "SetUpDeviceCaptureRequest([requester_id=%d])", request->requester_id));
   std::string audio_device_id;
   if (request->stream_controls().audio.requested() &&
@@ -2904,7 +2904,7 @@ void MediaStreamManager::FinalizeGenerateStreams(const std::string& label,
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(request);
   DCHECK_EQ(request->request_type(), blink::MEDIA_GENERATE_STREAM);
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("FinalizeGenerateStreams({label=%s}, {requester_id="
                          "%d}, {request_type=%s})",
                          label.c_str(), request->requester_id,
@@ -2947,7 +2947,7 @@ void MediaStreamManager::FinalizeGetOpenDevice(const std::string& label,
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(request);
   DCHECK_EQ(request->request_type(), blink::MEDIA_GET_OPEN_DEVICE);
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("FinalizeGetOpenDevice({label=%s}, {requester_id="
                          "%d}, {request_type=%s})",
                          label.c_str(), request->requester_id,
@@ -2987,7 +2987,7 @@ void MediaStreamManager::PanTiltZoomPermissionChecked(
     return;
   }
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "PanTiltZoomPermissionChecked({label=%s}, {requester_id="
       "%d}, {request_type=%s}, {pan_tilt_zoom_allowed=%d})",
       label.c_str(), request->requester_id,
@@ -3039,7 +3039,7 @@ void MediaStreamManager::FinalizeRequestFailed(
 
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "FinalizeRequestFailed({label=%s}, {requester_id=%d}, {result=%s})",
       request_it->first.c_str(), request->requester_id,
       RequestResultToString(result)));
@@ -3132,7 +3132,7 @@ void MediaStreamManager::InitializeMaybeAsync(
                                   std::move(video_capture_provider)));
     return;
   }
-  SendLogMessage(base::StringPrintf("InitializeMaybeAsync([this=%p])", this));
+  SendLogMessageMSM(base::StringPrintf("InitializeMaybeAsync([this=%p])", this));
 
   // Store a pointer to |this| on the IO thread to avoid having to jump to
   // the UI thread to fetch a pointer to the MSM. In particular on Android,
@@ -3169,7 +3169,7 @@ void MediaStreamManager::Opened(
     MediaStreamType stream_type,
     const base::UnguessableToken& capture_session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("Opened({stream_type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("Opened({stream_type=%s}, {session_id=%s})",
                                     StreamTypeToString(stream_type),
                                     capture_session_id.ToString().c_str()));
 
@@ -3282,7 +3282,7 @@ void MediaStreamManager::Closed(
     MediaStreamType stream_type,
     const base::UnguessableToken& capture_session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("Closed({stream_type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("Closed({stream_type=%s}, {session_id=%s})",
                                     StreamTypeToString(stream_type),
                                     capture_session_id.ToString().c_str()));
 }
@@ -3300,7 +3300,7 @@ void MediaStreamManager::DevicesEnumerated(
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "DevicesEnumerated({label=%s}, {requester_id=%d}, {request_type=%s})",
       label.c_str(), request->requester_id,
       RequestTypeToString(request->request_type())));
@@ -3331,7 +3331,7 @@ void MediaStreamManager::Aborted(
     MediaStreamType stream_type,
     const base::UnguessableToken& capture_session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "Aborted({stream_type=%s}, {session_id=%s})",
       StreamTypeToString(stream_type), capture_session_id.ToString().c_str()));
   StopDevice(stream_type, capture_session_id);
@@ -3397,7 +3397,7 @@ void MediaStreamManager::HandleAccessRequestResponse(
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "HandleAccessRequestResponse({label=%s}, {request=%s}, {result=%s})",
       label.c_str(), RequestTypeToString(request->request_type()),
       RequestResultToString(result)));
@@ -3493,7 +3493,7 @@ void MediaStreamManager::HandleAccessRequestResponse(
               *request->stream_devices_set.stream_devices[stream_index],
               device);
           request->SetState(device.type, state);
-          SendLogMessage(base::StringPrintf(
+          SendLogMessageMSM(base::StringPrintf(
               "HandleAccessRequestResponse([label=%s]) => "
               "(already opened device: [id: %s, session_id: %s])",
               label.c_str(), device.id.c_str(),
@@ -3510,7 +3510,7 @@ void MediaStreamManager::HandleAccessRequestResponse(
           current_state != MEDIA_REQUEST_STATE_ERROR) {
         request->SetState(device.type, MEDIA_REQUEST_STATE_OPENING);
       }
-      SendLogMessage(
+      SendLogMessageMSM(
           base::StringPrintf("HandleAccessRequestResponse([label=%s]) => "
                              "(opening device: [id: %s, session_id: %s])",
                              label.c_str(), device.id.c_str(),
@@ -3589,7 +3589,7 @@ void MediaStreamManager::StopMediaStreamFromBrowser(const std::string& label) {
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf("StopMediaStreamFromBrowser({label=%s})",
+  SendLogMessageMSM(base::StringPrintf("StopMediaStreamFromBrowser({label=%s})",
                                     label.c_str()));
 
   // Notify renderers that the devices in the stream will be stopped.
@@ -3643,7 +3643,7 @@ void MediaStreamManager::ChangeMediaStreamSourceFromBrowser(
     }
   }
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "ChangeMediaStreamSourceFromBrowser({label=%s})", label.c_str()));
 
   SetUpDesktopCaptureChangeSourceRequest(request, label, media_id);
@@ -3661,7 +3661,7 @@ void MediaStreamManager::OnRequestStateChangeFromBrowser(
     return;
   }
 
-  SendLogMessage(base::StringPrintf("RequestStateChangeFromBrowser({label=%s})",
+  SendLogMessageMSM(base::StringPrintf("RequestStateChangeFromBrowser({label=%s})",
                                     label.c_str()));
 
   request->OnRequestStateChangeFromBrowser(label, media_id, new_state);
@@ -3692,8 +3692,8 @@ void MediaStreamManager::NotifyDevicesChanged(
     MediaDeviceType device_type,
     const blink::WebMediaDeviceInfoArray& devices) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("NotifyDevicesChanged({device_type=%s})",
-                                    DeviceTypeToString(device_type)));
+  SendLogMessageMSM(base::StringPrintf("NotifyDevicesChanged({device_type=%s})",
+                                    DeviceTypeToStringMSM(device_type)));
 
   MediaObserver* media_observer =
       GetContentClient()->browser()->GetMediaObserver();
@@ -3721,7 +3721,7 @@ void MediaStreamManager::NotifyDevicesChanged(
 
 bool MediaStreamManager::RequestDone(const DeviceRequest& request) const {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "RequestDone({requester_id=%d}, {request_type=%s})", request.requester_id,
       RequestTypeToString(request.request_type())));
 
@@ -3985,7 +3985,7 @@ void MediaStreamManager::OnStreamStarted(const std::string& label) {
   if (!request) {
     return;
   }
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "OnStreamStarted({label=%s}, {requester_id=%d}, {request_type=%s})",
       label.c_str(), request->requester_id,
       RequestTypeToString(request->request_type())));
diff --git a/content/browser/renderer_host/media/media_stream_power_logger.cc b/content/browser/renderer_host/media/media_stream_power_logger.cc
index 733d66510..450a1eb28 100644
--- a/content/browser/renderer_host/media/media_stream_power_logger.cc
+++ b/content/browser/renderer_host/media/media_stream_power_logger.cc
@@ -11,7 +11,7 @@
 namespace content {
 
 namespace {
-void SendLogMessage(const std::string& message) {
+void SendLogMessageMSPL(const std::string& message) {
   MediaStreamManager::SendMessageToNativeLog("MSPL::" + message);
 }
 }  // namespace
@@ -27,23 +27,23 @@ MediaStreamPowerLogger::~MediaStreamPowerLogger() {
 }
 
 void MediaStreamPowerLogger::OnSuspend() {
-  SendLogMessage(base::StringPrintf("OnSuspend([this=%p])", this));
+  SendLogMessageMSPL(base::StringPrintf("OnSuspend([this=%p])", this));
 }
 
 void MediaStreamPowerLogger::OnResume() {
-  SendLogMessage(base::StringPrintf("OnResume([this=%p])", this));
+  SendLogMessageMSPL(base::StringPrintf("OnResume([this=%p])", this));
 }
 
 void MediaStreamPowerLogger::OnThermalStateChange(
     base::PowerThermalObserver::DeviceThermalState new_state) {
   const char* state_name =
       base::PowerMonitorSource::DeviceThermalStateToString(new_state);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSPL(base::StringPrintf(
       "OnThermalStateChange({this=%p}, {new_state=%s})", this, state_name));
 }
 
 void MediaStreamPowerLogger::OnSpeedLimitChange(int new_limit) {
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSPL(base::StringPrintf(
       "OnSpeedLimitChange({this=%p}, {new_limit=%d})", this, new_limit));
 }
 
diff --git a/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc b/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc
index a1e16c8e7..09a6976d1 100644
--- a/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc
+++ b/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc
@@ -81,7 +81,7 @@ void CallRemove(scoped_refptr<storage::FileSystemContext> file_system_context,
                                                   std::move(callback));
 }
 
-void CallTouchFile(
+void CallTouchFile2(
     scoped_refptr<storage::FileSystemContext> file_system_context,
     const storage::FileSystemURL& url,
     const base::Time& last_access_time,
@@ -246,7 +246,7 @@ int32_t PepperInternalFileRefBackend::Touch(
   GetIOThreadTaskRunner({})->PostTask(
       FROM_HERE,
       base::BindOnce(
-          CallTouchFile, GetFileSystemContext(), GetFileSystemURL(),
+          CallTouchFile2, GetFileSystemContext(), GetFileSystemURL(),
           last_access_time, last_modified_time,
           base::BindOnce(&PepperInternalFileRefBackend::DidFinishOnIOThread,
                          weak_factory_.GetWeakPtr(), reply_context,
diff --git a/content/browser/renderer_host/render_frame_proxy_host.cc b/content/browser/renderer_host/render_frame_proxy_host.cc
index 9fe6bf4e2..20d2ee941 100644
--- a/content/browser/renderer_host/render_frame_proxy_host.cc
+++ b/content/browser/renderer_host/render_frame_proxy_host.cc
@@ -65,10 +65,10 @@ typedef std::unordered_map<RenderFrameProxyHostID,
 base::LazyInstance<RoutingIDFrameProxyMap>::DestructorAtExit
     g_routing_id_frame_proxy_map = LAZY_INSTANCE_INITIALIZER;
 
-using TokenFrameMap = std::unordered_map<blink::RemoteFrameToken,
-                                         RenderFrameProxyHost*,
-                                         blink::RemoteFrameToken::Hasher>;
-base::LazyInstance<TokenFrameMap>::Leaky g_token_frame_proxy_map =
+using TokenFrameProxyMap = std::unordered_map<blink::RemoteFrameToken,
+                                              RenderFrameProxyHost*,
+                                              blink::RemoteFrameToken::Hasher>;
+base::LazyInstance<TokenFrameProxyMap>::Leaky g_token_frame_proxy_map =
     LAZY_INSTANCE_INITIALIZER;
 
 }  // namespace
@@ -94,7 +94,7 @@ RenderFrameProxyHost* RenderFrameProxyHost::FromFrameToken(
     int process_id,
     const blink::RemoteFrameToken& frame_token) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  TokenFrameMap* frames = g_token_frame_proxy_map.Pointer();
+  TokenFrameProxyMap* frames = g_token_frame_proxy_map.Pointer();
   auto it = frames->find(frame_token);
   // The check against |process_id| isn't strictly necessary, but represents
   // an extra level of protection against a renderer trying to force a frame
@@ -108,7 +108,7 @@ RenderFrameProxyHost* RenderFrameProxyHost::FromFrameToken(
 bool RenderFrameProxyHost::IsFrameTokenInUse(
     const blink::RemoteFrameToken& frame_token) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  TokenFrameMap* frames = g_token_frame_proxy_map.Pointer();
+  TokenFrameProxyMap* frames = g_token_frame_proxy_map.Pointer();
   return frames->find(frame_token) != frames->end();
 }
 
diff --git a/content/browser/service_worker/embedded_worker_instance.cc b/content/browser/service_worker/embedded_worker_instance.cc
index 2f01803d5..3e817c255 100644
--- a/content/browser/service_worker/embedded_worker_instance.cc
+++ b/content/browser/service_worker/embedded_worker_instance.cc
@@ -872,7 +872,7 @@ EmbeddedWorkerInstance::CreateFactoryBundle(
   non_network_factories[url::kDataScheme] = DataURLLoaderFactory::Create();
   // Allow service workers for chrome:// or chrome-untrusted:// based on flags.
   if (base::FeatureList::IsEnabled(
-          features::kEnableServiceWorkersForChromeScheme) &&
+          ::features::kEnableServiceWorkersForChromeScheme) &&
       origin.scheme() == content::kChromeUIScheme) {
     non_network_factories.emplace(
         content::kChromeUIScheme,
@@ -880,7 +880,7 @@ EmbeddedWorkerInstance::CreateFactoryBundle(
                                               content::kChromeUIScheme,
                                               base::flat_set<std::string>()));
   } else if (base::FeatureList::IsEnabled(
-                 features::kEnableServiceWorkersForChromeUntrusted) &&
+                 ::features::kEnableServiceWorkersForChromeUntrusted) &&
              origin.scheme() == content::kChromeUIUntrustedScheme) {
     non_network_factories.emplace(
         content::kChromeUIUntrustedScheme,
diff --git a/content/browser/service_worker/service_worker_context_wrapper.cc b/content/browser/service_worker/service_worker_context_wrapper.cc
index 88a5ecbb0..eb845c720 100644
--- a/content/browser/service_worker/service_worker_context_wrapper.cc
+++ b/content/browser/service_worker/service_worker_context_wrapper.cc
@@ -1699,7 +1699,7 @@ ServiceWorkerContextWrapper::GetLoaderFactoryForBrowserInitiatedRequest(
   } else {
     DCHECK(storage_partition());
     if (base::FeatureList::IsEnabled(
-            features::kPrivateNetworkAccessForWorkers)) {
+            ::features::kPrivateNetworkAccessForWorkers)) {
       if (g_loader_factory_interceptor.Get()) {
         g_loader_factory_interceptor.Get().Run(&pending_receiver);
       }
@@ -1740,7 +1740,7 @@ ServiceWorkerContextWrapper::GetLoaderFactoryForBrowserInitiatedRequest(
     // create a `WebUI` or a `WebUIController` for WebUI Service Workers so we
     // register the URLDataSource directly.
     if (base::FeatureList::IsEnabled(
-            features::kEnableServiceWorkersForChromeScheme) &&
+            ::features::kEnableServiceWorkersForChromeScheme) &&
         scope.scheme_piece() == kChromeUIScheme) {
       config->RegisterURLDataSource(browser_context());
       static_cast<blink::PendingURLLoaderFactoryBundle*>(
@@ -1750,7 +1750,7 @@ ServiceWorkerContextWrapper::GetLoaderFactoryForBrowserInitiatedRequest(
                                         browser_context(), kChromeUIScheme,
                                         base::flat_set<std::string>()));
     } else if (base::FeatureList::IsEnabled(
-                   features::kEnableServiceWorkersForChromeUntrusted) &&
+                   ::features::kEnableServiceWorkersForChromeUntrusted) &&
                scope.scheme_piece() == kChromeUIUntrustedScheme) {
       config->RegisterURLDataSource(browser_context());
       static_cast<blink::PendingURLLoaderFactoryBundle*>(
diff --git a/content/browser/service_worker/service_worker_controllee_request_handler.cc b/content/browser/service_worker/service_worker_controllee_request_handler.cc
index e82496b98..7b273e0ac 100644
--- a/content/browser/service_worker/service_worker_controllee_request_handler.cc
+++ b/content/browser/service_worker/service_worker_controllee_request_handler.cc
@@ -89,7 +89,7 @@ const char* FetchHandlerTypeToString(
 const base::flat_set<std::string> FetchHandlerBypassedHashStrings() {
   const static base::NoDestructor<base::flat_set<std::string>> result(
       base::SplitString(
-          features::kServiceWorkerBypassFetchHandlerBypassedHashStrings.Get(),
+          ::features::kServiceWorkerBypassFetchHandlerBypassedHashStrings.Get(),
           ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY));
 
   return *result;
@@ -98,22 +98,22 @@ const base::flat_set<std::string> FetchHandlerBypassedHashStrings() {
 bool ShouldBypassFetchHandlerForMainResource(
     const std::string& sha256_script_checksum) {
   if (!base::FeatureList::IsEnabled(
-          features::kServiceWorkerBypassFetchHandler)) {
+          ::features::kServiceWorkerBypassFetchHandler)) {
     return false;
   }
 
-  if (features::kServiceWorkerBypassFetchHandlerTarget.Get() !=
-      features::ServiceWorkerBypassFetchHandlerTarget::kMainResource) {
+  if (::features::kServiceWorkerBypassFetchHandlerTarget.Get() !=
+      ::features::ServiceWorkerBypassFetchHandlerTarget::kMainResource) {
     return false;
   }
 
   // If the feature is enabled, the main resource request bypasses ServiceWorker
   // and starts the worker in parallel for subsequent subresources.
-  switch (features::kServiceWorkerBypassFetchHandlerStrategy.Get()) {
+  switch (::features::kServiceWorkerBypassFetchHandlerStrategy.Get()) {
     // kFeatureOptIn means that the feature relies on the manual feature
     // toggle from about://flags etc, which is triggered by developers. We
     // bypass fetch handler regardless of the url matching in this case.
-    case features::ServiceWorkerBypassFetchHandlerStrategy::kFeatureOptIn:
+    case ::features::ServiceWorkerBypassFetchHandlerStrategy::kFeatureOptIn:
       RecordSkipReason(
           ServiceWorkerControlleeRequestHandler::FetchHandlerSkipReason::
               kMainResourceSkippedDueToFeatureFlag);
@@ -121,7 +121,7 @@ bool ShouldBypassFetchHandlerForMainResource(
     // If kAllowList, the allowlist should be specified. In this case, main
     // resource fetch handlers are bypassed only when the sha256 checksum of the
     // script is in the allowlist.
-    case features::ServiceWorkerBypassFetchHandlerStrategy::kAllowList:
+    case ::features::ServiceWorkerBypassFetchHandlerStrategy::kAllowList:
       if (FetchHandlerBypassedHashStrings().contains(sha256_script_checksum)) {
         RecordSkipReason(
             ServiceWorkerControlleeRequestHandler::FetchHandlerSkipReason::
@@ -535,7 +535,7 @@ void ServiceWorkerControlleeRequestHandler::ContinueWithActivatedVersion(
       registration->active_version()->CountFeature(
           blink::mojom::WebFeature::kServiceWorkerSkippedForEmptyFetchHandler);
       CompleteWithoutLoader();
-      if (!features::kStartServiceWorkerForEmptyFetchHandler.Get()) {
+      if (!::features::kStartServiceWorkerForEmptyFetchHandler.Get()) {
         return;
       }
       // Start service worker if it is not running so that we run the code
diff --git a/content/child/BUILD.gn b/content/child/BUILD.gn
index 2a07e5889..e8fb5d7af 100644
--- a/content/child/BUILD.gn
+++ b/content/child/BUILD.gn
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 import("//build/config/features.gni")
+import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//device/vr/buildflags/buildflags.gni")
 import("//ppapi/buildflags/buildflags.gni")
@@ -12,9 +13,9 @@ if (is_android) {
 }
 
 if (is_component_build) {
-  link_target_type = "source_set"
+  link_target_type = "jumbo_source_set"
 } else {
-  link_target_type = "static_library"
+  link_target_type = "jumbo_static_library"
 }
 target(link_target_type, "child") {
   # Targets external to content should always link to the public API.
diff --git a/content/common/BUILD.gn b/content/common/BUILD.gn
index d01ad9dbe..4b04d2463 100644
--- a/content/common/BUILD.gn
+++ b/content/common/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("//build/buildflag_header.gni")
 import("//build/config/features.gni")
+import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//content/public/common/zygote/features.gni")
 import("//ipc/features.gni")
@@ -59,7 +60,7 @@ if (is_linux || is_chromeos) {
   }
 }
 
-source_set("common") {
+jumbo_source_set("common") {
   # Targets external to content should always link to the public API.
   # In addition, targets outside of the content component (shell and tests)
   # must not link to this because it will duplicate the code in the component
@@ -165,6 +166,11 @@ source_set("common") {
     "webid/identity_url_loader_throttle.cc",
     "webid/identity_url_loader_throttle.h",
   ]
+  jumbo_excluded_sources = [
+    "common_param_traits.cc",
+    "content_message_generator.cc",
+    "content_param_traits.cc",
+  ]
 
   configs += [
     "//content:content_implementation",
diff --git a/content/renderer/pepper/pepper_plugin_instance_impl.h b/content/renderer/pepper/pepper_plugin_instance_impl.h
index a3f99906e..0c4e9ede8 100644
--- a/content/renderer/pepper/pepper_plugin_instance_impl.h
+++ b/content/renderer/pepper/pepper_plugin_instance_impl.h
@@ -66,6 +66,11 @@
 #include "v8/include/v8-forward.h"
 #include "v8/include/v8-persistent-handle.h"
 
+// Windows defines 'PostMessage', so we have to undef it.
+#ifdef PostMessage
+#undef PostMessage
+#endif
+
 struct PP_Point;
 
 namespace blink {
diff --git a/content/renderer/service_worker/web_service_worker_provider_impl.cc b/content/renderer/service_worker/web_service_worker_provider_impl.cc
index fa4ee1380..f834261cd 100644
--- a/content/renderer/service_worker/web_service_worker_provider_impl.cc
+++ b/content/renderer/service_worker/web_service_worker_provider_impl.cc
@@ -32,7 +32,7 @@ const char kLostConnectionErrorMessage[] =
     "Lost connection to the service worker system.";
 
 template <typename T>
-static std::string MojoEnumToString(T mojo_enum) {
+static std::string MojoEnumToString2(T mojo_enum) {
   std::ostringstream oss;
   oss << mojo_enum;
   return oss.str();
@@ -232,7 +232,7 @@ void WebServiceWorkerProviderImpl::OnRegistered(
     blink::mojom::ServiceWorkerRegistrationObjectInfoPtr registration) {
   TRACE_EVENT_NESTABLE_ASYNC_END2(
       "ServiceWorker", "WebServiceWorkerProviderImpl::RegisterServiceWorker",
-      TRACE_ID_LOCAL(this), "Error", MojoEnumToString(error), "Message",
+      TRACE_ID_LOCAL(this), "Error", MojoEnumToString2(error), "Message",
       error_msg ? *error_msg : "Success");
   if (error != blink::mojom::ServiceWorkerErrorType::kNone) {
     DCHECK(error_msg);
@@ -258,7 +258,7 @@ void WebServiceWorkerProviderImpl::OnDidGetRegistration(
     blink::mojom::ServiceWorkerRegistrationObjectInfoPtr registration) {
   TRACE_EVENT_NESTABLE_ASYNC_END2(
       "ServiceWorker", "WebServiceWorkerProviderImpl::GetRegistration",
-      TRACE_ID_LOCAL(this), "Error", MojoEnumToString(error), "Message",
+      TRACE_ID_LOCAL(this), "Error", MojoEnumToString2(error), "Message",
       error_msg ? *error_msg : "Success");
   if (error != blink::mojom::ServiceWorkerErrorType::kNone) {
     DCHECK(error_msg);
@@ -288,7 +288,7 @@ void WebServiceWorkerProviderImpl::OnDidGetRegistrations(
         infos) {
   TRACE_EVENT_NESTABLE_ASYNC_END2(
       "ServiceWorker", "WebServiceWorkerProviderImpl::GetRegistrations",
-      TRACE_ID_LOCAL(this), "Error", MojoEnumToString(error), "Message",
+      TRACE_ID_LOCAL(this), "Error", MojoEnumToString2(error), "Message",
       error_msg ? *error_msg : "Success");
   if (error != blink::mojom::ServiceWorkerErrorType::kNone) {
     DCHECK(error_msg);
diff --git a/dbus/message.cc b/dbus/message.cc
index 949ee5d59..47d73816d 100644
--- a/dbus/message.cc
+++ b/dbus/message.cc
@@ -767,7 +767,7 @@ bool MessageReader::PopBool(bool* value) {
   // Like MessageWriter::AppendBool(), we should copy |value| to
   // dbus_bool_t, as dbus_message_iter_get_basic() used in PopBasic()
   // expects four bytes for DBUS_TYPE_BOOLEAN.
-  dbus_bool_t dbus_value = FALSE;
+  dbus_bool_t dbus_value = 0; //FALSE;
   const bool success = PopBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
   *value = static_cast<bool>(dbus_value);
   return success;
@@ -962,7 +962,7 @@ bool MessageReader::PopVariantOfByte(uint8_t* value) {
 
 bool MessageReader::PopVariantOfBool(bool* value) {
   // See the comment at MessageReader::PopBool().
-  dbus_bool_t dbus_value = FALSE;
+  dbus_bool_t dbus_value = 0; //FALSE;
   const bool success = PopVariantOfBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
   *value = static_cast<bool>(dbus_value);
   return success;
diff --git a/device/fido/cable/cable_discovery_data.h b/device/fido/cable/cable_discovery_data.h
index 66aa16179..8efe2e3f5 100644
--- a/device/fido/cable/cable_discovery_data.h
+++ b/device/fido/cable/cable_discovery_data.h
@@ -139,7 +139,7 @@ struct COMPONENT_EXPORT(DEVICE_FIDO) Pairing {
   // within the structure is validated by using `local_identity_seed` and
   // `handshake_hash`.
   static absl::optional<std::unique_ptr<Pairing>> Parse(
-      const cbor::Value& cbor,
+      const ::cbor::Value& cbor,
       tunnelserver::KnownDomainID domain,
       base::span<const uint8_t, kQRSeedSize> local_identity_seed,
       base::span<const uint8_t, 32> handshake_hash);
diff --git a/device/fido/public_key_credential_descriptor.h b/device/fido/public_key_credential_descriptor.h
index d6b40f93e..9ba5c7456 100644
--- a/device/fido/public_key_credential_descriptor.h
+++ b/device/fido/public_key_credential_descriptor.h
@@ -25,7 +25,7 @@ namespace device {
 class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialDescriptor {
  public:
   static absl::optional<PublicKeyCredentialDescriptor> CreateFromCBORValue(
-      const cbor::Value& cbor);
+      const ::cbor::Value& cbor);
 
   PublicKeyCredentialDescriptor();
   PublicKeyCredentialDescriptor(CredentialType credential_type,
@@ -54,7 +54,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialDescriptor {
 };
 
 COMPONENT_EXPORT(DEVICE_FIDO)
-cbor::Value AsCBOR(const PublicKeyCredentialDescriptor&);
+::cbor::Value AsCBOR(const PublicKeyCredentialDescriptor&);
 
 }  // namespace device
 
diff --git a/device/fido/public_key_credential_params.h b/device/fido/public_key_credential_params.h
index fe0c3b063..34a266efb 100644
--- a/device/fido/public_key_credential_params.h
+++ b/device/fido/public_key_credential_params.h
@@ -31,7 +31,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialParams {
   };
 
   static absl::optional<PublicKeyCredentialParams> CreateFromCBORValue(
-      const cbor::Value& cbor_value);
+      const ::cbor::Value& cbor_value);
 
   explicit PublicKeyCredentialParams(
       std::vector<CredentialInfo> credential_params);
@@ -49,7 +49,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialParams {
   std::vector<CredentialInfo> public_key_credential_params_;
 };
 
-cbor::Value AsCBOR(const PublicKeyCredentialParams&);
+::cbor::Value AsCBOR(const PublicKeyCredentialParams&);
 
 }  // namespace device
 
diff --git a/device/fido/public_key_credential_rp_entity.h b/device/fido/public_key_credential_rp_entity.h
index d59250fd1..5a3c194b0 100644
--- a/device/fido/public_key_credential_rp_entity.h
+++ b/device/fido/public_key_credential_rp_entity.h
@@ -21,7 +21,7 @@ namespace device {
 struct COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialRpEntity {
  public:
   static absl::optional<PublicKeyCredentialRpEntity> CreateFromCBORValue(
-      const cbor::Value& cbor);
+      const ::cbor::Value& cbor);
 
   PublicKeyCredentialRpEntity();
   explicit PublicKeyCredentialRpEntity(std::string id);
@@ -38,7 +38,7 @@ struct COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialRpEntity {
   absl::optional<std::string> name;
 };
 
-cbor::Value AsCBOR(const PublicKeyCredentialRpEntity&);
+::cbor::Value AsCBOR(const PublicKeyCredentialRpEntity&);
 
 }  // namespace device
 
diff --git a/device/fido/public_key_credential_user_entity.h b/device/fido/public_key_credential_user_entity.h
index 88e554744..87a3febf4 100644
--- a/device/fido/public_key_credential_user_entity.h
+++ b/device/fido/public_key_credential_user_entity.h
@@ -23,7 +23,7 @@ namespace device {
 class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialUserEntity {
  public:
   static absl::optional<PublicKeyCredentialUserEntity> CreateFromCBORValue(
-      const cbor::Value& cbor);
+      const ::cbor::Value& cbor);
 
   PublicKeyCredentialUserEntity();
   explicit PublicKeyCredentialUserEntity(std::vector<uint8_t> id);
@@ -44,7 +44,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialUserEntity {
   absl::optional<std::string> display_name;
 };
 
-cbor::Value AsCBOR(const PublicKeyCredentialUserEntity&);
+::cbor::Value AsCBOR(const PublicKeyCredentialUserEntity&);
 
 }  // namespace device
 
diff --git a/extensions/browser/api/declarative_webrequest/webrequest_condition.cc b/extensions/browser/api/declarative_webrequest/webrequest_condition.cc
index 4023f6750..36345455c 100644
--- a/extensions/browser/api/declarative_webrequest/webrequest_condition.cc
+++ b/extensions/browser/api/declarative_webrequest/webrequest_condition.cc
@@ -18,8 +18,6 @@ using url_matcher::URLMatcherConditionFactory;
 using url_matcher::URLMatcherConditionSet;
 using url_matcher::URLMatcherFactory;
 
-namespace keys = extensions::declarative_webrequest_constants;
-
 namespace {
 static base::MatcherStringPattern::ID g_next_id = 0;
 
@@ -38,7 +36,7 @@ const char kConditionCannotBeFulfilled[] = "A condition can never be "
 
 namespace extensions {
 
-namespace keys = declarative_webrequest_constants;
+namespace keys_wrc = declarative_webrequest_constants;
 
 //
 // WebRequestData
@@ -128,12 +126,12 @@ std::unique_ptr<WebRequestCondition> WebRequestCondition::Create(
 
   // Verify that we are dealing with a Condition whose type we understand.
   const std::string* instance_type =
-      condition_dict->FindString(keys::kInstanceTypeKey);
+      condition_dict->FindString(keys_wrc::kInstanceTypeKey);
   if (!instance_type) {
     *error = kConditionWithoutInstanceType;
     return nullptr;
   }
-  if (*instance_type != keys::kRequestMatcherType) {
+  if (*instance_type != keys_wrc::kRequestMatcherType) {
     *error = kExpectedOtherConditionType;
     return nullptr;
   }
@@ -144,12 +142,12 @@ std::unique_ptr<WebRequestCondition> WebRequestCondition::Create(
   for (const auto entry : *condition_dict) {
     const std::string& condition_attribute_name = entry.first;
     const base::Value& condition_attribute_value = entry.second;
-    if (condition_attribute_name == keys::kInstanceTypeKey ||
+    if (condition_attribute_name == keys_wrc::kInstanceTypeKey ||
         condition_attribute_name ==
-            keys::kDeprecatedFirstPartyForCookiesUrlKey ||
-        condition_attribute_name == keys::kDeprecatedThirdPartyKey) {
+            keys_wrc::kDeprecatedFirstPartyForCookiesUrlKey ||
+        condition_attribute_name == keys_wrc::kDeprecatedThirdPartyKey) {
       // Skip this.
-    } else if (condition_attribute_name == keys::kUrlKey) {
+    } else if (condition_attribute_name == keys_wrc::kUrlKey) {
       const base::Value::Dict* dict = condition_attribute_value.GetIfDict();
       if (!dict) {
         *error = base::StringPrintf(kInvalidTypeOfParamter,
diff --git a/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc b/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc
index 89d1208d8..5c7237de0 100644
--- a/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc
+++ b/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc
@@ -35,7 +35,7 @@ using base::CaseInsensitiveCompareASCII;
 using base::Value;
 
 namespace helpers = extension_web_request_api_helpers;
-namespace keys = extensions::declarative_webrequest_constants;
+namespace keys_wrca = extensions::declarative_webrequest_constants;
 
 namespace extensions {
 
@@ -50,31 +50,31 @@ struct WebRequestConditionAttributeFactory {
 
   WebRequestConditionAttributeFactory() : factory(5) {
     factory.RegisterFactoryMethod(
-        keys::kResourceTypeKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kResourceTypeKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeResourceType::Create);
 
     factory.RegisterFactoryMethod(
-        keys::kContentTypeKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kContentTypeKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeContentType::Create);
     factory.RegisterFactoryMethod(
-        keys::kExcludeContentTypeKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kExcludeContentTypeKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeContentType::Create);
 
     factory.RegisterFactoryMethod(
-        keys::kRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeRequestHeaders::Create);
     factory.RegisterFactoryMethod(
-        keys::kExcludeRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kExcludeRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeRequestHeaders::Create);
 
     factory.RegisterFactoryMethod(
-        keys::kResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeResponseHeaders::Create);
     factory.RegisterFactoryMethod(
-        keys::kExcludeResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kExcludeResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeResponseHeaders::Create);
 
-    factory.RegisterFactoryMethod(keys::kStagesKey, FactoryT::IS_PARAMETERIZED,
+    factory.RegisterFactoryMethod(keys_wrca::kStagesKey, FactoryT::IS_PARAMETERIZED,
                                   &WebRequestConditionAttributeStages::Create);
   }
 };
@@ -128,10 +128,10 @@ WebRequestConditionAttributeResourceType::Create(
     const base::Value* value,
     std::string* error,
     bool* bad_message) {
-  DCHECK(instance_type == keys::kResourceTypeKey);
+  DCHECK(instance_type == keys_wrca::kResourceTypeKey);
   if (!value->is_list()) {
     *error = ErrorUtils::FormatErrorMessage(kInvalidValue,
-                                            keys::kResourceTypeKey);
+                                            keys_wrca::kResourceTypeKey);
     return nullptr;
   }
   const base::Value::List& list = value->GetList();
@@ -147,7 +147,7 @@ WebRequestConditionAttributeResourceType::Create(
         !ParseWebRequestResourceType(resource_type_string,
                                      &passed_types.back())) {
       *error = ErrorUtils::FormatErrorMessage(kInvalidValue,
-                                              keys::kResourceTypeKey);
+                                              keys_wrca::kResourceTypeKey);
       return nullptr;
     }
   }
@@ -175,7 +175,7 @@ WebRequestConditionAttributeResourceType::GetType() const {
 }
 
 std::string WebRequestConditionAttributeResourceType::GetName() const {
-  return keys::kResourceTypeKey;
+  return keys_wrca::kResourceTypeKey;
 }
 
 bool WebRequestConditionAttributeResourceType::Equals(
@@ -208,7 +208,7 @@ WebRequestConditionAttributeContentType::Create(
       const base::Value* value,
       std::string* error,
       bool* bad_message) {
-  DCHECK(name == keys::kContentTypeKey || name == keys::kExcludeContentTypeKey);
+  DCHECK(name == keys_wrca::kContentTypeKey || name == keys_wrca::kExcludeContentTypeKey);
 
   if (!value->is_list()) {
     *error = ErrorUtils::FormatErrorMessage(kInvalidValue, name);
@@ -225,7 +225,7 @@ WebRequestConditionAttributeContentType::Create(
 
   return scoped_refptr<const WebRequestConditionAttribute>(
       new WebRequestConditionAttributeContentType(
-          content_types, name == keys::kContentTypeKey));
+          content_types, name == keys_wrca::kContentTypeKey));
 }
 
 int WebRequestConditionAttributeContentType::GetStages() const {
@@ -259,7 +259,7 @@ WebRequestConditionAttributeContentType::GetType() const {
 }
 
 std::string WebRequestConditionAttributeContentType::GetName() const {
-  return (inclusive_ ? keys::kContentTypeKey : keys::kExcludeContentTypeKey);
+  return (inclusive_ ? keys_wrca::kContentTypeKey : keys_wrca::kExcludeContentTypeKey);
 }
 
 bool WebRequestConditionAttributeContentType::Equals(
@@ -458,25 +458,25 @@ HeaderMatcher::HeaderMatchTest::Create(const base::Value::Dict& tests) {
   for (const auto entry : tests) {
     bool is_name = false;  // Is this test for header name?
     StringMatchTest::MatchType match_type;
-    if (entry.first == keys::kNamePrefixKey) {
+    if (entry.first == keys_wrca::kNamePrefixKey) {
       is_name = true;
       match_type = StringMatchTest::kPrefix;
-    } else if (entry.first == keys::kNameSuffixKey) {
+    } else if (entry.first == keys_wrca::kNameSuffixKey) {
       is_name = true;
       match_type = StringMatchTest::kSuffix;
-    } else if (entry.first == keys::kNameContainsKey) {
+    } else if (entry.first == keys_wrca::kNameContainsKey) {
       is_name = true;
       match_type = StringMatchTest::kContains;
-    } else if (entry.first == keys::kNameEqualsKey) {
+    } else if (entry.first == keys_wrca::kNameEqualsKey) {
       is_name = true;
       match_type = StringMatchTest::kEquals;
-    } else if (entry.first == keys::kValuePrefixKey) {
+    } else if (entry.first == keys_wrca::kValuePrefixKey) {
       match_type = StringMatchTest::kPrefix;
-    } else if (entry.first == keys::kValueSuffixKey) {
+    } else if (entry.first == keys_wrca::kValueSuffixKey) {
       match_type = StringMatchTest::kSuffix;
-    } else if (entry.first == keys::kValueContainsKey) {
+    } else if (entry.first == keys_wrca::kValueContainsKey) {
       match_type = StringMatchTest::kContains;
-    } else if (entry.first == keys::kValueEqualsKey) {
+    } else if (entry.first == keys_wrca::kValueEqualsKey) {
       match_type = StringMatchTest::kEquals;
     } else {
       NOTREACHED();  // JSON schema type checking should prevent this.
@@ -566,8 +566,8 @@ WebRequestConditionAttributeRequestHeaders::Create(
     const base::Value* value,
     std::string* error,
     bool* bad_message) {
-  DCHECK(name == keys::kRequestHeadersKey ||
-         name == keys::kExcludeRequestHeadersKey);
+  DCHECK(name == keys_wrca::kRequestHeadersKey ||
+         name == keys_wrca::kExcludeRequestHeadersKey);
 
   std::unique_ptr<const HeaderMatcher> header_matcher(
       PrepareHeaderMatcher(name, value, error));
@@ -576,7 +576,7 @@ WebRequestConditionAttributeRequestHeaders::Create(
 
   return scoped_refptr<const WebRequestConditionAttribute>(
       new WebRequestConditionAttributeRequestHeaders(
-          std::move(header_matcher), name == keys::kRequestHeadersKey));
+          std::move(header_matcher), name == keys_wrca::kRequestHeadersKey));
 }
 
 int WebRequestConditionAttributeRequestHeaders::GetStages() const {
@@ -609,8 +609,8 @@ WebRequestConditionAttributeRequestHeaders::GetType() const {
 }
 
 std::string WebRequestConditionAttributeRequestHeaders::GetName() const {
-  return (positive_ ? keys::kRequestHeadersKey
-                    : keys::kExcludeRequestHeadersKey);
+  return (positive_ ? keys_wrca::kRequestHeadersKey
+                    : keys_wrca::kExcludeRequestHeadersKey);
 }
 
 bool WebRequestConditionAttributeRequestHeaders::Equals(
@@ -639,8 +639,8 @@ WebRequestConditionAttributeResponseHeaders::Create(
     const base::Value* value,
     std::string* error,
     bool* bad_message) {
-  DCHECK(name == keys::kResponseHeadersKey ||
-         name == keys::kExcludeResponseHeadersKey);
+  DCHECK(name == keys_wrca::kResponseHeadersKey ||
+         name == keys_wrca::kExcludeResponseHeadersKey);
 
   std::unique_ptr<const HeaderMatcher> header_matcher(
       PrepareHeaderMatcher(name, value, error));
@@ -649,7 +649,7 @@ WebRequestConditionAttributeResponseHeaders::Create(
 
   return scoped_refptr<const WebRequestConditionAttribute>(
       new WebRequestConditionAttributeResponseHeaders(
-          std::move(header_matcher), name == keys::kResponseHeadersKey));
+          std::move(header_matcher), name == keys_wrca::kResponseHeadersKey));
 }
 
 int WebRequestConditionAttributeResponseHeaders::GetStages() const {
@@ -689,8 +689,8 @@ WebRequestConditionAttributeResponseHeaders::GetType() const {
 }
 
 std::string WebRequestConditionAttributeResponseHeaders::GetName() const {
-  return (positive_ ? keys::kResponseHeadersKey
-                    : keys::kExcludeResponseHeadersKey);
+  return (positive_ ? keys_wrca::kResponseHeadersKey
+                    : keys_wrca::kExcludeResponseHeadersKey);
 }
 
 bool WebRequestConditionAttributeResponseHeaders::Equals(
@@ -723,13 +723,13 @@ bool ParseListOfStages(const base::Value& value, int* out_stages) {
     if (!entry.is_string())
       return false;
     const std::string& stage_name = entry.GetString();
-    if (stage_name == keys::kOnBeforeRequestEnum) {
+    if (stage_name == keys_wrca::kOnBeforeRequestEnum) {
       stages |= ON_BEFORE_REQUEST;
-    } else if (stage_name == keys::kOnBeforeSendHeadersEnum) {
+    } else if (stage_name == keys_wrca::kOnBeforeSendHeadersEnum) {
       stages |= ON_BEFORE_SEND_HEADERS;
-    } else if (stage_name == keys::kOnHeadersReceivedEnum) {
+    } else if (stage_name == keys_wrca::kOnHeadersReceivedEnum) {
       stages |= ON_HEADERS_RECEIVED;
-    } else if (stage_name == keys::kOnAuthRequiredEnum) {
+    } else if (stage_name == keys_wrca::kOnAuthRequiredEnum) {
       stages |= ON_AUTH_REQUIRED;
     } else {
       NOTREACHED();  // JSON schema checks prevent getting here.
@@ -749,12 +749,12 @@ WebRequestConditionAttributeStages::Create(const std::string& name,
                                            const base::Value* value,
                                            std::string* error,
                                            bool* bad_message) {
-  DCHECK(name == keys::kStagesKey);
+  DCHECK(name == keys_wrca::kStagesKey);
 
   int allowed_stages = 0;
   if (!ParseListOfStages(*value, &allowed_stages)) {
     *error = ErrorUtils::FormatErrorMessage(kInvalidValue,
-                                                     keys::kStagesKey);
+                                                     keys_wrca::kStagesKey);
     return nullptr;
   }
 
@@ -778,7 +778,7 @@ WebRequestConditionAttributeStages::GetType() const {
 }
 
 std::string WebRequestConditionAttributeStages::GetName() const {
-  return keys::kStagesKey;
+  return keys_wrca::kStagesKey;
 }
 
 bool WebRequestConditionAttributeStages::Equals(
diff --git a/extensions/browser/api/hid/hid_connection_resource.cc b/extensions/browser/api/hid/hid_connection_resource.cc
index 3105a0d20..337747d59 100644
--- a/extensions/browser/api/hid/hid_connection_resource.cc
+++ b/extensions/browser/api/hid/hid_connection_resource.cc
@@ -13,14 +13,14 @@
 namespace extensions {
 
 static base::LazyInstance<BrowserContextKeyedAPIFactory<
-    ApiResourceManager<HidConnectionResource>>>::DestructorAtExit g_factory =
+    ApiResourceManager<HidConnectionResource>>>::DestructorAtExit g_factoryHCR =
     LAZY_INSTANCE_INITIALIZER;
 
 // static
 template <>
 BrowserContextKeyedAPIFactory<ApiResourceManager<HidConnectionResource> >*
 ApiResourceManager<HidConnectionResource>::GetFactoryInstance() {
-  return &g_factory.Get();
+  return &g_factoryHCR.Get();
 }
 
 HidConnectionResource::HidConnectionResource(
diff --git a/extensions/browser/api/hid/hid_device_manager.cc b/extensions/browser/api/hid/hid_device_manager.cc
index 7c189966f..633879bdf 100644
--- a/extensions/browser/api/hid/hid_device_manager.cc
+++ b/extensions/browser/api/hid/hid_device_manager.cc
@@ -89,7 +89,7 @@ bool WillDispatchDeviceEvent(
   return false;
 }
 
-HidDeviceManager::HidManagerBinder& GetHidManagerBinderOverride() {
+HidDeviceManager::HidManagerBinder& GetHidDeviceManagerBinderOverride() {
   static base::NoDestructor<HidDeviceManager::HidManagerBinder> binder;
   return *binder;
 }
@@ -293,7 +293,7 @@ void HidDeviceManager::LazyInitialize() {
 
     DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
     auto receiver = hid_manager_.BindNewPipeAndPassReceiver();
-    const auto& binder = GetHidManagerBinderOverride();
+    const auto& binder = GetHidDeviceManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
     else
@@ -314,7 +314,7 @@ void HidDeviceManager::LazyInitialize() {
 // static
 void HidDeviceManager::OverrideHidManagerBinderForTesting(
     HidManagerBinder binder) {
-  GetHidManagerBinderOverride() = std::move(binder);
+  GetHidDeviceManagerBinderOverride() = std::move(binder);
 }
 
 base::Value::List HidDeviceManager::CreateApiDeviceList(
diff --git a/extensions/browser/api/usb/usb_device_manager.cc b/extensions/browser/api/usb/usb_device_manager.cc
index 46bdeb624..3153f20c3 100644
--- a/extensions/browser/api/usb/usb_device_manager.cc
+++ b/extensions/browser/api/usb/usb_device_manager.cc
@@ -68,7 +68,7 @@ bool ShouldExposeDevice(const device::mojom::UsbDeviceInfo& device_info) {
 
 // Returns true if the given extension has permission to receive events
 // regarding this device.
-bool WillDispatchDeviceEvent(
+bool MyWillDispatchDeviceEvent(
     const device::mojom::UsbDeviceInfo& device_info,
     content::BrowserContext* browser_context,
     Feature::Context target_context,
@@ -390,7 +390,7 @@ void UsbDeviceManager::DispatchEvent(
     }
 
     event->will_dispatch_callback =
-        base::BindRepeating(&WillDispatchDeviceEvent, std::cref(device_info));
+        base::BindRepeating(&MyWillDispatchDeviceEvent, std::cref(device_info));
     event_router->BroadcastEvent(std::move(event));
   }
 }
diff --git a/extensions/browser/api/usb/usb_device_resource.cc b/extensions/browser/api/usb/usb_device_resource.cc
index 78116ed87..b720bd492 100644
--- a/extensions/browser/api/usb/usb_device_resource.cc
+++ b/extensions/browser/api/usb/usb_device_resource.cc
@@ -21,14 +21,14 @@ using content::BrowserThread;
 namespace extensions {
 
 static base::LazyInstance<BrowserContextKeyedAPIFactory<
-    ApiResourceManager<UsbDeviceResource>>>::DestructorAtExit g_factory =
+    ApiResourceManager<UsbDeviceResource>>>::DestructorAtExit g_factory2 =
     LAZY_INSTANCE_INITIALIZER;
 
 // static
 template <>
 BrowserContextKeyedAPIFactory<ApiResourceManager<UsbDeviceResource> >*
 ApiResourceManager<UsbDeviceResource>::GetFactoryInstance() {
-  return g_factory.Pointer();
+  return g_factory2.Pointer();
 }
 
 UsbDeviceResource::UsbDeviceResource(
diff --git a/extensions/browser/api/web_request/upload_data_presenter.cc b/extensions/browser/api/web_request/upload_data_presenter.cc
index 7ace7a2a2..c48eb8184 100644
--- a/extensions/browser/api/web_request/upload_data_presenter.cc
+++ b/extensions/browser/api/web_request/upload_data_presenter.cc
@@ -15,7 +15,7 @@
 #include "extensions/browser/api/web_request/web_request_api_constants.h"
 #include "net/base/upload_file_element_reader.h"
 
-namespace keys = extension_web_request_api_constants;
+namespace keys_udp = extension_web_request_api_constants;
 
 namespace {
 
@@ -69,13 +69,13 @@ absl::optional<base::Value> RawDataPresenter::TakeResult() {
 
 void RawDataPresenter::FeedNextBytes(const char* bytes, size_t size) {
   subtle::AppendKeyValuePair(
-      keys::kRequestBodyRawBytesKey,
+      keys_udp::kRequestBodyRawBytesKey,
       base::Value(base::as_bytes(base::make_span(bytes, size))), list_);
 }
 
 void RawDataPresenter::FeedNextFile(const std::string& filename) {
   // Insert the file path instead of the contents, which may be too large.
-  subtle::AppendKeyValuePair(keys::kRequestBodyRawFileKey,
+  subtle::AppendKeyValuePair(keys_udp::kRequestBodyRawFileKey,
                              base::Value(filename), list_);
 }
 
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index 21ba17ede..72af15032 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -102,7 +102,7 @@ using extensions::mojom::APIPermissionID;
 
 namespace activity_log = activity_log_web_request_constants;
 namespace helpers = extension_web_request_api_helpers;
-namespace keys = extension_web_request_api_constants;
+namespace keys_wra = extension_web_request_api_constants;
 using URLLoaderFactoryType =
     content::ContentBrowserClient::URLLoaderFactoryType;
 using DNRRequestAction = extensions::declarative_net_request::RequestAction;
@@ -144,15 +144,15 @@ const char kWebRequestEventPrefix[] = "webRequest.";
 // handled as a normal event (as opposed to a WebRequestEvent at the bindings
 // layer).
 const char* const kWebRequestEvents[] = {
-    keys::kOnBeforeRedirectEvent,
+    keys_wra::kOnBeforeRedirectEvent,
     web_request::OnBeforeRequest::kEventName,
-    keys::kOnBeforeSendHeadersEvent,
-    keys::kOnCompletedEvent,
+    keys_wra::kOnBeforeSendHeadersEvent,
+    keys_wra::kOnCompletedEvent,
     web_request::OnErrorOccurred::kEventName,
-    keys::kOnSendHeadersEvent,
-    keys::kOnAuthRequiredEvent,
-    keys::kOnResponseStartedEvent,
-    keys::kOnHeadersReceivedEvent,
+    keys_wra::kOnSendHeadersEvent,
+    keys_wra::kOnAuthRequiredEvent,
+    keys_wra::kOnResponseStartedEvent,
+    keys_wra::kOnHeadersReceivedEvent,
 };
 
 const char* GetRequestStageAsString(
@@ -161,23 +161,23 @@ const char* GetRequestStageAsString(
     case ExtensionWebRequestEventRouter::kInvalidEvent:
       return "Invalid";
     case ExtensionWebRequestEventRouter::kOnBeforeRequest:
-      return keys::kOnBeforeRequest;
+      return keys_wra::kOnBeforeRequest;
     case ExtensionWebRequestEventRouter::kOnBeforeSendHeaders:
-      return keys::kOnBeforeSendHeaders;
+      return keys_wra::kOnBeforeSendHeaders;
     case ExtensionWebRequestEventRouter::kOnSendHeaders:
-      return keys::kOnSendHeaders;
+      return keys_wra::kOnSendHeaders;
     case ExtensionWebRequestEventRouter::kOnHeadersReceived:
-      return keys::kOnHeadersReceived;
+      return keys_wra::kOnHeadersReceived;
     case ExtensionWebRequestEventRouter::kOnBeforeRedirect:
-      return keys::kOnBeforeRedirect;
+      return keys_wra::kOnBeforeRedirect;
     case ExtensionWebRequestEventRouter::kOnAuthRequired:
-      return keys::kOnAuthRequired;
+      return keys_wra::kOnAuthRequired;
     case ExtensionWebRequestEventRouter::kOnResponseStarted:
-      return keys::kOnResponseStarted;
+      return keys_wra::kOnResponseStarted;
     case ExtensionWebRequestEventRouter::kOnErrorOccurred:
-      return keys::kOnErrorOccurred;
+      return keys_wra::kOnErrorOccurred;
     case ExtensionWebRequestEventRouter::kOnCompleted:
-      return keys::kOnCompleted;
+      return keys_wra::kOnCompleted;
   }
   NOTREACHED();
   return "Not reached";
@@ -197,23 +197,23 @@ ExtensionWebRequestEventRouter::EventTypes GetEventTypeFromEventName(
   static base::NoDestructor<const base::flat_map<
       base::StringPiece, ExtensionWebRequestEventRouter::EventTypes>>
       kRequestStageMap(
-          {{keys::kOnBeforeRequest,
+          {{keys_wra::kOnBeforeRequest,
             ExtensionWebRequestEventRouter::kOnBeforeRequest},
-           {keys::kOnBeforeSendHeaders,
+           {keys_wra::kOnBeforeSendHeaders,
             ExtensionWebRequestEventRouter::kOnBeforeSendHeaders},
-           {keys::kOnSendHeaders,
+           {keys_wra::kOnSendHeaders,
             ExtensionWebRequestEventRouter::kOnSendHeaders},
-           {keys::kOnHeadersReceived,
+           {keys_wra::kOnHeadersReceived,
             ExtensionWebRequestEventRouter::kOnHeadersReceived},
-           {keys::kOnBeforeRedirect,
+           {keys_wra::kOnBeforeRedirect,
             ExtensionWebRequestEventRouter::kOnBeforeRedirect},
-           {keys::kOnAuthRequired,
+           {keys_wra::kOnAuthRequired,
             ExtensionWebRequestEventRouter::kOnAuthRequired},
-           {keys::kOnResponseStarted,
+           {keys_wra::kOnResponseStarted,
             ExtensionWebRequestEventRouter::kOnResponseStarted},
-           {keys::kOnErrorOccurred,
+           {keys_wra::kOnErrorOccurred,
             ExtensionWebRequestEventRouter::kOnErrorOccurred},
-           {keys::kOnCompleted, ExtensionWebRequestEventRouter::kOnCompleted}});
+           {keys_wra::kOnCompleted, ExtensionWebRequestEventRouter::kOnCompleted}});
 
   DCHECK_EQ(kRequestStageMap->size(), std::size(kWebRequestEvents));
 
@@ -271,15 +271,15 @@ bool IsRequestFromExtension(const WebRequestInfo& request,
 bool FromHeaderDictionary(const base::Value::Dict& header_value,
                           std::string* name,
                           std::string* out_value) {
-  const std::string* name_ptr = header_value.FindString(keys::kHeaderNameKey);
+  const std::string* name_ptr = header_value.FindString(keys_wra::kHeaderNameKey);
   if (!name)
     return false;
   *name = *name_ptr;
 
   // We require either a "value" or a "binaryValue" entry.
-  const base::Value* value = header_value.Find(keys::kHeaderValueKey);
+  const base::Value* value = header_value.Find(keys_wra::kHeaderValueKey);
   const base::Value* binary_value =
-      header_value.Find(keys::kHeaderBinaryValueKey);
+      header_value.Find(keys_wra::kHeaderBinaryValueKey);
   if (!((value != nullptr) ^ (binary_value != nullptr))) {
     return false;
   }
@@ -380,18 +380,18 @@ events::HistogramValue GetEventHistogramValue(const std::string& event_name) {
     events::HistogramValue histogram_value;
     const char* const event_name;
   } values_and_names[] = {
-      {events::WEB_REQUEST_ON_BEFORE_REDIRECT, keys::kOnBeforeRedirectEvent},
+      {events::WEB_REQUEST_ON_BEFORE_REDIRECT, keys_wra::kOnBeforeRedirectEvent},
       {events::WEB_REQUEST_ON_BEFORE_REQUEST,
        web_request::OnBeforeRequest::kEventName},
       {events::WEB_REQUEST_ON_BEFORE_SEND_HEADERS,
-       keys::kOnBeforeSendHeadersEvent},
-      {events::WEB_REQUEST_ON_COMPLETED, keys::kOnCompletedEvent},
+       keys_wra::kOnBeforeSendHeadersEvent},
+      {events::WEB_REQUEST_ON_COMPLETED, keys_wra::kOnCompletedEvent},
       {events::WEB_REQUEST_ON_ERROR_OCCURRED,
        web_request::OnErrorOccurred::kEventName},
-      {events::WEB_REQUEST_ON_SEND_HEADERS, keys::kOnSendHeadersEvent},
-      {events::WEB_REQUEST_ON_AUTH_REQUIRED, keys::kOnAuthRequiredEvent},
-      {events::WEB_REQUEST_ON_RESPONSE_STARTED, keys::kOnResponseStartedEvent},
-      {events::WEB_REQUEST_ON_HEADERS_RECEIVED, keys::kOnHeadersReceivedEvent}};
+      {events::WEB_REQUEST_ON_SEND_HEADERS, keys_wra::kOnSendHeadersEvent},
+      {events::WEB_REQUEST_ON_AUTH_REQUIRED, keys_wra::kOnAuthRequiredEvent},
+      {events::WEB_REQUEST_ON_RESPONSE_STARTED, keys_wra::kOnResponseStartedEvent},
+      {events::WEB_REQUEST_ON_HEADERS_RECEIVED, keys_wra::kOnHeadersReceivedEvent}};
   static_assert(std::size(kWebRequestEvents) == std::size(values_and_names),
                 "kWebRequestEvents and values_and_names must be the same");
   for (const ValueAndName& value_and_name : values_and_names) {
@@ -651,13 +651,13 @@ void WebRequestAPI::Shutdown() {
 }
 
 static base::LazyInstance<
-    BrowserContextKeyedAPIFactory<WebRequestAPI>>::DestructorAtExit g_factory =
+    BrowserContextKeyedAPIFactory<WebRequestAPI>>::DestructorAtExit g_factory_wra =
     LAZY_INSTANCE_INITIALIZER;
 
 // static
 BrowserContextKeyedAPIFactory<WebRequestAPI>*
 WebRequestAPI::GetFactoryInstance() {
-  return g_factory.Pointer();
+  return g_factory_wra.Pointer();
 }
 
 void WebRequestAPI::OnListenerRemoved(const EventListenerInfo& details) {
@@ -1030,7 +1030,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         if (url.empty() ||
             pattern.Parse(url) != URLPattern::ParseResult::kSuccess) {
           *error = ErrorUtils::FormatErrorMessage(
-              keys::kInvalidRequestFilterUrl, url);
+              keys_wra::kInvalidRequestFilterUrl, url);
           return false;
         }
         urls.AddPattern(pattern);
@@ -1285,7 +1285,7 @@ int ExtensionWebRequestEventRouter::OnBeforeSendHeaders(
   bool initialize_blocked_requests = false;
 
   initialize_blocked_requests |=
-      ProcessDeclarativeRules(browser_context, keys::kOnBeforeSendHeadersEvent,
+      ProcessDeclarativeRules(browser_context, keys_wra::kOnBeforeSendHeadersEvent,
                               request, ON_BEFORE_SEND_HEADERS, nullptr);
 
   DCHECK(request->dnr_actions);
@@ -1297,7 +1297,7 @@ int ExtensionWebRequestEventRouter::OnBeforeSendHeaders(
 
   int extra_info_spec = 0;
   RawListeners listeners =
-      GetMatchingListeners(browser_context, keys::kOnBeforeSendHeadersEvent,
+      GetMatchingListeners(browser_context, keys_wra::kOnBeforeSendHeadersEvent,
                            request, &extra_info_spec);
   if (!listeners.empty() &&
       !GetAndSetSignaled(request->id, kOnBeforeSendHeaders)) {
@@ -1341,7 +1341,7 @@ void ExtensionWebRequestEventRouter::OnSendHeaders(
 
   int extra_info_spec = 0;
   RawListeners listeners = GetMatchingListeners(
-      browser_context, keys::kOnSendHeadersEvent, request, &extra_info_spec);
+      browser_context, keys_wra::kOnSendHeadersEvent, request, &extra_info_spec);
   if (listeners.empty())
     return;
 
@@ -1372,12 +1372,12 @@ int ExtensionWebRequestEventRouter::OnHeadersReceived(
       });
 
   initialize_blocked_requests |= ProcessDeclarativeRules(
-      browser_context, keys::kOnHeadersReceivedEvent, request,
+      browser_context, keys_wra::kOnHeadersReceivedEvent, request,
       ON_HEADERS_RECEIVED, original_response_headers);
 
   int extra_info_spec = 0;
   RawListeners listeners =
-      GetMatchingListeners(browser_context, keys::kOnHeadersReceivedEvent,
+      GetMatchingListeners(browser_context, keys_wra::kOnHeadersReceivedEvent,
                            request, &extra_info_spec);
 
   if (!listeners.empty() &&
@@ -1427,7 +1427,7 @@ ExtensionWebRequestEventRouter::OnAuthRequired(
 
   int extra_info_spec = 0;
   RawListeners listeners = GetMatchingListeners(
-      browser_context, keys::kOnAuthRequiredEvent, request, &extra_info_spec);
+      browser_context, keys_wra::kOnAuthRequiredEvent, request, &extra_info_spec);
   if (listeners.empty())
     return AuthRequiredResponse::AUTH_REQUIRED_RESPONSE_NO_ACTION;
 
@@ -1466,7 +1466,7 @@ void ExtensionWebRequestEventRouter::OnBeforeRedirect(
 
   int extra_info_spec = 0;
   RawListeners listeners = GetMatchingListeners(
-      browser_context, keys::kOnBeforeRedirectEvent, request, &extra_info_spec);
+      browser_context, keys_wra::kOnBeforeRedirectEvent, request, &extra_info_spec);
   if (listeners.empty())
     return;
 
@@ -1474,7 +1474,7 @@ void ExtensionWebRequestEventRouter::OnBeforeRedirect(
       CreateEventDetails(*request, extra_info_spec));
   event_details->SetResponseHeaders(*request, request->response_headers.get());
   event_details->SetResponseSource(*request);
-  event_details->SetString(keys::kRedirectUrlKey, new_location.spec());
+  event_details->SetString(keys_wra::kRedirectUrlKey, new_location.spec());
 
   DispatchEvent(browser_context, request, listeners, std::move(event_details));
 }
@@ -1494,7 +1494,7 @@ void ExtensionWebRequestEventRouter::OnResponseStarted(
 
   int extra_info_spec = 0;
   RawListeners listeners =
-      GetMatchingListeners(browser_context, keys::kOnResponseStartedEvent,
+      GetMatchingListeners(browser_context, keys_wra::kOnResponseStartedEvent,
                            request, &extra_info_spec);
   if (listeners.empty())
     return;
@@ -1533,7 +1533,7 @@ void ExtensionWebRequestEventRouter::OnCompleted(
 
   int extra_info_spec = 0;
   RawListeners listeners = GetMatchingListeners(
-      browser_context, keys::kOnCompletedEvent, request, &extra_info_spec);
+      browser_context, keys_wra::kOnCompletedEvent, request, &extra_info_spec);
   if (listeners.empty())
     return;
 
@@ -1595,8 +1595,8 @@ void ExtensionWebRequestEventRouter::OnErrorOccurred(
   if (started)
     event_details->SetResponseSource(*request);
   else
-    event_details->SetBoolean(keys::kFromCache, request->response_from_cache);
-  event_details->SetString(keys::kErrorKey, net::ErrorToString(net_error));
+    event_details->SetBoolean(keys_wra::kFromCache, request->response_from_cache);
+  event_details->SetString(keys_wra::kErrorKey, net::ErrorToString(net_error));
 
   DispatchEvent(browser_context, request, listeners, std::move(event_details));
 }
@@ -2557,8 +2557,8 @@ void ExtensionWebRequestEventRouter::SendMessages(
     for (const std::string& message : messages) {
       std::unique_ptr<WebRequestEventDetails> event_details(CreateEventDetails(
           *blocked_request.request, /* extra_info_spec */ 0));
-      event_details->SetString(keys::kMessageKey, message);
-      event_details->SetString(keys::kStageKey,
+      event_details->SetString(keys_wra::kMessageKey, message);
+      event_details->SetString(keys_wra::kStageKey,
                                GetRequestStageAsString(blocked_request.event));
       SendOnMessageEventOnUI(browser_context, delta.extension_id,
                              blocked_request.request->is_web_view,
@@ -2936,7 +2936,7 @@ WebRequestInternalAddEventListenerFunction::Run() {
         return true;
       }
 
-      return event_name == keys::kOnAuthRequiredEvent &&
+      return event_name == keys_wra::kOnAuthRequiredEvent &&
              extension->permissions_data()->HasAPIPermission(
                  APIPermissionID::kWebRequestAuthProvider);
     };
@@ -2947,7 +2947,7 @@ WebRequestInternalAddEventListenerFunction::Run() {
     bool is_blocking = extra_info_spec & (ExtraInfoSpec::BLOCKING |
                                           ExtraInfoSpec::ASYNC_BLOCKING);
     if (is_blocking && !has_blocking_permission()) {
-      return RespondNow(Error(keys::kBlockingPermissionRequired));
+      return RespondNow(Error(keys_wra::kBlockingPermissionRequired));
     }
 
     // We allow to subscribe to patterns that are broader than the host
@@ -2963,7 +2963,7 @@ WebRequestInternalAddEventListenerFunction::Run() {
             ->withheld_permissions()
             .explicit_hosts()
             .is_empty()) {
-      return RespondNow(Error(keys::kHostPermissionsRequired));
+      return RespondNow(Error(keys_wra::kHostPermissionsRequired));
     }
   }
 
@@ -3031,7 +3031,7 @@ WebRequestInternalEventHandledFunction::Run() {
 
     const base::Value* redirect_url_value = dict_value.Find("redirectUrl");
     const base::Value* auth_credentials_value =
-        dict_value.Find(keys::kAuthCredentialsKey);
+        dict_value.Find(keys_wra::kAuthCredentialsKey);
     const base::Value* request_headers_value =
         dict_value.Find("requestHeaders");
     const base::Value* response_headers_value =
@@ -3043,7 +3043,7 @@ WebRequestInternalEventHandledFunction::Run() {
       if (dict_value.size() != 1) {
         OnError(event_name, sub_event_name, request_id, render_process_id,
                 web_view_instance_id, std::move(response));
-        return RespondNow(Error(keys::kInvalidBlockingResponse));
+        return RespondNow(Error(keys_wra::kInvalidBlockingResponse));
       }
 
       EXTENSION_FUNCTION_VALIDATE(cancel_value->is_bool());
@@ -3057,7 +3057,7 @@ WebRequestInternalEventHandledFunction::Run() {
       if (!response->new_url.is_valid()) {
         OnError(event_name, sub_event_name, request_id, render_process_id,
                 web_view_instance_id, std::move(response));
-        return RespondNow(Error(keys::kInvalidRedirectUrl, new_url_str));
+        return RespondNow(Error(keys_wra::kInvalidRedirectUrl, new_url_str));
       }
     }
 
@@ -3068,7 +3068,7 @@ WebRequestInternalEventHandledFunction::Run() {
         // Allow only one of the keys, not both.
         OnError(event_name, sub_event_name, request_id, render_process_id,
                 web_view_instance_id, std::move(response));
-        return RespondNow(Error(keys::kInvalidHeaderKeyCombination));
+        return RespondNow(Error(keys_wra::kInvalidHeaderKeyCombination));
       }
 
       const base::Value::List* headers_value = nullptr;
@@ -3076,10 +3076,10 @@ WebRequestInternalEventHandledFunction::Run() {
       std::unique_ptr<helpers::ResponseHeaders> response_headers;
       if (has_request_headers) {
         request_headers = std::make_unique<net::HttpRequestHeaders>();
-        headers_value = dict_value.FindList(keys::kRequestHeadersKey);
+        headers_value = dict_value.FindList(keys_wra::kRequestHeadersKey);
       } else {
         response_headers = std::make_unique<helpers::ResponseHeaders>();
-        headers_value = dict_value.FindList(keys::kResponseHeadersKey);
+        headers_value = dict_value.FindList(keys_wra::kResponseHeadersKey);
       }
       EXTENSION_FUNCTION_VALIDATE(headers_value);
 
@@ -3093,17 +3093,17 @@ WebRequestInternalEventHandledFunction::Run() {
           base::JSONWriter::Write(header_value, &serialized_header);
           OnError(event_name, sub_event_name, request_id, render_process_id,
                   web_view_instance_id, std::move(response));
-          return RespondNow(Error(keys::kInvalidHeader, serialized_header));
+          return RespondNow(Error(keys_wra::kInvalidHeader, serialized_header));
         }
         if (!net::HttpUtil::IsValidHeaderName(name)) {
           OnError(event_name, sub_event_name, request_id, render_process_id,
                   web_view_instance_id, std::move(response));
-          return RespondNow(Error(keys::kInvalidHeaderName));
+          return RespondNow(Error(keys_wra::kInvalidHeaderName));
         }
         if (!net::HttpUtil::IsValidHeaderValue(value)) {
           OnError(event_name, sub_event_name, request_id, render_process_id,
                   web_view_instance_id, std::move(response));
-          return RespondNow(Error(keys::kInvalidHeaderValue, name));
+          return RespondNow(Error(keys_wra::kInvalidHeaderValue, name));
         }
         if (has_request_headers) {
           request_headers->SetHeader(name, value);
@@ -3123,9 +3123,9 @@ WebRequestInternalEventHandledFunction::Run() {
           auth_credentials_value->GetIfDict();
       EXTENSION_FUNCTION_VALIDATE(credentials_value);
       const std::string* username =
-          credentials_value->FindString(keys::kUsernameKey);
+          credentials_value->FindString(keys_wra::kUsernameKey);
       const std::string* password =
-          credentials_value->FindString(keys::kPasswordKey);
+          credentials_value->FindString(keys_wra::kPasswordKey);
       EXTENSION_FUNCTION_VALIDATE(username);
       EXTENSION_FUNCTION_VALIDATE(password);
       response->auth_credentials = net::AuthCredentials(
diff --git a/extensions/browser/api/web_request/web_request_info.cc b/extensions/browser/api/web_request/web_request_info.cc
index 7863345bc..9eb1c999e 100644
--- a/extensions/browser/api/web_request/web_request_info.cc
+++ b/extensions/browser/api/web_request/web_request_info.cc
@@ -29,7 +29,7 @@
 #include "services/network/url_loader.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
-namespace keys = extension_web_request_api_constants;
+namespace keys_wri = extension_web_request_api_constants;
 
 namespace extensions {
 
@@ -129,8 +129,8 @@ absl::optional<base::Value::Dict> CreateRequestBodyData(
       &raw_data_presenter      // 2: any data at all? (Non-specific.)
   };
   // Keys for the results of the corresponding presenters.
-  static const char* const kKeys[] = {keys::kRequestBodyFormDataKey,
-                                      keys::kRequestBodyRawKey};
+  static const char* const kKeys[] = {keys_wri::kRequestBodyFormDataKey,
+                                      keys_wri::kRequestBodyRawKey};
   bool some_succeeded = false;
   if (!data_sources.empty()) {
     for (size_t i = 0; i < std::size(presenters); ++i) {
@@ -145,7 +145,7 @@ absl::optional<base::Value::Dict> CreateRequestBodyData(
   }
 
   if (!some_succeeded) {
-    request_body_data.Set(keys::kRequestBodyErrorKey, "Unknown error.");
+    request_body_data.Set(keys_wri::kRequestBodyErrorKey, "Unknown error.");
   }
 
   return request_body_data;
diff --git a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc
index 09437c18a..987128531 100644
--- a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc
+++ b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc
@@ -78,26 +78,26 @@ constexpr char kWebRequestProxyingURLLoaderFactoryScope[] =
 // This shutdown notifier makes sure the proxy is destroyed if an incognito
 // browser context is destroyed. This is needed because WebRequestAPI only
 // clears the proxies when the original browser context is destroyed.
-class ShutdownNotifierFactory
+class ShutdownNotifierFactory2
     : public BrowserContextKeyedServiceShutdownNotifierFactory {
  public:
-  ShutdownNotifierFactory(const ShutdownNotifierFactory&) = delete;
-  ShutdownNotifierFactory& operator=(const ShutdownNotifierFactory&) = delete;
+  ShutdownNotifierFactory2(const ShutdownNotifierFactory2&) = delete;
+  ShutdownNotifierFactory2& operator=(const ShutdownNotifierFactory2&) = delete;
 
-  static ShutdownNotifierFactory* GetInstance() {
-    static base::NoDestructor<ShutdownNotifierFactory> factory;
+  static ShutdownNotifierFactory2* GetInstance() {
+    static base::NoDestructor<ShutdownNotifierFactory2> factory;
     return factory.get();
   }
 
  private:
-  friend class base::NoDestructor<ShutdownNotifierFactory>;
+  friend class base::NoDestructor<ShutdownNotifierFactory2>;
 
-  ShutdownNotifierFactory()
+  ShutdownNotifierFactory2()
       : BrowserContextKeyedServiceShutdownNotifierFactory(
             "WebRequestProxyingURLLoaderFactory") {
     DependsOn(PermissionHelper::GetFactoryInstance());
   }
-  ~ShutdownNotifierFactory() override {}
+  ~ShutdownNotifierFactory2() override {}
 };
 
 // Creates simulated net::RedirectInfo when an extension redirects a request,
@@ -1443,7 +1443,7 @@ WebRequestProxyingURLLoaderFactory::WebRequestProxyingURLLoaderFactory(
   // canceled when |shutdown_notifier_subscription_| is destroyed, and
   // |proxies_| owns this.
   shutdown_notifier_subscription_ =
-      ShutdownNotifierFactory::GetInstance()
+      ShutdownNotifierFactory2::GetInstance()
           ->Get(browser_context)
           ->Subscribe(base::BindRepeating(&WebRequestAPI::ProxySet::RemoveProxy,
                                           base::Unretained(proxies_), this));
diff --git a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h
index 11c58337e..c53676bab 100644
--- a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h
+++ b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h
@@ -39,7 +39,7 @@
 #include "url/gurl.h"
 #include "url/origin.h"
 
-namespace {
+namespace content {
 class BrowserContext;
 }
 
diff --git a/extensions/browser/app_window/app_window.cc b/extensions/browser/app_window/app_window.cc
index 7546c00df..a1328f641 100644
--- a/extensions/browser/app_window/app_window.cc
+++ b/extensions/browser/app_window/app_window.cc
@@ -235,7 +235,7 @@ gfx::Size AppWindow::CreateParams::GetWindowMaximumSize(
 
 // AppWindow
 
-AppWindow::AppWindow(BrowserContext* context,
+AppWindow::AppWindow(content::BrowserContext* context,
                      std::unique_ptr<AppDelegate> app_delegate,
                      const Extension* extension)
     : browser_context_(context),
@@ -954,7 +954,7 @@ content::WebContents* AppWindow::GetAssociatedWebContents() const {
   return web_contents();
 }
 
-void AppWindow::OnExtensionUnloaded(BrowserContext* browser_context,
+void AppWindow::OnExtensionUnloaded(content::BrowserContext* browser_context,
                                     const Extension* extension,
                                     UnloadedExtensionReason reason) {
   if (extension_id_ == extension->id())
diff --git a/extensions/browser/extension_message_filter.cc b/extensions/browser/extension_message_filter.cc
index 9e24cefb4..d08c9f4d6 100644
--- a/extensions/browser/extension_message_filter.cc
+++ b/extensions/browser/extension_message_filter.cc
@@ -18,25 +18,25 @@ namespace extensions {
 
 namespace {
 
-class ShutdownNotifierFactory
+class ShutdownNotifierFactoryForExtensionMessageFilter
     : public BrowserContextKeyedServiceShutdownNotifierFactory {
  public:
-  ShutdownNotifierFactory(const ShutdownNotifierFactory&) = delete;
-  ShutdownNotifierFactory& operator=(const ShutdownNotifierFactory&) = delete;
+  ShutdownNotifierFactoryForExtensionMessageFilter(const ShutdownNotifierFactoryForExtensionMessageFilter&) = delete;
+  ShutdownNotifierFactoryForExtensionMessageFilter& operator=(const ShutdownNotifierFactoryForExtensionMessageFilter&) = delete;
 
-  static ShutdownNotifierFactory* GetInstance() {
-    return base::Singleton<ShutdownNotifierFactory>::get();
+  static ShutdownNotifierFactoryForExtensionMessageFilter* GetInstance() {
+    return base::Singleton<ShutdownNotifierFactoryForExtensionMessageFilter>::get();
   }
 
  private:
-  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactory>;
+  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactoryForExtensionMessageFilter>;
 
-  ShutdownNotifierFactory()
+  ShutdownNotifierFactoryForExtensionMessageFilter()
       : BrowserContextKeyedServiceShutdownNotifierFactory(
             "ExtensionMessageFilter") {
     DependsOn(ProcessManagerFactory::GetInstance());
   }
-  ~ShutdownNotifierFactory() override {}
+  ~ShutdownNotifierFactoryForExtensionMessageFilter() override {}
 };
 
 }  // namespace
@@ -48,13 +48,13 @@ ExtensionMessageFilter::ExtensionMessageFilter(int render_process_id,
       browser_context_(context) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   shutdown_notifier_subscription_ =
-      ShutdownNotifierFactory::GetInstance()->Get(context)->Subscribe(
+      ShutdownNotifierFactoryForExtensionMessageFilter::GetInstance()->Get(context)->Subscribe(
           base::BindRepeating(&ExtensionMessageFilter::ShutdownOnUIThread,
                               base::Unretained(this)));
 }
 
 void ExtensionMessageFilter::EnsureShutdownNotifierFactoryBuilt() {
-  ShutdownNotifierFactory::GetInstance();
+  ShutdownNotifierFactoryForExtensionMessageFilter::GetInstance();
 }
 
 ExtensionMessageFilter::~ExtensionMessageFilter() {
diff --git a/extensions/browser/extension_service_worker_message_filter.cc b/extensions/browser/extension_service_worker_message_filter.cc
index 5fca5696a..11321038d 100644
--- a/extensions/browser/extension_service_worker_message_filter.cc
+++ b/extensions/browser/extension_service_worker_message_filter.cc
@@ -28,27 +28,27 @@ namespace extensions {
 
 namespace {
 
-class ShutdownNotifierFactory
+class ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter
     : public BrowserContextKeyedServiceShutdownNotifierFactory {
  public:
-  ShutdownNotifierFactory(const ShutdownNotifierFactory&) = delete;
-  ShutdownNotifierFactory& operator=(const ShutdownNotifierFactory&) = delete;
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter(const ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter&) = delete;
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter& operator=(const ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter&) = delete;
 
-  static ShutdownNotifierFactory* GetInstance() {
-    return base::Singleton<ShutdownNotifierFactory>::get();
+  static ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter* GetInstance() {
+    return base::Singleton<ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter>::get();
   }
 
  private:
-  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactory>;
+  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter>;
 
-  ShutdownNotifierFactory()
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter()
       : BrowserContextKeyedServiceShutdownNotifierFactory(
             "ExtensionServiceWorkerMessageFilter") {
     DependsOn(ExtensionRegistryFactory::GetInstance());
     DependsOn(EventRouterFactory::GetInstance());
     DependsOn(ProcessManagerFactory::GetInstance());
   }
-  ~ShutdownNotifierFactory() override = default;
+  ~ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter() override = default;
 };
 
 }  // namespace
@@ -64,7 +64,7 @@ ExtensionServiceWorkerMessageFilter::ExtensionServiceWorkerMessageFilter(
       dispatcher_(new ExtensionFunctionDispatcher(context)) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   shutdown_notifier_subscription_ =
-      ShutdownNotifierFactory::GetInstance()->Get(context)->Subscribe(
+      ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter::GetInstance()->Get(context)->Subscribe(
           base::BindRepeating(
               &ExtensionServiceWorkerMessageFilter::ShutdownOnUIThread,
               base::Unretained(this)));
@@ -80,7 +80,7 @@ void ExtensionServiceWorkerMessageFilter::OnDestruct() const {
 }
 
 void ExtensionServiceWorkerMessageFilter::EnsureShutdownNotifierFactoryBuilt() {
-  ShutdownNotifierFactory::GetInstance();
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter::GetInstance();
 }
 
 ExtensionServiceWorkerMessageFilter::~ExtensionServiceWorkerMessageFilter() {}
diff --git a/extensions/common/BUILD.gn b/extensions/common/BUILD.gn
index 97c23c3ae..1297328ef 100644
--- a/extensions/common/BUILD.gn
+++ b/extensions/common/BUILD.gn
@@ -476,6 +476,11 @@ jumbo_static_library("common") {
   # from mojom/permission_set_mojom_traits.cc.
   allow_circular_includes_from = [ ":mojom" ]
 
+  jumbo_excluded_sources = [
+    "manifest_handlers/file_handler_info.cc",
+    "manifest_handlers/permissions_parser.cc",
+  ]
+
   deps = [
     "//base",
     "//build:branding_buildflags",
diff --git a/extensions/common/manifest_handlers/shared_module_info.cc b/extensions/common/manifest_handlers/shared_module_info.cc
index 0661cbb80..b19c778c5 100644
--- a/extensions/common/manifest_handlers/shared_module_info.cc
+++ b/extensions/common/manifest_handlers/shared_module_info.cc
@@ -35,7 +35,7 @@ namespace {
 
 const char kSharedModule[] = "shared_module";
 
-using ManifestKeys = api::shared_module::ManifestKeys;
+using ManifestKeys2 = api::shared_module::ManifestKeys;
 
 static base::LazyInstance<SharedModuleInfo>::DestructorAtExit
     g_empty_shared_module_info = LAZY_INSTANCE_INITIALIZER;
@@ -130,8 +130,8 @@ SharedModuleHandler::SharedModuleHandler() = default;
 SharedModuleHandler::~SharedModuleHandler() = default;
 
 bool SharedModuleHandler::Parse(Extension* extension, std::u16string* error) {
-  ManifestKeys manifest_keys;
-  if (!ManifestKeys::ParseFromDictionary(
+  ManifestKeys2 manifest_keys;
+  if (!ManifestKeys2::ParseFromDictionary(
           extension->manifest()->available_values(), &manifest_keys, error)) {
     return false;
   }
@@ -210,8 +210,8 @@ bool SharedModuleHandler::Validate(
 }
 
 base::span<const char* const> SharedModuleHandler::Keys() const {
-  static constexpr const char* kKeys[] = {ManifestKeys::kImport,
-                                          ManifestKeys::kExport};
+  static constexpr const char* kKeys[] = {ManifestKeys2::kImport,
+                                          ManifestKeys2::kExport};
   return kKeys;
 }
 
diff --git a/gpu/command_buffer/service/BUILD.gn b/gpu/command_buffer/service/BUILD.gn
index 2e0a3176b..375215e6b 100644
--- a/gpu/command_buffer/service/BUILD.gn
+++ b/gpu/command_buffer/service/BUILD.gn
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//skia/features.gni")
@@ -27,9 +26,9 @@ group("gles2") {
 }
 
 if (is_component_build) {
-  link_target_type = "jumbo_source_set"
+  link_target_type = "source_set"
 } else {
-  link_target_type = "jumbo_static_library"
+  link_target_type = "static_library"
 }
 target(link_target_type, "service_sources") {
   # External code should depend on this via //gpu/command_buffer/service above
@@ -594,7 +593,7 @@ proto_library("disk_cache_proto") {
 }
 
 if (is_android) {
-  jumbo_static_library("android_texture_owner_test_support") {
+  static_library("android_texture_owner_test_support") {
     testonly = true
     sources = [
       "mock_abstract_texture.cc",
diff --git a/gpu/config/BUILD.gn b/gpu/config/BUILD.gn
index 4f552bc9f..d8ee27329 100644
--- a/gpu/config/BUILD.gn
+++ b/gpu/config/BUILD.gn
@@ -5,7 +5,6 @@
 import("//build/config/chrome_build.gni")
 import("//build/config/chromecast_build.gni")
 import("//build/config/chromeos/ui_mode.gni")
-import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//skia/features.gni")
@@ -114,7 +113,7 @@ if (enable_vulkan) {
   }
 }
 
-jumbo_source_set("config_sources") {
+source_set("config_sources") {
   # External code should depend on this via //gpu/config above rather than
   # depending on this directly or the component build will break.
   visibility = [ "//gpu/*" ]
diff --git a/media/filters/h265_to_annex_b_bitstream_converter.cc b/media/filters/h265_to_annex_b_bitstream_converter.cc
index 60af198f9..4bc2033a1 100644
--- a/media/filters/h265_to_annex_b_bitstream_converter.cc
+++ b/media/filters/h265_to_annex_b_bitstream_converter.cc
@@ -14,12 +14,12 @@
 namespace media {
 namespace {
 
-static const uint8_t kStartCodePrefix[3] = {0, 0, 1};
-static const uint32_t kParamSetStartCodeSize = 1 + sizeof(kStartCodePrefix);
+static const uint8_t kStartCodePrefix2[3] = {0, 0, 1};
+static const uint32_t kParamSetStartCodeSize2 = 1 + sizeof(kStartCodePrefix2);
 
 // Helper function which determines whether NAL unit of given type marks
 // access unit boundary.
-static bool IsAccessUnitBoundaryNal(int nal_unit_type) {
+static bool IsAccessUnitBoundaryNal2(int nal_unit_type) {
   // Spec 7.4.2.4.4
   // Check if this packet marks access unit boundary by checking the
   // packet type.
@@ -64,7 +64,7 @@ uint32_t H265ToAnnexBBitstreamConverter::GetConfigSize(
 
   for (auto& nalu_array : hevc_config.arrays) {
     for (auto& nalu : nalu_array.units) {
-      config_size += kParamSetStartCodeSize + nalu.size();
+      config_size += kParamSetStartCodeSize2 + nalu.size();
     }
   }
   return config_size;
@@ -118,12 +118,12 @@ uint32_t H265ToAnnexBBitstreamConverter::CalculateNeededOutputBufferSize(
     // nal_unit_type.
     int nal_unit_type = (*input >> 1) & 0x3F;
     if (first_nal_in_this_access_unit ||
-        IsAccessUnitBoundaryNal(nal_unit_type)) {
+        IsAccessUnitBoundaryNal2(nal_unit_type)) {
       output_size += 1;  // Extra zero_byte for these nal units
       first_nal_in_this_access_unit = false;
     }
     // Start code prefix
-    output_size += sizeof(kStartCodePrefix);
+    output_size += sizeof(kStartCodePrefix2);
     // Actual NAL unit size
     output_size += nal_unit_length;
     input += nal_unit_length;
@@ -218,8 +218,8 @@ bool H265ToAnnexBBitstreamConverter::ConvertNalUnitStreamToByteStream(
     }
     uint32_t start_code_len;
     first_nal_unit_in_access_unit_
-        ? start_code_len = sizeof(kStartCodePrefix) + 1
-        : start_code_len = sizeof(kStartCodePrefix);
+        ? start_code_len = sizeof(kStartCodePrefix2) + 1
+        : start_code_len = sizeof(kStartCodePrefix2);
     if (static_cast<uint32_t>(outscan - output) + start_code_len +
             nal_unit_length >
         *output_size) {
@@ -229,7 +229,7 @@ bool H265ToAnnexBBitstreamConverter::ConvertNalUnitStreamToByteStream(
 
     // Check if this packet marks access unit boundary by checking the
     // packet type.
-    if (IsAccessUnitBoundaryNal(nal_unit_type)) {
+    if (IsAccessUnitBoundaryNal2(nal_unit_type)) {
       first_nal_unit_in_access_unit_ = true;
     }
 
@@ -243,8 +243,8 @@ bool H265ToAnnexBBitstreamConverter::ConvertNalUnitStreamToByteStream(
 
     // No need to write leading zero bits.
     // Write start-code prefix.
-    memcpy(outscan, kStartCodePrefix, sizeof(kStartCodePrefix));
-    outscan += sizeof(kStartCodePrefix);
+    memcpy(outscan, kStartCodePrefix2, sizeof(kStartCodePrefix2));
+    outscan += sizeof(kStartCodePrefix2);
     // Then write the actual NAL unit from the input buffer.
     memcpy(outscan, inscan, nal_unit_length);
     inscan += nal_unit_length;
@@ -270,8 +270,8 @@ bool H265ToAnnexBBitstreamConverter::WriteParamSet(
 
   // Verify space.
   uint32_t bytes_left = *out_size;
-  if (bytes_left < kParamSetStartCodeSize ||
-      bytes_left - kParamSetStartCodeSize < size) {
+  if (bytes_left < kParamSetStartCodeSize2 ||
+      bytes_left - kParamSetStartCodeSize2 < size) {
     return false;
   }
 
@@ -280,8 +280,8 @@ bool H265ToAnnexBBitstreamConverter::WriteParamSet(
 
   // Write the 4 byte Annex B start code.
   *buf++ = 0;  // zero byte
-  memcpy(buf, kStartCodePrefix, sizeof(kStartCodePrefix));
-  buf += sizeof(kStartCodePrefix);
+  memcpy(buf, kStartCodePrefix2, sizeof(kStartCodePrefix2));
+  buf += sizeof(kStartCodePrefix2);
 
   // Copy the data.
   memcpy(buf, &param_set[0], size);
diff --git a/media/filters/mac/audio_toolbox_audio_encoder.cc b/media/filters/mac/audio_toolbox_audio_encoder.cc
index c1875279f..0329077f8 100644
--- a/media/filters/mac/audio_toolbox_audio_encoder.cc
+++ b/media/filters/mac/audio_toolbox_audio_encoder.cc
@@ -20,7 +20,7 @@ namespace media {
 
 namespace {
 
-struct InputData {
+struct InputData2 {
   raw_ptr<const AudioBus> bus = nullptr;
   bool flushing = false;
 };
@@ -28,12 +28,12 @@ struct InputData {
 constexpr int kAacFramesPerBuffer = 1024;
 
 // Callback used to provide input data to the AudioConverter.
-OSStatus ProvideInputCallback(AudioConverterRef decoder,
+OSStatus ProvideInputCallback2(AudioConverterRef decoder,
                               UInt32* num_packets,
                               AudioBufferList* buffer_list,
                               AudioStreamPacketDescription** packets,
                               void* user_data) {
-  auto* input_data = reinterpret_cast<InputData*>(user_data);
+  auto* input_data = reinterpret_cast<InputData2*>(user_data);
   if (input_data->flushing) {
     *num_packets = 0;
     return noErr;
@@ -294,7 +294,7 @@ bool AudioToolboxAudioEncoder::CreateEncoder(
 void AudioToolboxAudioEncoder::DoEncode(AudioBus* input_bus) {
   bool is_flushing = !input_bus;
 
-  InputData input_data;
+  InputData2 input_data;
   input_data.bus = input_bus;
   input_data.flushing = is_flushing;
 
diff --git a/media/filters/media_file_checker.cc b/media/filters/media_file_checker.cc
index dca328bc6..a2d475758 100644
--- a/media/filters/media_file_checker.cc
+++ b/media/filters/media_file_checker.cc
@@ -29,7 +29,7 @@ void OnMediaFileCheckerError(bool* called) {
   *called = false;
 }
 
-struct Decoder {
+struct DecoderStruct {
   std::unique_ptr<AVCodecContext, ScopedPtrAVFreeContext> context;
   std::unique_ptr<FFmpegDecodingLoop> loop;
 };
@@ -59,7 +59,7 @@ bool MediaFileChecker::Start(base::TimeDelta check_time) {
 
   // Remember the codec context for any decodable audio or video streams.
   bool found_streams = false;
-  std::vector<Decoder> stream_contexts(format_context->nb_streams);
+  std::vector<DecoderStruct> stream_contexts(format_context->nb_streams);
   for (size_t i = 0; i < format_context->nb_streams; ++i) {
     AVCodecParameters* cp = format_context->streams[i]->codecpar;
 
diff --git a/media/mojo/services/gpu_mojo_media_client_cros.cc b/media/mojo/services/gpu_mojo_media_client_cros.cc
index 7cc7e9d60..389b71b7b 100644
--- a/media/mojo/services/gpu_mojo_media_client_cros.cc
+++ b/media/mojo/services/gpu_mojo_media_client_cros.cc
@@ -10,6 +10,7 @@
 #include "build/build_config.h"
 #include "media/base/audio_decoder.h"
 #include "media/base/audio_encoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/media_switches.h"
 #include "media/gpu/chromeos/mailbox_video_frame_converter.h"
 #include "media/gpu/chromeos/platform_video_frame_pool.h"
@@ -224,10 +225,6 @@ std::unique_ptr<AudioEncoder> CreatePlatformAudioEncoder(
   return nullptr;
 }
 
-#if !BUILDFLAG(IS_CHROMEOS)
-class CdmFactory {};
-#endif  // !BUILDFLAG(IS_CHROMEOS)
-
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
 #if BUILDFLAG(IS_CHROMEOS)
diff --git a/media/mojo/services/gpu_mojo_media_client_mac.cc b/media/mojo/services/gpu_mojo_media_client_mac.cc
index 7ddaadc74..cc7a68134 100644
--- a/media/mojo/services/gpu_mojo_media_client_mac.cc
+++ b/media/mojo/services/gpu_mojo_media_client_mac.cc
@@ -6,6 +6,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/thread_pool.h"
 #include "media/base/audio_decoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/offloading_audio_encoder.h"
 #include "media/filters/mac/audio_toolbox_audio_decoder.h"
 #include "media/filters/mac/audio_toolbox_audio_encoder.h"
@@ -46,7 +47,7 @@ std::unique_ptr<AudioEncoder> CreatePlatformAudioEncoder(
 }
 
 // This class doesn't exist on mac, so we need a stub for unique_ptr.
-class CdmFactory {};
+//class CdmFactory {};
 
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
diff --git a/media/mojo/services/gpu_mojo_media_client_stubs.cc b/media/mojo/services/gpu_mojo_media_client_stubs.cc
index 990226164..fd8fc1032 100644
--- a/media/mojo/services/gpu_mojo_media_client_stubs.cc
+++ b/media/mojo/services/gpu_mojo_media_client_stubs.cc
@@ -6,6 +6,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "media/base/audio_decoder.h"
 #include "media/base/audio_encoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/video_decoder.h"
 #include "media/mojo/services/gpu_mojo_media_client.h"
 
@@ -35,9 +36,6 @@ std::unique_ptr<AudioEncoder> CreatePlatformAudioEncoder(
   return nullptr;
 }
 
-// This class doesn't exist on any of the platforms that use the stubs.
-class CdmFactory {};
-
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
   return nullptr;
diff --git a/media/mojo/services/gpu_mojo_media_client_win.cc b/media/mojo/services/gpu_mojo_media_client_win.cc
index 624f1950e..4bfe1dd04 100644
--- a/media/mojo/services/gpu_mojo_media_client_win.cc
+++ b/media/mojo/services/gpu_mojo_media_client_win.cc
@@ -8,6 +8,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/thread_pool.h"
 #include "media/base/audio_decoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/media_switches.h"
 #include "media/base/offloading_audio_encoder.h"
 #if BUILDFLAG(ENABLE_PLATFORM_DTS_AUDIO)
@@ -98,7 +99,7 @@ VideoDecoderType GetPlatformDecoderImplementationType(
 }
 
 // There is no CdmFactory on windows, so just stub it out.
-class CdmFactory {};
+//class CdmFactory {};
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
   return nullptr;
diff --git a/mojo/public/tools/bindings/mojom.gni b/mojo/public/tools/bindings/mojom.gni
index 6b29f9c12..496934eeb 100644
--- a/mojo/public/tools/bindings/mojom.gni
+++ b/mojo/public/tools/bindings/mojom.gni
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//third_party/closure_compiler/closure_args.gni")
 import("//third_party/closure_compiler/compile_js.gni")
 import("//third_party/protobuf/proto_library.gni")
@@ -947,7 +946,7 @@ template("mojom") {
   }
 
   shared_cpp_sources_target_name = "${target_name}_shared_cpp_sources"
-  jumbo_source_set(shared_cpp_sources_target_name) {
+  source_set(shared_cpp_sources_target_name) {
     if (defined(invoker.testonly)) {
       testonly = invoker.testonly
     }
@@ -1567,7 +1566,7 @@ template("mojom") {
       sources_target_name = output_target_name
     }
 
-    target("jumbo_" + sources_target_type, sources_target_name) {
+    target(sources_target_type, sources_target_name) {
       if (defined(output_name_override)) {
         output_name = output_name_override
       }
diff --git a/services/network/public/cpp/BUILD.gn b/services/network/public/cpp/BUILD.gn
index 8d757bb4e..ca0babdb0 100644
--- a/services/network/public/cpp/BUILD.gn
+++ b/services/network/public/cpp/BUILD.gn
@@ -377,6 +377,10 @@ jumbo_component("cpp_base") {
     "web_transport_error_mojom_traits.cc",
     "web_transport_error_mojom_traits.h",
   ]
+  jumbo_excluded_sources = [
+    "network_ipc_param_traits.cc",
+    "url_request_mojom_traits.cc"
+  ]
 
   configs += [ "//build/config/compiler:wexit_time_destructors" ]
 
@@ -413,6 +417,7 @@ jumbo_component("cpp_base") {
       "p2p_param_traits.h",
       "p2p_socket_type.h",
     ]
+    jumbo_excluded_sources += [ "p2p_param_traits.cc" ]
 
     public_deps += [ "//third_party/webrtc_overrides:webrtc_component" ]
   }
diff --git a/services/network/web_bundle/web_bundle_url_loader_factory.cc b/services/network/web_bundle/web_bundle_url_loader_factory.cc
index eba6b4fba..036cab919 100644
--- a/services/network/web_bundle/web_bundle_url_loader_factory.cc
+++ b/services/network/web_bundle/web_bundle_url_loader_factory.cc
@@ -34,7 +34,7 @@ namespace network {
 
 namespace {
 
-constexpr size_t kBlockedBodyAllocationSize = 1;
+constexpr size_t kBlockedBodyAllocationSize2 = 1;
 
 void DeleteProducerAndRunCallback(
     std::unique_ptr<mojo::DataPipeProducer> producer,
@@ -86,7 +86,7 @@ class WebBundleURLLoaderClient : public network::mojom::URLLoaderClient {
     options.struct_size = sizeof(MojoCreateDataPipeOptions);
     options.flags = MOJO_CREATE_DATA_PIPE_FLAG_NONE;
     options.element_num_bytes = 1;
-    options.capacity_num_bytes = kBlockedBodyAllocationSize;
+    options.capacity_num_bytes = kBlockedBodyAllocationSize2;
     mojo::ScopedDataPipeProducerHandle producer;
     mojo::ScopedDataPipeConsumerHandle consumer;
     MojoResult result = mojo::CreateDataPipe(&options, producer, consumer);
diff --git a/storage/browser/BUILD.gn b/storage/browser/BUILD.gn
index e30e9df29..e4768078a 100644
--- a/storage/browser/BUILD.gn
+++ b/storage/browser/BUILD.gn
@@ -226,6 +226,10 @@ jumbo_component("browser") {
     "quota/usage_tracker.h",
   ]
 
+  jumbo_excluded_sources = [
+    "file_system/local_file_stream_reader.cc",
+  ]
+
   defines = [ "IS_STORAGE_BROWSER_IMPL" ]
   configs += [
     "//build/config:precompiled_headers",
diff --git a/storage/browser/blob/blob_url_registry.cc b/storage/browser/blob/blob_url_registry.cc
index 95072bc21..2a0f7ea39 100644
--- a/storage/browser/blob/blob_url_registry.cc
+++ b/storage/browser/blob/blob_url_registry.cc
@@ -15,7 +15,7 @@ namespace storage {
 
 namespace {
 
-BlobUrlRegistry::URLStoreCreationHook* g_url_store_creation_hook = nullptr;
+BlobUrlRegistry::URLStoreCreationHook* g_url_store_creation_hook2 = nullptr;
 
 }
 
@@ -35,8 +35,8 @@ void BlobUrlRegistry::AddReceiver(
       std::make_unique<storage::BlobURLStoreImpl>(storage_key, AsWeakPtr()),
       std::move(receiver));
 
-  if (g_url_store_creation_hook) {
-    g_url_store_creation_hook->Run(this, receiver_id);
+  if (g_url_store_creation_hook2) {
+    g_url_store_creation_hook2->Run(this, receiver_id);
   }
 }
 
@@ -180,7 +180,7 @@ void BlobUrlRegistry::SetURLStoreCreationHookForTesting(
     URLStoreCreationHook* hook) {
   DCHECK(
       base::FeatureList::IsEnabled(net::features::kSupportPartitionedBlobUrl));
-  g_url_store_creation_hook = hook;
+  g_url_store_creation_hook2 = hook;
 }
 
 }  // namespace storage
diff --git a/storage/browser/quota/quota_settings.cc b/storage/browser/quota/quota_settings.cc
index b90b65552..88ae48f60 100644
--- a/storage/browser/quota/quota_settings.cc
+++ b/storage/browser/quota/quota_settings.cc
@@ -24,14 +24,14 @@ namespace storage {
 
 namespace {
 
-const int64_t kMBytes = 1024 * 1024;
+const int64_t _kMBytes = 1024 * 1024;
 const int kRandomizedPercentage = 10;
 const double kDefaultPerStorageKeyRatio = 0.75;
 const double kIncognitoQuotaRatioLowerBound = 0.15;
 const double kIncognitoQuotaRatioUpperBound = 0.2;
 
 // Skews |value| by +/- |percent|.
-int64_t RandomizeByPercent(int64_t value, int percent) {
+int64_t MyRandomizeByPercent(int64_t value, int percent) {
   double random_percent = (base::RandDouble() - 0.5) * percent * 2;
   return value + (value * (random_percent / 100.0));
 }
@@ -117,7 +117,7 @@ absl::optional<QuotaSettings> CalculateNominalDynamicSettings(
   // SessionOnly (or ephemeral) origins are allotted a fraction of what
   // normal origins are provided, and the amount is capped to a hard limit.
   const double kSessionOnlyStorageKeyQuotaRatio = 0.1;  // 10%
-  const int64_t kMaxSessionOnlyStorageKeyQuota = 300 * kMBytes;
+  const int64_t kMaxSessionOnlyStorageKeyQuota = 300 * _kMBytes;
 
   QuotaSettings settings;
 
@@ -144,10 +144,9 @@ absl::optional<QuotaSettings> CalculateNominalDynamicSettings(
                static_cast<int64_t>(total * kMustRemainAvailableRatio));
   settings.per_storage_key_quota = pool_size * kPerStorageKeyTemporaryRatio;
   settings.session_only_per_storage_key_quota = std::min(
-      RandomizeByPercent(kMaxSessionOnlyStorageKeyQuota, kRandomizedPercentage),
+      MyRandomizeByPercent(kMaxSessionOnlyStorageKeyQuota, kRandomizedPercentage),
       static_cast<int64_t>(settings.per_storage_key_quota *
                            kSessionOnlyStorageKeyQuotaRatio));
-  settings.refresh_interval = base::Seconds(60);
   return settings;
 }
 
diff --git a/third_party/blink/common/frame/user_activation_state.cc b/third_party/blink/common/frame/user_activation_state.cc
index de3b52d4b..e80da3f8b 100644
--- a/third_party/blink/common/frame/user_activation_state.cc
+++ b/third_party/blink/common/frame/user_activation_state.cc
@@ -31,7 +31,7 @@ bool IsRestricted(UserActivationNotificationType notification_type) {
 // The expiry time should be long enough to allow network round trips even in a
 // very slow connection (to support xhr-like calls with user activation), yet
 // not too long to make an "unattended" page feel activated.
-constexpr base::TimeDelta kActivationLifespan = base::Seconds(5);
+constexpr base::TimeDelta kActivationLifespan2 = base::Seconds(5);
 
 UserActivationState::UserActivationState()
     : first_notification_type_(UserActivationNotificationType::kNone),
@@ -101,7 +101,7 @@ void UserActivationState::RecordPreconsumptionUma() const {
 }
 
 void UserActivationState::ActivateTransientState() {
-  transient_state_expiry_time_ = base::TimeTicks::Now() + kActivationLifespan;
+  transient_state_expiry_time_ = base::TimeTicks::Now() + kActivationLifespan2;
 }
 
 void UserActivationState::DeactivateTransientState() {
diff --git a/third_party/blink/common/user_agent/user_agent_metadata.cc b/third_party/blink/common/user_agent/user_agent_metadata.cc
index 3b99c66c4..935b02967 100644
--- a/third_party/blink/common/user_agent/user_agent_metadata.cc
+++ b/third_party/blink/common/user_agent/user_agent_metadata.cc
@@ -11,7 +11,7 @@
 namespace blink {
 
 namespace {
-constexpr uint32_t kVersion = 2u;
+constexpr uint32_t kVersionUA = 2u;
 }  // namespace
 
 UserAgentBrandVersion::UserAgentBrandVersion(const std::string& ua_brand,
@@ -56,7 +56,7 @@ absl::optional<std::string> UserAgentMetadata::Marshal(
   if (!in)
     return absl::nullopt;
   base::Pickle out;
-  out.WriteUInt32(kVersion);
+  out.WriteUInt32(kVersionUA);
 
   out.WriteUInt32(in->brand_version_list.size());
   for (const auto& brand_version : in->brand_version_list) {
@@ -92,7 +92,7 @@ absl::optional<UserAgentMetadata> UserAgentMetadata::Demarshal(
 
   uint32_t version;
   UserAgentMetadata out;
-  if (!in.ReadUInt32(&version) || version != kVersion)
+  if (!in.ReadUInt32(&version) || version != kVersionUA)
     return absl::nullopt;
 
   uint32_t brand_version_size;
diff --git a/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py b/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py
index 6703feeb0..7478af1ef 100644
--- a/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py
+++ b/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py
@@ -185,6 +185,7 @@ def generate_callback_interface(callback_interface_identifier):
          cg_context,
          FN_INSTALL_INTERFACE_TEMPLATE,
          class_name=class_name,
+         api_class_name=class_name,
          trampoline_var_name=None,
          constructor_entries=[],
          supplemental_install_node=SequenceNode(),
diff --git a/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py b/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
index 1c163ff51..af714c4c6 100644
--- a/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
+++ b/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
@@ -5689,7 +5689,7 @@ ${prototype_object}->GetPrototype().As<v8::Object>()->Delete(
     return SequenceNode(nodes) if nodes else None
 
 
-def make_install_interface_template(cg_context, function_name, class_name,
+def make_install_interface_template(cg_context, function_name, class_name, api_class_name,
                                     trampoline_var_name, constructor_entries,
                                     supplemental_install_node,
                                     install_unconditional_func_name,
@@ -5813,7 +5813,7 @@ def make_install_interface_template(cg_context, function_name, class_name,
     for entry in constructor_entries:
         nodes = [
             FormatNode("${interface_function_template}->SetCallHandler({});",
-                       entry.ctor_callback_name),
+                       api_class_name + "Callbacks::" + entry.ctor_callback_name),
             FormatNode("${interface_function_template}->SetLength({});",
                        entry.ctor_func_length),
         ]
@@ -6208,6 +6208,7 @@ ${instance_object} = ${v8_context}->Global()->GetPrototype().As<v8::Object>();\
         if unconditional_entries:
             body.append(
                 CxxBlockNode([
+                    TextNode("using namespace ${class_name}Callbacks;"),
                     make_table_func(table_name, unconditional_entries),
                     TextNode(installer_call_text),
                 ]))
@@ -6217,6 +6218,7 @@ ${instance_object} = ${v8_context}->Global()->GetPrototype().As<v8::Object>();\
                 CxxUnlikelyIfNode(
                     cond=conditional,
                     body=[
+                        TextNode("using namespace ${class_name}Callbacks;"),
                         make_table_func(table_name, entries),
                         TextNode(installer_call_text),
                     ]))
@@ -6368,6 +6370,8 @@ def make_indexed_and_named_property_callbacks_and_install_node(cg_context):
                 map(lambda flag: "int32_t({})".format(flag), flags))))
         pattern = """\
 // Named interceptors
+{{
+using namespace ${class_name}Callbacks;
 ${instance_object_template}->SetHandler(
     v8::NamedPropertyHandlerConfiguration(
         {impl_bridge}::NamedPropertyGetterCallback,
@@ -6388,7 +6392,9 @@ interface.indexed_and_named_properties.named_getter.extended_attributes:
         {impl_bridge}::NamedPropertyDefinerCallback,
         {impl_bridge}::NamedPropertyDescriptorCallback,
         v8::Local<v8::Value>(),
-        {property_handler_flags}));"""
+        {property_handler_flags}));
+}}
+"""
         install_node.append(
             F(pattern,
               impl_bridge=impl_bridge,
@@ -6428,6 +6434,8 @@ interface.indexed_and_named_properties.named_getter.extended_attributes:
         property_handler_flags = flags[0]
         pattern = """\
 // Indexed interceptors
+{{
+using namespace ${class_name}Callbacks;
 ${instance_object_template}->SetHandler(
     v8::IndexedPropertyHandlerConfiguration(
         {impl_bridge}::IndexedPropertyGetterCallback,
@@ -6442,7 +6450,8 @@ ${instance_object_template}->SetHandler(
         {impl_bridge}::IndexedPropertyDefinerCallback,
         {impl_bridge}::IndexedPropertyDescriptorCallback,
         v8::Local<v8::Value>(),
-        {property_handler_flags}));"""
+        {property_handler_flags}));
+}}"""
         install_node.append(
             F(pattern,
               impl_bridge=impl_bridge,
@@ -6503,6 +6512,8 @@ def make_named_properties_object_callbacks_and_install_node(cg_context):
         callback_defs.append(EmptyNode())
 
     text = """\
+{{
+using namespace ${class_name}Callbacks;
 // Named interceptors
 ${npo_prototype_template}->SetHandler(
     v8::NamedPropertyHandlerConfiguration(
@@ -6528,7 +6539,8 @@ ${npo_prototype_template}->SetHandler(
         NamedPropsObjIndexedDefinerCallback,
         NamedPropsObjIndexedDescriptorCallback,
         v8::Local<v8::Value>(),
-        v8::PropertyHandlerFlags::kNone));"""
+        v8::PropertyHandlerFlags::kNone));
+}}"""
     install_node.append(TextNode(text))
 
     return callback_defs, install_node
@@ -6667,6 +6679,8 @@ def make_cross_origin_property_callbacks_and_install_node(
 
     text = """\
 // Cross origin properties
+{{
+using namespace ${class_name}Callbacks;
 ${instance_object_template}->SetAccessCheckCallbackAndHandler(
     CrossOriginAccessCheckCallback,
     v8::NamedPropertyHandlerConfiguration(
@@ -6692,6 +6706,7 @@ ${instance_object_template}->SetAccessCheckCallbackAndHandler(
     v8::External::New(
         ${isolate},
         const_cast<WrapperTypeInfo*>(${class_name}::GetWrapperTypeInfo())));
+}}
 """
     install_node.append(TextNode(text))
     install_node.accumulate(
@@ -6724,6 +6739,8 @@ ${instance_object_template}->SetAccessCheckCallbackAndHandler(
         callback_defs.append(EmptyNode())
 
     text = """\
+{{
+using namespace ${class_name}Callbacks;
 // Same origin interceptors
 ${instance_object_template}->SetHandler(
     v8::IndexedPropertyHandlerConfiguration(
@@ -6736,6 +6753,7 @@ ${instance_object_template}->SetHandler(
         SameOriginIndexedDescriptorCallback,
         v8::Local<v8::Value>(),
         v8::PropertyHandlerFlags::kNone));
+}}
 """
     install_node.append(TextNode(text))
 
@@ -6905,6 +6923,7 @@ def make_wrapper_type_info(cg_context, function_name,
         ]))
 
     pattern = """\
+namespace ${class_name}Callbacks {{ }}
 // Construction of WrapperTypeInfo may require non-trivial initialization due
 // to cross-component address resolution in order to load the pointer to the
 // parent interface's WrapperTypeInfo.  We ignore this issue because the issue
@@ -7112,6 +7131,7 @@ def _make_v8_context_snapshot_get_reference_table_function(
                                                                            )),
             filter(None, callback_names)))
     table_node = ListNode([
+        TextNode("using namespace ${class_name}Callbacks;"),
         TextNode("static const intptr_t kReferenceTable[] = {"),
         ListNode(entry_nodes),
         TextNode("};"),
@@ -7568,6 +7588,7 @@ def generate_class_like(class_like,
          cg_context,
          FN_INSTALL_INTERFACE_TEMPLATE,
          class_name=impl_class_name,
+         api_class_name=api_class_name,
          trampoline_var_name=tp_install_interface_template,
          constructor_entries=constructor_entries,
          supplemental_install_node=supplemental_install_node,
@@ -7820,7 +7841,7 @@ def generate_class_like(class_like,
                                                     class_like.identifier)
     impl_source_blink_ns.body.extend([
         CxxNamespaceNode(
-            name="",
+            name=api_class_name + "Callbacks",
             body=[
                 # Enclose the implementations with a namespace just in order to
                 # include the class_like name in a stacktrace, such as
diff --git a/third_party/blink/renderer/core/BUILD.gn b/third_party/blink/renderer/core/BUILD.gn
index e1234cafb..b5867d2da 100644
--- a/third_party/blink/renderer/core/BUILD.gn
+++ b/third_party/blink/renderer/core/BUILD.gn
@@ -5,6 +5,7 @@
 import("//build/config/chromecast_build.gni")
 import("//build/config/compiler/compiler.gni")
 import("//build/config/dcheck_always_on.gni")
+import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//build/toolchain/toolchain.gni")
 import("//media/media_options.gni")
@@ -144,7 +145,7 @@ source_set("core_common") {
   sources = [ "core_export.h" ]
 }
 
-source_set("prerequisites") {
+jumbo_source_set("prerequisites") {
   public_deps = [
     "//services/network/public/cpp:cpp",
     "//services/network/public/mojom",
@@ -186,7 +187,7 @@ source_set("prerequisites") {
   ]
 }
 
-component("core") {
+jumbo_component("core") {
   output_name = "blink_core"
 
   visibility = []  # Allow re-assignment of list.
@@ -361,6 +362,14 @@ component("core") {
     "//third_party/blink/renderer/core/url_pattern",
     "//third_party/blink/renderer/core/xml:xpath_generated",
   ]
+  jumbo_excluded_sources = [ ]
+  jumbo_excluded_sources += rebase_path([ "frame_fetch_context.cc" ], "", "loader")
+  jumbo_excluded_sources += rebase_path([ "image_loader.cc" ], "", "loader")
+  jumbo_excluded_sources += rebase_path([ "create_window.cc" ], "", "page")
+  jumbo_excluded_sources += rebase_path([ "link_highlight_impl.cc" ], "", "paint")
+  jumbo_excluded_sources += rebase_path([ "scroll_animator.cc" ], "", "scroll")
+  jumbo_excluded_sources += rebase_path([ "grid_baseline_alignment.cc" ], "", "layout")
+  jumbo_excluded_sources += rebase_path([ "grid_track_sizing_algorithm.cc" ], "", "layout")
 
   public_configs = [ ":core_include_dirs" ]
 
diff --git a/third_party/blink/renderer/core/animation/BUILD.gn b/third_party/blink/renderer/core/animation/BUILD.gn
index 4ce94baab..97a1f8811 100644
--- a/third_party/blink/renderer/core/animation/BUILD.gn
+++ b/third_party/blink/renderer/core/animation/BUILD.gn
@@ -300,6 +300,9 @@ blink_core_sources("animation") {
     "worklet_animation_controller.cc",
     "worklet_animation_controller.h",
   ]
+  jumbo_excluded_sources = [
+    "css_transform_interpolation_type.cc",
+  ]
 
   deps = [
     ":buildflags",
diff --git a/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc b/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc
index 47ec7902e..6beb54e33 100644
--- a/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc
+++ b/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc
@@ -207,7 +207,7 @@ CSSShadowListInterpolationType::PreInterpolationCompositeIfNeeded(
   // to disable that caching in this case.
   // TODO(crbug.com/1009230): Remove this once our interpolation code isn't
   // caching composited values.
-  conversion_checkers.push_back(std::make_unique<AlwaysInvalidateChecker>());
+  conversion_checkers.push_back(std::make_unique<blink::AlwaysInvalidateChecker>());
   auto interpolable_list = std::unique_ptr<InterpolableList>(
       To<InterpolableList>(value.interpolable_value.release()));
   if (composite == EffectModel::CompositeOperation::kCompositeAdd) {
diff --git a/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc b/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc
index 8554ef066..50ad55bc8 100644
--- a/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc
+++ b/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc
@@ -11,22 +11,22 @@ namespace blink {
 namespace {
 
 BoxShadowPaintImageGenerator::BoxShadowPaintImageGeneratorCreateFunction*
-    g_create_function = nullptr;
+    g_create_function_bspig = nullptr;
 
 }  // namespace
 
 // static
 void BoxShadowPaintImageGenerator::Init(
     BoxShadowPaintImageGeneratorCreateFunction* create_function) {
-  DCHECK(!g_create_function);
-  g_create_function = create_function;
+  DCHECK(!g_create_function_bspig);
+  g_create_function_bspig = create_function;
 }
 
 BoxShadowPaintImageGenerator* BoxShadowPaintImageGenerator::Create(
     LocalFrame& local_root) {
-  DCHECK(g_create_function);
+  DCHECK(g_create_function_bspig);
   DCHECK(local_root.IsLocalRoot());
-  return g_create_function(local_root);
+  return g_create_function_bspig(local_root);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc b/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc
index 84cae256f..f365766dd 100644
--- a/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc
+++ b/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc
@@ -11,22 +11,22 @@ namespace blink {
 namespace {
 
 ClipPathPaintImageGenerator::ClipPathPaintImageGeneratorCreateFunction*
-    g_create_function = nullptr;
+    g_create_function2 = nullptr;
 
 }  // namespace
 
 // static
 void ClipPathPaintImageGenerator::Init(
     ClipPathPaintImageGeneratorCreateFunction* create_function) {
-  DCHECK(!g_create_function);
-  g_create_function = create_function;
+  DCHECK(!g_create_function2);
+  g_create_function2 = create_function;
 }
 
 ClipPathPaintImageGenerator* ClipPathPaintImageGenerator::Create(
     LocalFrame& local_root) {
-  DCHECK(g_create_function);
+  DCHECK(g_create_function2);
   DCHECK(local_root.IsLocalRoot());
-  return g_create_function(local_root);
+  return g_create_function2(local_root);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc b/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc
index a9437500d..2029ebfbc 100644
--- a/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc
+++ b/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc
@@ -90,7 +90,7 @@ size_t GetCurrentCursorPositionInFrame(LocalFrame* local_frame) {
 }
 #endif
 
-RemoteFrame* SourceFrameForOptionalToken(
+RemoteFrame* SourceFrameForOptionalToken2(
     const absl::optional<RemoteFrameToken>& source_frame_token) {
   if (!source_frame_token)
     return nullptr;
@@ -710,7 +710,7 @@ void LocalFrameMojoHandler::AdvanceFocusInFrame(
     mojom::blink::FocusType focus_type,
     const absl::optional<RemoteFrameToken>& source_frame_token) {
   RemoteFrame* source_frame =
-      source_frame_token ? SourceFrameForOptionalToken(*source_frame_token)
+      source_frame_token ? SourceFrameForOptionalToken2(*source_frame_token)
                          : nullptr;
   if (!source_frame) {
     SetInitialFocus(focus_type == mojom::blink::FocusType::kBackward);
diff --git a/third_party/blink/renderer/core/frame/sticky_ad_detector.cc b/third_party/blink/renderer/core/frame/sticky_ad_detector.cc
index efaeba07b..f108d589a 100644
--- a/third_party/blink/renderer/core/frame/sticky_ad_detector.cc
+++ b/third_party/blink/renderer/core/frame/sticky_ad_detector.cc
@@ -22,8 +22,8 @@ namespace blink {
 
 namespace {
 
-constexpr base::TimeDelta kFireInterval = base::Seconds(1);
-constexpr double kLargeAdSizeToViewportSizeThreshold = 0.3;
+constexpr base::TimeDelta kFireInterval2 = base::Seconds(1);
+constexpr double kLargeAdSizeToViewportSizeThreshold2 = 0.3;
 
 // An sticky element should have a non-default position w.r.t. the viewport. The
 // main page should also be scrollable.
@@ -71,7 +71,7 @@ void StickyAdDetector::MaybeFireDetection(LocalFrame* outermost_main_frame) {
   if (last_detection_time_.has_value() &&
       base::FeatureList::IsEnabled(
           features::kFrequencyCappingForLargeStickyAdDetection) &&
-      current_time < last_detection_time_.value() + kFireInterval) {
+      current_time < last_detection_time_.value() + kFireInterval2) {
     return;
   }
 
@@ -127,7 +127,7 @@ void StickyAdDetector::MaybeFireDetection(LocalFrame* outermost_main_frame) {
 
   bool is_large =
       (overlay_rect.size().Area64() > outermost_main_frame_size.Area64() *
-                                          kLargeAdSizeToViewportSizeThreshold);
+                                          kLargeAdSizeToViewportSizeThreshold2);
 
   bool is_main_page_scrollable =
       element->GetDocument().GetLayoutView()->HasScrollableOverflowY();
diff --git a/third_party/blink/renderer/core/html/forms/html_input_element.cc b/third_party/blink/renderer/core/html/forms/html_input_element.cc
index 475a7a583..bc81c05b4 100644
--- a/third_party/blink/renderer/core/html/forms/html_input_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_input_element.cc
@@ -102,7 +102,7 @@ namespace {
 
 const unsigned kMaxEmailFieldLength = 254;
 
-static bool is_default_font_prewarmed_ = false;
+static bool is_default_font_prewarmed_hie = false;
 
 }  // namespace
 
@@ -415,10 +415,10 @@ void HTMLInputElement::InitializeTypeInParsing() {
   // Prewarm the default font family. Do this while parsing because the style
   // recalc calls |TextControlInnerEditorElement::CreateInnerEditorStyle| which
   // needs the primary font.
-  if (!is_default_font_prewarmed_ && new_type_name == input_type_names::kText) {
+  if (!is_default_font_prewarmed_hie && new_type_name == input_type_names::kText) {
     FontCache::PrewarmFamily(LayoutThemeFontProvider::SystemFontFamily(
         CSSValueID::kWebkitSmallControl));
-    is_default_font_prewarmed_ = true;
+    is_default_font_prewarmed_hie = true;
   }
 }
 
diff --git a/third_party/blink/renderer/core/html/forms/html_text_area_element.cc b/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
index e2799c952..4d7c468c8 100644
--- a/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
@@ -67,7 +67,7 @@ namespace blink {
 static const unsigned kDefaultRows = 2;
 static const unsigned kDefaultCols = 20;
 
-static bool is_default_font_prewarmed_ = false;
+static bool is_default_font_prewarmed_htae = false;
 
 static inline unsigned ComputeLengthForAPIValue(const String& text) {
   unsigned length = text.length();
@@ -93,14 +93,14 @@ HTMLTextAreaElement::HTMLTextAreaElement(Document& document)
       is_placeholder_visible_(false) {
   EnsureUserAgentShadowRoot();
 
-  if (!is_default_font_prewarmed_) {
+  if (!is_default_font_prewarmed_htae) {
     if (Settings* settings = document.GetSettings()) {
       // Prewarm 'monospace', the default font family for `<textarea>`. The
       // default language should be fine for this purpose because most users set
       // the same family for all languages.
       FontCache::PrewarmFamily(settings->GetGenericFontFamilySettings().Fixed(
           LayoutLocale::GetDefault().GetScript()));
-      is_default_font_prewarmed_ = true;
+      is_default_font_prewarmed_htae = true;
     }
   }
 }
diff --git a/third_party/blink/renderer/core/html/parser/html_tree_builder.cc b/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
index 0210b7530..5dd7a4e13 100644
--- a/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
+++ b/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
@@ -78,7 +78,7 @@ static TextPosition UninitializedPositionValue1() {
                       OrdinalNumber::First());
 }
 
-static inline bool IsAllWhitespace(const StringView& string_view) {
+static inline bool IsAllWhitespaceHTB(const StringView& string_view) {
   return string_view.IsAllSpecialCharacters<IsHTMLSpace<UChar>>();
 }
 
@@ -2783,7 +2783,7 @@ void HTMLTreeBuilder::DefaultForAfterHead() {
 void HTMLTreeBuilder::DefaultForInTableText() {
   String characters = pending_table_characters_.ToString();
   pending_table_characters_.Clear();
-  if (!IsAllWhitespace(characters)) {
+  if (!IsAllWhitespaceHTB(characters)) {
     // FIXME: parse error
     HTMLConstructionSite::RedirectToFosterParentGuard redirecter(tree_);
     tree_.ReconstructTheActiveFormattingElements();
diff --git a/third_party/blink/renderer/core/html/track/cue_timeline.cc b/third_party/blink/renderer/core/html/track/cue_timeline.cc
index a0acee282..ccad139a8 100644
--- a/third_party/blink/renderer/core/html/track/cue_timeline.cc
+++ b/third_party/blink/renderer/core/html/track/cue_timeline.cc
@@ -358,7 +358,7 @@ void CueTimeline::TimeMarchesOn() {
           is_enter_event ? event_type_names::kEnter : event_type_names::kExit;
       media_element.ScheduleEvent(
           CreateEventWithTarget(event_name, task.second.Get()));
-      if (features::IsTextBasedAudioDescriptionEnabled()) {
+      if (::features::IsTextBasedAudioDescriptionEnabled()) {
         if (is_enter_event) {
           cue->OnEnter(MediaElement());
         } else {
diff --git a/third_party/blink/renderer/core/html/track/text_track.cc b/third_party/blink/renderer/core/html/track/text_track.cc
index e93831d87..3737f2b71 100644
--- a/third_party/blink/renderer/core/html/track/text_track.cc
+++ b/third_party/blink/renderer/core/html/track/text_track.cc
@@ -321,7 +321,7 @@ void TextTrack::InvalidateTrackIndex() {
 }
 
 bool TextTrack::IsRendered() const {
-  if (features::IsTextBasedAudioDescriptionEnabled()) {
+  if (::features::IsTextBasedAudioDescriptionEnabled()) {
     return mode_ == TextTrackMode::kShowing &&
            (IsVisualKind() || IsSpokenKind());
   }
@@ -331,7 +331,7 @@ bool TextTrack::IsRendered() const {
 bool TextTrack::CanBeRendered() const {
   // A track can be displayed when it's of kind captions, subtitles, or
   // descriptions and hasn't failed to load.
-  if (features::IsTextBasedAudioDescriptionEnabled()) {
+  if (::features::IsTextBasedAudioDescriptionEnabled()) {
     return GetReadinessState() != kFailedToLoad &&
            (IsVisualKind() || IsSpokenKind());
   }
diff --git a/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc b/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc
index 6bb17ceef..58a65cdfa 100644
--- a/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc
+++ b/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc
@@ -14,7 +14,7 @@
 
 namespace blink {
 
-constexpr const char* kImageBitmapOptionNone = "none";
+constexpr const char* kImageBitmapOptionNone2 = "none";
 
 ScriptPromise ImageBitmapSource::FulfillImageBitmap(
     ScriptState* script_state,
@@ -31,7 +31,7 @@ ScriptPromise ImageBitmapSource::FulfillImageBitmap(
   // imageOrientation: 'from-image' will be used to replace imageOrientation:
   // 'none'. Adding a deprecation warning when 'none' is called in
   // createImageBitmap.
-  if (options->imageOrientation() == kImageBitmapOptionNone) {
+  if (options->imageOrientation() == kImageBitmapOptionNone2) {
     auto* execution_context =
         ExecutionContext::From(script_state->GetContext());
     Deprecation::CountDeprecation(
diff --git a/third_party/blink/renderer/core/layout/flexible_box_algorithm.cc b/third_party/blink/renderer/core/layout/flexible_box_algorithm.cc
index 94dabe8c2..fed94e161 100644
--- a/third_party/blink/renderer/core/layout/flexible_box_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/flexible_box_algorithm.cc
@@ -87,7 +87,7 @@ FlexItem::FlexItem(const FlexLayoutAlgorithm* algorithm,
                    NGPhysicalBoxStrut physical_margins,
                    NGBoxStrut scrollbars,
                    WritingMode baseline_writing_mode,
-                   BaselineGroup baseline_group,
+                   BaselineGroupType baseline_group,
                    bool depends_on_min_max_sizes)
     : algorithm_(algorithm),
       line_number_(0),
@@ -202,7 +202,7 @@ LayoutUnit FlexItem::MarginBoxAscent(bool is_last_baseline,
   if (is_wrap_reverse != is_last_baseline)
     baseline = baseline_fragment.BlockSize() - baseline;
 
-  return baseline_group_ == BaselineGroup::kMajor
+  return baseline_group_ == BaselineGroupType::kMajor
              ? FlowAwareMarginBefore() + baseline
              : FlowAwareMarginAfter() + baseline;
 }
@@ -583,7 +583,7 @@ void FlexLine::ComputeLineItemsPosition(LayoutUnit main_axis_start_offset,
       LayoutUnit descent =
           (flex_item.CrossAxisMarginExtent() + flex_item.cross_axis_size_) -
           ascent;
-      if (flex_item.baseline_group_ == BaselineGroup::kMajor) {
+      if (flex_item.baseline_group_ == BaselineGroupType::kMajor) {
         max_major_ascent_ = std::max(max_major_ascent_, ascent);
         max_major_descent = std::max(max_major_descent, descent);
         child_cross_axis_margin_box_extent =
@@ -913,7 +913,7 @@ void FlexLayoutAlgorithm::AlignChildren() {
       LayoutUnit baseline_offset;
       if (position == ItemPosition::kBaseline ||
           position == ItemPosition::kLastBaseline) {
-        bool is_major = flex_item.baseline_group_ == BaselineGroup::kMajor;
+        bool is_major = flex_item.baseline_group_ == BaselineGroupType::kMajor;
         LayoutUnit ascent = flex_item.MarginBoxAscent(
             position == ItemPosition::kLastBaseline, is_wrap_reverse);
         LayoutUnit max_ascent = is_major ? line_context.max_major_ascent_
diff --git a/third_party/blink/renderer/core/layout/flexible_box_algorithm.h b/third_party/blink/renderer/core/layout/flexible_box_algorithm.h
index 34695087e..278d27743 100644
--- a/third_party/blink/renderer/core/layout/flexible_box_algorithm.h
+++ b/third_party/blink/renderer/core/layout/flexible_box_algorithm.h
@@ -136,7 +136,7 @@ class FlexItem {
            NGPhysicalBoxStrut physical_margins,
            NGBoxStrut scrollbars,
            WritingMode baseline_writing_mode,
-           BaselineGroup baseline_group = BaselineGroup::kMajor,
+           BaselineGroupType baseline_group = BaselineGroupType::kMajor,
            bool depends_on_min_max_sizes = false);
 
   LayoutUnit HypotheticalMainAxisMarginBoxSize() const {
@@ -211,7 +211,7 @@ class FlexItem {
   NGPhysicalBoxStrut physical_margins_;
   const NGBoxStrut scrollbars_;
   const WritingDirectionMode baseline_writing_direction_;
-  const BaselineGroup baseline_group_;
+  const BaselineGroupType baseline_group_;
 
   LayoutUnit flexed_content_size_;
 
diff --git a/third_party/blink/renderer/core/layout/ng/flex/ng_flex_layout_algorithm.cc b/third_party/blink/renderer/core/layout/ng/flex/ng_flex_layout_algorithm.cc
index d2eb9aca5..e71d054d4 100644
--- a/third_party/blink/renderer/core/layout/ng/flex/ng_flex_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/ng/flex/ng_flex_layout_algorithm.cc
@@ -45,11 +45,11 @@ namespace blink {
 
 namespace {
 
-class BaselineAccumulator {
+class BaselineAccumulatorFlex {
   STACK_ALLOCATED();
 
  public:
-  explicit BaselineAccumulator(const ComputedStyle& style)
+  explicit BaselineAccumulatorFlex(const ComputedStyle& style)
       : font_baseline_(style.GetFontBaseline()) {}
 
   void AccumulateItem(const NGBoxFragment& fragment,
@@ -187,10 +187,10 @@ LayoutUnit NGFlexLayoutAlgorithm::MainAxisContentExtent(
 
 namespace {
 
-enum AxisEdge { kStart, kCenter, kEnd };
+enum class LocalAxisEdge { kStart, kCenter, kEnd };
 
 // Maps the resolved justify-content value to a static-position edge.
-AxisEdge MainAxisStaticPositionEdge(const ComputedStyle& style,
+LocalAxisEdge MainAxisStaticPositionEdge(const ComputedStyle& style,
                                     bool is_column) {
   const StyleContentAlignmentData justify =
       FlexLayoutAlgorithm::ResolvedJustifyContent(style);
@@ -202,23 +202,23 @@ AxisEdge MainAxisStaticPositionEdge(const ComputedStyle& style,
   DCHECK_NE(content_position, ContentPosition::kLeft);
   DCHECK_NE(content_position, ContentPosition::kRight);
   if (content_position == ContentPosition::kFlexEnd)
-    return is_reverse_flex ? AxisEdge::kStart : AxisEdge::kEnd;
+    return is_reverse_flex ? LocalAxisEdge::kStart : LocalAxisEdge::kEnd;
 
   if (content_position == ContentPosition::kCenter ||
       justify.Distribution() == ContentDistributionType::kSpaceAround ||
       justify.Distribution() == ContentDistributionType::kSpaceEvenly)
-    return AxisEdge::kCenter;
+    return LocalAxisEdge::kCenter;
 
   if (content_position == ContentPosition::kStart)
-    return AxisEdge::kStart;
+    return LocalAxisEdge::kStart;
   if (content_position == ContentPosition::kEnd)
-    return AxisEdge::kEnd;
+    return LocalAxisEdge::kEnd;
 
-  return is_reverse_flex ? AxisEdge::kEnd : AxisEdge::kStart;
+  return is_reverse_flex ? LocalAxisEdge::kEnd : LocalAxisEdge::kStart;
 }
 
 // Maps the resolved alignment value to a static-position edge.
-AxisEdge CrossAxisStaticPositionEdge(const ComputedStyle& style,
+LocalAxisEdge CrossAxisStaticPositionEdge(const ComputedStyle& style,
                                      const ComputedStyle& child_style) {
   ItemPosition alignment =
       FlexLayoutAlgorithm::AlignmentForChild(style, child_style);
@@ -226,17 +226,17 @@ AxisEdge CrossAxisStaticPositionEdge(const ComputedStyle& style,
   // kFlexEnd, but not kStretch. kStretch is supposed to act like kFlexStart.
   if (style.FlexWrap() == EFlexWrap::kWrapReverse &&
       alignment == ItemPosition::kStretch) {
-    return AxisEdge::kEnd;
+    return LocalAxisEdge::kEnd;
   }
 
   if (alignment == ItemPosition::kFlexEnd ||
       alignment == ItemPosition::kLastBaseline)
-    return AxisEdge::kEnd;
+    return LocalAxisEdge::kEnd;
 
   if (alignment == ItemPosition::kCenter)
-    return AxisEdge::kCenter;
+    return LocalAxisEdge::kCenter;
 
-  return AxisEdge::kStart;
+  return LocalAxisEdge::kStart;
 }
 
 }  // namespace
@@ -289,8 +289,8 @@ void NGFlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
   for (LayoutBox* oof_child : oofs) {
     NGBlockNode child(oof_child);
 
-    AxisEdge main_axis_edge = MainAxisStaticPositionEdge(Style(), is_column_);
-    AxisEdge cross_axis_edge =
+    LocalAxisEdge main_axis_edge = MainAxisStaticPositionEdge(Style(), is_column_);
+    LocalAxisEdge cross_axis_edge =
         CrossAxisStaticPositionEdge(Style(), child.Style());
 
     // This code block just collects UMA stats.
@@ -321,7 +321,7 @@ void NGFlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
                             WebFeature::kFlexboxNewAbsPos);
         }
       }
-      if (main_axis_edge != AxisEdge::kStart) {
+      if (main_axis_edge != LocalAxisEdge::kStart) {
         const bool are_main_axis_insets_auto =
             is_column_
                 ? insets_in_flexbox_writing_mode.BlockStart().IsAuto() &&
@@ -335,18 +335,18 @@ void NGFlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
       }
     }
 
-    AxisEdge inline_axis_edge = is_column_ ? cross_axis_edge : main_axis_edge;
-    AxisEdge block_axis_edge = is_column_ ? main_axis_edge : cross_axis_edge;
+    LocalAxisEdge inline_axis_edge = is_column_ ? cross_axis_edge : main_axis_edge;
+    LocalAxisEdge block_axis_edge = is_column_ ? main_axis_edge : cross_axis_edge;
 
     InlineEdge inline_edge;
     BlockEdge block_edge;
     LogicalOffset offset = border_scrollbar_padding.StartOffset();
 
     // Determine the static-position based off the axis-edge.
-    if (block_axis_edge == AxisEdge::kStart) {
+    if (block_axis_edge == LocalAxisEdge::kStart) {
       DCHECK(!IsBreakInside(BreakToken()));
       block_edge = BlockEdge::kBlockStart;
-    } else if (block_axis_edge == AxisEdge::kCenter) {
+    } else if (block_axis_edge == LocalAxisEdge::kCenter) {
       if (!should_process_block_center) {
         oof_children.emplace_back(oof_child);
         continue;
@@ -362,9 +362,9 @@ void NGFlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
       offset.block_offset += total_fragment_size.block_size;
     }
 
-    if (inline_axis_edge == AxisEdge::kStart) {
+    if (inline_axis_edge == LocalAxisEdge::kStart) {
       inline_edge = InlineEdge::kInlineStart;
-    } else if (inline_axis_edge == AxisEdge::kCenter) {
+    } else if (inline_axis_edge == LocalAxisEdge::kCenter) {
       inline_edge = InlineEdge::kInlineCenter;
       offset.inline_offset += total_fragment_size.inline_size / 2;
     } else {
@@ -1431,7 +1431,7 @@ NGLayoutResult::EStatus NGFlexLayoutAlgorithm::GiveItemsFinalPositionAndSize(
     }
   }
 
-  BaselineAccumulator baseline_accumulator(Style());
+  BaselineAccumulatorFlex baseline_accumulator(Style());
   NGLayoutResult::EStatus status = NGLayoutResult::kSuccess;
 
   for (wtf_size_t flex_line_idx = 0; flex_line_idx < flex_line_outputs->size();
@@ -1578,7 +1578,7 @@ NGFlexLayoutAlgorithm::GiveItemsFinalPositionAndSizeForFragmentation(
   if (BreakToken())
     previously_consumed_block_size = BreakToken()->ConsumedBlockSize();
 
-  BaselineAccumulator baseline_accumulator(Style());
+  BaselineAccumulatorFlex baseline_accumulator(Style());
   for (auto entry = item_iterator.NextItem(*broke_before_row);
        NGFlexItem* flex_item = entry.flex_item;
        entry = item_iterator.NextItem(*broke_before_row)) {
diff --git a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.cc b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.cc
index 535785221..88d3ca2d7 100644
--- a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.cc
+++ b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.cc
@@ -241,12 +241,12 @@ void GridItemData::SetAlignmentFallback(
   if (!CanParticipateInBaselineAlignment()) {
     const auto baseline_group = BaselineGroup(track_direction);
     if (track_direction == kForColumns) {
-      inline_axis_alignment_fallback = baseline_group == BaselineGroup::kMajor
+      inline_axis_alignment_fallback = baseline_group == BaselineGroupType::kMajor
                                            ? AxisEdge::kStart
                                            : AxisEdge::kEnd;
       is_inline_axis_overflow_safe_fallback = true;
     } else {
-      block_axis_alignment_fallback = baseline_group == BaselineGroup::kMajor
+      block_axis_alignment_fallback = baseline_group == BaselineGroupType::kMajor
                                           ? AxisEdge::kStart
                                           : AxisEdge::kEnd;
       is_block_axis_overflow_safe_fallback = true;
diff --git a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.h b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.h
index c331808b7..927a5b423 100644
--- a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.h
+++ b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_item.h
@@ -94,7 +94,7 @@ struct CORE_EXPORT GridItemData {
       const NGGridPlacementData& placement_data,
       const ComputedStyle& grid_style);
 
-  enum BaselineGroup BaselineGroup(
+  enum BaselineGroupType BaselineGroup(
       GridTrackSizingDirection track_direction) const {
     return (track_direction == kForColumns) ? column_baseline_group
                                             : row_baseline_group;
@@ -213,8 +213,8 @@ struct CORE_EXPORT GridItemData {
   NGAutoBehavior inline_auto_behavior;
   NGAutoBehavior block_auto_behavior;
 
-  enum BaselineGroup column_baseline_group;
-  enum BaselineGroup row_baseline_group;
+  enum BaselineGroupType column_baseline_group;
+  enum BaselineGroupType row_baseline_group;
 
   WritingMode column_baseline_writing_mode;
   WritingMode row_baseline_writing_mode;
diff --git a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
index feca36f0e..268492cfd 100644
--- a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
@@ -692,13 +692,13 @@ LayoutUnit NGGridLayoutAlgorithm::Baseline(
   //  alignment context along that axis"
   // https://www.w3.org/TR/css-align-3/#baseline-sharing-group
   if (track_direction == kForColumns) {
-    return (grid_item.column_baseline_group == BaselineGroup::kMajor)
+    return (grid_item.column_baseline_group == BaselineGroupType::kMajor)
                ? layout_data.Columns().MajorBaseline(
                      grid_item.column_set_indices.begin)
                : layout_data.Columns().MinorBaseline(
                      grid_item.column_set_indices.end - 1);
   } else {
-    return (grid_item.row_baseline_group == BaselineGroup::kMajor)
+    return (grid_item.row_baseline_group == BaselineGroupType::kMajor)
                ? layout_data.Rows().MajorBaseline(
                      grid_item.row_set_indices.begin)
                : layout_data.Rows().MinorBaseline(
@@ -1487,7 +1487,7 @@ void NGGridLayoutAlgorithm::CalculateAlignmentBaselines(
     //  in first/last baseline alignment within its start-most/end-most shared
     //  alignment context along that axis"
     // https://www.w3.org/TR/css-align-3/#baseline-sharing-group
-    if (grid_item.BaselineGroup(track_direction) == BaselineGroup::kMajor) {
+    if (grid_item.BaselineGroup(track_direction) == BaselineGroupType::kMajor) {
       track_collection->SetMajorBaseline(
           grid_item.SetIndices(track_direction).begin, baseline);
     } else {
@@ -2893,11 +2893,11 @@ namespace {
 // opposed to DOM order). The baseline of the grid is determined by the first
 // grid item with baseline alignment in the first row. If no items have
 // baseline alignment, fall back to the first item in row-major order.
-class BaselineAccumulator {
+class BaselineAccumulatorGrid {
   STACK_ALLOCATED();
 
  public:
-  explicit BaselineAccumulator(FontBaseline font_baseline)
+  explicit BaselineAccumulatorGrid(FontBaseline font_baseline)
       : font_baseline_(font_baseline) {}
 
   void Accumulate(const GridItemData& grid_item,
@@ -3041,7 +3041,7 @@ void NGGridLayoutAlgorithm::PlaceGridItems(
         layout_data.Rows().GetSetCount() + 1, EBreakBetween::kAuto);
   }
 
-  BaselineAccumulator baseline_accumulator(Style().GetFontBaseline());
+  BaselineAccumulatorGrid baseline_accumulator(Style().GetFontBaseline());
 
   for (const auto& grid_item : grid_items) {
     LogicalRect containing_grid_area;
@@ -3071,7 +3071,7 @@ void NGGridLayoutAlgorithm::PlaceGridItems(
           GetLogicalBaseline(
               baseline_fragment,
               grid_item.IsLastBaselineSpecifiedForDirection(track_direction));
-      if (grid_item.BaselineGroup(track_direction) == BaselineGroup::kMajor)
+      if (grid_item.BaselineGroup(track_direction) == BaselineGroupType::kMajor)
         return baseline_delta;
 
       // BaselineGroup::kMinor
@@ -3239,7 +3239,7 @@ void NGGridLayoutAlgorithm::PlaceGridItemsForFragmentation(
 
   HeapVector<ResultAndOffsets> result_and_offsets;
   HeapVector<GridItemPlacementData*> out_of_fragmentainer_space_item_placement;
-  BaselineAccumulator baseline_accumulator(Style().GetFontBaseline());
+  BaselineAccumulatorGrid baseline_accumulator(Style().GetFontBaseline());
   LayoutUnit max_row_expansion;
   wtf_size_t expansion_row_set_index;
   wtf_size_t breakpoint_row_set_index;
@@ -3265,7 +3265,7 @@ void NGGridLayoutAlgorithm::PlaceGridItemsForFragmentation(
     // Reset our state.
     result_and_offsets.clear();
     out_of_fragmentainer_space_item_placement.clear();
-    baseline_accumulator = BaselineAccumulator(Style().GetFontBaseline());
+    baseline_accumulator = BaselineAccumulatorGrid(Style().GetFontBaseline());
     max_row_expansion = LayoutUnit();
     expansion_row_set_index = kNotFound;
     breakpoint_row_set_index = kNotFound;
diff --git a/third_party/blink/renderer/core/layout/ng/mathml/ng_math_scripts_layout_algorithm.cc b/third_party/blink/renderer/core/layout/ng/mathml/ng_math_scripts_layout_algorithm.cc
index 624faa207..be8ae12f6 100644
--- a/third_party/blink/renderer/core/layout/ng/mathml/ng_math_scripts_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/ng/mathml/ng_math_scripts_layout_algorithm.cc
@@ -15,7 +15,7 @@ namespace {
 
 using MathConstants = OpenTypeMathSupport::MathConstants;
 
-static bool IsPrescriptDelimiter(const NGBlockNode& blockNode) {
+bool MyIsPrescriptDelimiter(const NGBlockNode& blockNode) {
   auto* node = blockNode.GetDOMNode();
   return node && IsA<MathMLElement>(node) &&
          node->HasTagName(mathml_names::kMprescriptsTag);
@@ -147,7 +147,7 @@ void NGMathScriptsLayoutAlgorithm::GatherChildren(
       case MathScriptType::kMultiscripts: {
         // The structure of mmultiscripts is specified here:
         // https://w3c.github.io/mathml-core/#prescripts-and-tensor-indices-mmultiscripts
-        if (IsPrescriptDelimiter(block_child)) {
+        if (MyIsPrescriptDelimiter(block_child)) {
           if (!number_of_scripts_is_even || *prescripts) {
             NOTREACHED();
             return;
diff --git a/third_party/blink/renderer/core/layout/ng/ng_baseline_utils.h b/third_party/blink/renderer/core/layout/ng/ng_baseline_utils.h
index 252a3c761..99f7a5275 100644
--- a/third_party/blink/renderer/core/layout/ng/ng_baseline_utils.h
+++ b/third_party/blink/renderer/core/layout/ng/ng_baseline_utils.h
@@ -9,7 +9,7 @@
 
 namespace blink {
 
-enum class BaselineGroup { kMajor, kMinor };
+enum class BaselineGroupType { kMajor, kMinor };
 
 // Determines the writing-mode to read a baseline from a fragment.
 inline WritingMode DetermineBaselineWritingMode(
@@ -48,7 +48,7 @@ inline WritingMode DetermineBaselineWritingMode(
 //
 // We label these "major"/"minor" to separate them. The "major" group should be
 // aligned to the appropriate "start" axis.
-inline BaselineGroup DetermineBaselineGroup(
+inline BaselineGroupType DetermineBaselineGroup(
     const WritingDirectionMode container_writing_direction,
     const WritingMode baseline_writing_mode,
     bool is_parallel_context,
@@ -57,8 +57,8 @@ inline BaselineGroup DetermineBaselineGroup(
   const auto container_writing_mode =
       container_writing_direction.GetWritingMode();
 
-  auto start_group = BaselineGroup::kMajor;
-  auto end_group = BaselineGroup::kMinor;
+  auto start_group = BaselineGroupType::kMajor;
+  auto end_group = BaselineGroupType::kMinor;
   if (is_last_baseline)
     std::swap(start_group, end_group);
   if (is_flipped)
@@ -86,7 +86,7 @@ inline BaselineGroup DetermineBaselineGroup(
   }
 
   NOTREACHED();
-  return BaselineGroup::kMinor;
+  return BaselineGroupType::kMinor;
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/page/drag_image.cc b/third_party/blink/renderer/core/page/drag_image.cc
index d4be264a7..92a0f5372 100644
--- a/third_party/blink/renderer/core/page/drag_image.cc
+++ b/third_party/blink/renderer/core/page/drag_image.cc
@@ -53,6 +53,9 @@
 #include "ui/gfx/geometry/point_f.h"
 #include "ui/gfx/geometry/rect_f.h"
 
+// To avoid conflicts with the DrawText macro from the Windows SDK...
+#undef DrawText
+
 namespace blink {
 
 namespace {
diff --git a/third_party/blink/renderer/core/paint/ng/ng_highlight_painter.cc b/third_party/blink/renderer/core/paint/ng/ng_highlight_painter.cc
index ef4e16c90..cf52e521b 100644
--- a/third_party/blink/renderer/core/paint/ng/ng_highlight_painter.cc
+++ b/third_party/blink/renderer/core/paint/ng/ng_highlight_painter.cc
@@ -63,7 +63,7 @@ DocumentMarkerVector MarkersFor(Node* node, DocumentMarker::MarkerType type) {
   return controller.MarkersFor(*text_node, DocumentMarker::MarkerTypes{type});
 }
 
-unsigned GetTextContentOffset(const Text& text, unsigned offset) {
+unsigned GetTextContentOffset2(const Text& text, unsigned offset) {
   // TODO(yoichio): Sanitize DocumentMarker around text length.
   const Position position(text, std::min(offset, text.length()));
   const NGOffsetMapping* const offset_mapping =
@@ -607,9 +607,9 @@ void NGHighlightPainter::Paint(Phase phase) {
 
   for (const DocumentMarker* marker : markers_) {
     const unsigned marker_start_offset =
-        GetTextContentOffset(text_node, marker->StartOffset());
+        GetTextContentOffset2(text_node, marker->StartOffset());
     const unsigned marker_end_offset =
-        GetTextContentOffset(text_node, marker->EndOffset());
+        GetTextContentOffset2(text_node, marker->EndOffset());
     const unsigned paint_start_offset =
         ClampOffset(marker_start_offset, fragment_item_);
     const unsigned paint_end_offset =
@@ -842,9 +842,9 @@ void NGHighlightPainter::FastPaintSpellingGrammarDecorations(
     const DocumentMarkerVector& markers) {
   for (const DocumentMarker* marker : markers) {
     const unsigned marker_start_offset =
-        GetTextContentOffset(text_node, marker->StartOffset());
+        GetTextContentOffset2(text_node, marker->StartOffset());
     const unsigned marker_end_offset =
-        GetTextContentOffset(text_node, marker->EndOffset());
+        GetTextContentOffset2(text_node, marker->EndOffset());
     const unsigned paint_start_offset =
         ClampOffset(marker_start_offset, fragment_item_);
     const unsigned paint_end_offset =
@@ -995,9 +995,9 @@ void NGHighlightPainter::PaintHighlightOverlays(
       }
 
       const unsigned content_start =
-          GetTextContentOffset(*text_node, marker->StartOffset());
+          GetTextContentOffset2(*text_node, marker->StartOffset());
       const unsigned content_end =
-          GetTextContentOffset(*text_node, marker->EndOffset());
+          GetTextContentOffset2(*text_node, marker->EndOffset());
       const unsigned clamped_start = ClampOffset(content_start, fragment_item_);
       const unsigned clamped_end = ClampOffset(content_end, fragment_item_);
       const unsigned length = clamped_end - clamped_start;
diff --git a/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc b/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
index 9de1b3087..1cb167945 100644
--- a/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
+++ b/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
@@ -33,7 +33,7 @@ namespace blink {
 
 namespace {
 
-bool IsLinkHighlighted(const LayoutObject& object) {
+bool IsLinkHighlightedPPTW(const LayoutObject& object) {
   return object.GetFrame()->GetPage()->GetLinkHighlight().IsHighlighting(
       object);
 }
@@ -421,7 +421,7 @@ FragmentData* PrePaintTreeWalk::GetOrCreateFragmentData(
       // is the highlighted link (in which case even culled inlines get paint
       // effects).
       if (!object.IsBox() && !object.HasInlineFragments() &&
-          !IsLinkHighlighted(object))
+          !IsLinkHighlightedPPTW(object))
         return nullptr;
 
       DCHECK(allow_update);
diff --git a/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc b/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc
index c0087c50c..f5d0e7307 100644
--- a/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc
+++ b/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc
@@ -53,7 +53,7 @@ bool IsValidBrowsingContextNameOrKeyword(const String& name_or_keyword) {
 
 // If `out_error` is provided and hasn't already had a message set, sets it to
 // `message`.
-void SetParseErrorMessage(String* out_error, String message) {
+void SetParseErrorMessage2(String* out_error, String message) {
   if (out_error && out_error->IsNull()) {
     *out_error = message;
   }
@@ -85,7 +85,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     const String& input_key = input->at(i).first;
     if (!base::Contains(kKnownKeys, input_key) &&
         !base::Contains(kConditionalKnownKeys, input_key)) {
-      SetParseErrorMessage(
+      SetParseErrorMessage2(
           out_error, "A rule contains an unknown key: \"" + input_key + "\".");
       return nullptr;
     }
@@ -101,11 +101,11 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
   // string "document", then return null.
   String source;
   if (!input->GetString("source", &source)) {
-    SetParseErrorMessage(out_error, "A rule must have a source.");
+    SetParseErrorMessage2(out_error, "A rule must have a source.");
     return nullptr;
   }
   if (!(source == "list" || (document_rules_enabled && source == "document"))) {
-    SetParseErrorMessage(out_error,
+    SetParseErrorMessage2(out_error,
                          "A rule has an unknown source: \"" + source + "\".");
     return nullptr;
   }
@@ -114,7 +114,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
   if (source == "list") {
     // If input["where"] exists, then return null.
     if (input->Get("where")) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A list rule may not have document rule matchers.");
       return nullptr;
     }
@@ -129,7 +129,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
       // "document", then return null.
       if (!relative_to_enabled || !relative_to->AsString(&value) ||
           !base::Contains(kKnownRelativeToValues, value)) {
-        SetParseErrorMessage(out_error,
+        SetParseErrorMessage2(out_error,
                              "A rule has an unknown \"relative_to\" value.");
         return nullptr;
       }
@@ -145,7 +145,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     // is not a string, then return null.
     JSONArray* input_urls = input->GetArray("urls");
     if (!input_urls) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A list rule must have a \"urls\" array.");
       return nullptr;
     }
@@ -155,7 +155,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     for (wtf_size_t i = 0; i < input_urls->size(); ++i) {
       String url_string;
       if (!input_urls->at(i)->AsString(&url_string)) {
-        SetParseErrorMessage(out_error, "URLs must be given as strings.");
+        SetParseErrorMessage2(out_error, "URLs must be given as strings.");
         return nullptr;
       }
 
@@ -174,7 +174,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     DCHECK(document_rules_enabled);
     // If input["urls"] exists, then return null.
     if (input->Get("urls")) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A document rule cannot have a \"urls\" key.");
       return nullptr;
     }
@@ -182,7 +182,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     // "relative_to" outside the "href_matches" clause is not allowed for
     // document rules.
     if (input->Get("relative_to")) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A document rule cannot have \"relative_to\" "
                            "outside the \"where\" clause.");
       return nullptr;
@@ -208,7 +208,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
   // If input["requires"] exists, but is not a list, then return null.
   JSONValue* requirements = input->Get("requires");
   if (requirements && requirements->GetType() != JSONValue::kTypeArray) {
-    SetParseErrorMessage(out_error, "\"requires\" must be an array.");
+    SetParseErrorMessage2(out_error, "\"requires\" must be an array.");
     return nullptr;
   }
 
@@ -219,7 +219,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     for (wtf_size_t i = 0; i < requirements_array->size(); ++i) {
       String requirement;
       if (!requirements_array->at(i)->AsString(&requirement)) {
-        SetParseErrorMessage(out_error, "Requirements must be strings.");
+        SetParseErrorMessage2(out_error, "Requirements must be strings.");
         return nullptr;
       }
 
@@ -227,7 +227,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
         requires_anonymous_client_ip =
             SpeculationRule::RequiresAnonymousClientIPWhenCrossOrigin(true);
       } else {
-        SetParseErrorMessage(
+        SetParseErrorMessage2(
             out_error,
             "A rule has an unknown requirement: \"" + requirement + "\".");
         return nullptr;
@@ -246,11 +246,11 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     // Set targetHint to input["target_hint"].
     String target_hint_str;
     if (!target_hint_value->AsString(&target_hint_str)) {
-      SetParseErrorMessage(out_error, "\"target_hint\" must be a string.");
+      SetParseErrorMessage2(out_error, "\"target_hint\" must be a string.");
       return nullptr;
     }
     if (!IsValidBrowsingContextNameOrKeyword(target_hint_str)) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A rule has an invalid \"target_hint\": \"" +
                                target_hint_str + "\".");
       return nullptr;
@@ -276,7 +276,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
 
     String referrer_policy_str;
     if (!referrer_policy_value->AsString(&referrer_policy_str)) {
-      SetParseErrorMessage(out_error, "A referrer policy must be a string.");
+      SetParseErrorMessage2(out_error, "A referrer policy must be a string.");
       return nullptr;
     }
 
@@ -286,7 +286,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
       if (!SecurityPolicy::ReferrerPolicyFromString(
               referrer_policy_str, kDoNotSupportReferrerPolicyLegacyKeywords,
               &referrer_policy_out)) {
-        SetParseErrorMessage(out_error,
+        SetParseErrorMessage2(out_error,
                              "A rule has an invalid referrer policy: \"" +
                                  referrer_policy_str + "\".");
         return nullptr;
@@ -303,7 +303,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
 
     String eagerness_str;
     if (!eagerness_value->AsString(&eagerness_str)) {
-      SetParseErrorMessage(out_error, "Eagerness value must be a string.");
+      SetParseErrorMessage2(out_error, "Eagerness value must be a string.");
       return nullptr;
     }
 
@@ -314,7 +314,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     } else if (eagerness_str == "conservative") {
       eagerness = mojom::blink::SpeculationEagerness::kConservative;
     } else {
-      SetParseErrorMessage(
+      SetParseErrorMessage2(
           out_error, "Eagerness value: \"" + eagerness_str + "\" is invalid.");
       return nullptr;
     }
@@ -389,7 +389,7 @@ SpeculationRuleSet* SpeculationRuleSet::Parse(Source* source,
 
   // If parsed is not a map, then return null.
   if (!parsed) {
-    SetParseErrorMessage(out_error,
+    SetParseErrorMessage2(out_error,
                          parse_error.type != JSONParseErrorType::kNoError
                              ? parse_error.message
                              : "Parsed JSON must be an object.");
@@ -412,7 +412,7 @@ SpeculationRuleSet* SpeculationRuleSet::Parse(Source* source,
           // If prefetch/prerenderRule is not a map, then continue.
           JSONObject* input_rule = JSONObject::Cast(array->at(i));
           if (!input_rule) {
-            SetParseErrorMessage(out_error, "A rule must be an object.");
+            SetParseErrorMessage2(out_error, "A rule must be an object.");
             continue;
           }
 
@@ -429,7 +429,7 @@ SpeculationRuleSet* SpeculationRuleSet::Parse(Source* source,
           // continue.
           if (!allow_target_hint &&
               rule->target_browsing_context_name_hint().has_value()) {
-            SetParseErrorMessage(
+            SetParseErrorMessage2(
                 out_error, "\"target_hint\" may not be set for " + String(key) +
                                " rules.");
             continue;
diff --git a/third_party/blink/renderer/core/timing/performance_timing.cc b/third_party/blink/renderer/core/timing/performance_timing.cc
index 3e35c36b1..cc909e28d 100644
--- a/third_party/blink/renderer/core/timing/performance_timing.cc
+++ b/third_party/blink/renderer/core/timing/performance_timing.cc
@@ -25,7 +25,7 @@
 // Legacy support for NT1(https://www.w3.org/TR/navigation-timing/).
 namespace blink {
 
-static uint64_t ToIntegerMilliseconds(base::TimeDelta duration,
+static uint64_t ToIntegerMilliseconds2(base::TimeDelta duration,
                                       bool cross_origin_isolated_capability) {
   // TODO(npm): add histograms to understand when/why |duration| is sometimes
   // negative.
@@ -345,8 +345,8 @@ uint64_t PerformanceTiming::MonotonicTimeToIntegerMilliseconds(
   if (!timing)
     return 0;
 
-  return ToIntegerMilliseconds(timing->MonotonicTimeToPseudoWallTime(time),
-                               cross_origin_isolated_capability_);
+  return ToIntegerMilliseconds2(timing->MonotonicTimeToPseudoWallTime(time),
+                                cross_origin_isolated_capability_);
 }
 
 // static
diff --git a/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc b/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc
index 48bbff80c..2dedfd18b 100644
--- a/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc
+++ b/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc
@@ -18,7 +18,7 @@ std::unique_ptr<AXProperty> CreateProperty(const String& name,
   return AXProperty::create().setName(name).setValue(std::move(value)).build();
 }
 
-String IgnoredReasonName(AXIgnoredReason reason) {
+static String IgnoredReasonName_ITBH(AXIgnoredReason reason) {
   switch (reason) {
     case kAXActiveFullscreenElement:
       return "activeFullscreenElement";
@@ -60,10 +60,10 @@ String IgnoredReasonName(AXIgnoredReason reason) {
 std::unique_ptr<AXProperty> CreateProperty(IgnoredReason reason) {
   if (reason.related_object)
     return CreateProperty(
-        IgnoredReasonName(reason.reason),
+        IgnoredReasonName_ITBH(reason.reason),
         CreateRelatedNodeListValue(*(reason.related_object), nullptr,
                                    AXValueTypeEnum::Idref));
-  return CreateProperty(IgnoredReasonName(reason.reason),
+  return CreateProperty(IgnoredReasonName_ITBH(reason.reason),
                         CreateBooleanValue(true));
 }
 
diff --git a/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc b/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc
index 18baec1da..e40ea6b14 100644
--- a/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc
+++ b/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc
@@ -27,7 +27,7 @@
 namespace blink {
 
 const char kAbortErrorMessage[] = "The Bluetooth operation was cancelled.";
-const char kInactiveDocumentError[] = "Document not active";
+const char kInactiveDocumentError2[] = "Document not active";
 const char kInvalidStateErrorMessage[] =
     "Pending watch advertisements operation.";
 
@@ -113,7 +113,7 @@ ScriptPromise BluetoothDevice::watchAdvertisements(
     ExceptionState& exception_state) {
   ExecutionContext* context = GetExecutionContext();
   if (!context) {
-    exception_state.ThrowTypeError(kInactiveDocumentError);
+    exception_state.ThrowTypeError(kInactiveDocumentError2);
     return ScriptPromise();
   }
 
@@ -204,7 +204,7 @@ void BluetoothDevice::AbortWatchAdvertisements(AbortSignal* signal) {
 ScriptPromise BluetoothDevice::forget(ScriptState* script_state,
                                       ExceptionState& exception_state) {
   if (!GetExecutionContext()) {
-    exception_state.ThrowTypeError(kInactiveDocumentError);
+    exception_state.ThrowTypeError(kInactiveDocumentError2);
     return ScriptPromise();
   }
 
diff --git a/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc b/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc
index f9f383bf5..d2f08a988 100644
--- a/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc
+++ b/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc
@@ -37,9 +37,9 @@ BASE_FEATURE(kBreakoutBoxEagerConversion,
 #endif
 );
 
-class TransferringOptimizer : public WritableStreamTransferringOptimizer {
+class TransferringOptimizerMSVTUS : public WritableStreamTransferringOptimizer {
  public:
-  explicit TransferringOptimizer(
+  explicit TransferringOptimizerMSVTUS(
       scoped_refptr<PushableMediaStreamVideoSource::Broker> source_broker)
       : source_broker_(std::move(source_broker)) {}
   UnderlyingSinkBase* PerformInProcessOptimization(
@@ -145,7 +145,7 @@ ScriptPromise MediaStreamVideoTrackUnderlyingSink::close(
 std::unique_ptr<WritableStreamTransferringOptimizer>
 MediaStreamVideoTrackUnderlyingSink::GetTransferringOptimizer() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  return std::make_unique<TransferringOptimizer>(source_broker_);
+  return std::make_unique<TransferringOptimizerMSVTUS>(source_broker_);
 }
 
 void MediaStreamVideoTrackUnderlyingSink::Disconnect() {
diff --git a/third_party/blink/renderer/modules/canvas/BUILD.gn b/third_party/blink/renderer/modules/canvas/BUILD.gn
index cc8359ffa..9ca8ad525 100644
--- a/third_party/blink/renderer/modules/canvas/BUILD.gn
+++ b/third_party/blink/renderer/modules/canvas/BUILD.gn
@@ -53,6 +53,10 @@ blink_modules_sources("canvas") {
     "offscreencanvas2d/offscreen_canvas_rendering_context_2d.h",
     "testing/canvas_test_utils.cc",
   ]
+  jumbo_excluded_sources = [
+    "imagebitmap/image_bitmap_rendering_context_base.cc",
+    "offscreencanvas2d/offscreen_canvas_rendering_context_2d.cc",
+  ]
 
   deps = [
     "//third_party/blink/renderer/modules/formatted_text",
diff --git a/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc b/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc
index aa578c429..f0b81e9f5 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc
@@ -599,7 +599,7 @@ void OnGetComplete(std::unique_ptr<ScopedPromiseResolver> scoped_resolver,
   resolver->Resolve(mojo::ConvertTo<Credential*>(std::move(credential_info)));
 }
 
-DOMArrayBuffer* VectorToDOMArrayBuffer(const Vector<uint8_t> buffer) {
+static DOMArrayBuffer* VectorToDOMArrayBuffer_CC(const Vector<uint8_t> buffer) {
   return DOMArrayBuffer::Create(static_cast<const void*>(buffer.data()),
                                 buffer.size());
 }
@@ -653,17 +653,17 @@ void OnMakePublicKeyCredentialComplete(
                       WebFeature::kWebAuthnRkRequiredCreationSuccess);
   }
   DOMArrayBuffer* client_data_buffer =
-      VectorToDOMArrayBuffer(std::move(credential->info->client_data_json));
+      VectorToDOMArrayBuffer_CC(std::move(credential->info->client_data_json));
   DOMArrayBuffer* raw_id =
-      VectorToDOMArrayBuffer(std::move(credential->info->raw_id));
+      VectorToDOMArrayBuffer_CC(std::move(credential->info->raw_id));
   DOMArrayBuffer* attestation_buffer =
-      VectorToDOMArrayBuffer(std::move(credential->attestation_object));
+      VectorToDOMArrayBuffer_CC(std::move(credential->attestation_object));
   DOMArrayBuffer* authenticator_data =
-      VectorToDOMArrayBuffer(std::move(credential->info->authenticator_data));
+      VectorToDOMArrayBuffer_CC(std::move(credential->info->authenticator_data));
   DOMArrayBuffer* public_key_der = nullptr;
   if (credential->public_key_der) {
     public_key_der =
-        VectorToDOMArrayBuffer(std::move(credential->public_key_der.value()));
+        VectorToDOMArrayBuffer_CC(std::move(credential->public_key_der.value()));
   }
   auto* authenticator_response =
       MakeGarbageCollected<AuthenticatorAttestationResponse>(
@@ -697,9 +697,9 @@ void OnMakePublicKeyCredentialComplete(
   if (credential->device_public_key) {
     AuthenticationExtensionsDevicePublicKeyOutputs* device_public_key_outputs =
         AuthenticationExtensionsDevicePublicKeyOutputs::Create();
-    device_public_key_outputs->setAuthenticatorOutput(VectorToDOMArrayBuffer(
+    device_public_key_outputs->setAuthenticatorOutput(VectorToDOMArrayBuffer_CC(
         std::move(credential->device_public_key->authenticator_output)));
-    device_public_key_outputs->setSignature(VectorToDOMArrayBuffer(
+    device_public_key_outputs->setSignature(VectorToDOMArrayBuffer_CC(
         std::move(credential->device_public_key->signature)));
     extension_outputs->setDevicePubKey(device_public_key_outputs);
   }
@@ -830,7 +830,7 @@ void OnGetAssertionComplete(
           AuthenticationExtensionsLargeBlobOutputs::Create();
       if (credential->large_blob) {
         large_blob_outputs->setBlob(
-            VectorToDOMArrayBuffer(std::move(*credential->large_blob)));
+            VectorToDOMArrayBuffer_CC(std::move(*credential->large_blob)));
       }
       if (credential->echo_large_blob_written) {
         large_blob_outputs->setWritten(credential->large_blob_written);
@@ -839,15 +839,15 @@ void OnGetAssertionComplete(
     }
     if (credential->get_cred_blob) {
       extension_outputs->setGetCredBlob(
-          VectorToDOMArrayBuffer(std::move(*credential->get_cred_blob)));
+          VectorToDOMArrayBuffer_CC(std::move(*credential->get_cred_blob)));
     }
     if (credential->device_public_key) {
       AuthenticationExtensionsDevicePublicKeyOutputs*
           device_public_key_outputs =
               AuthenticationExtensionsDevicePublicKeyOutputs::Create();
-      device_public_key_outputs->setAuthenticatorOutput(VectorToDOMArrayBuffer(
+      device_public_key_outputs->setAuthenticatorOutput(VectorToDOMArrayBuffer_CC(
           std::move(credential->device_public_key->authenticator_output)));
-      device_public_key_outputs->setSignature(VectorToDOMArrayBuffer(
+      device_public_key_outputs->setSignature(VectorToDOMArrayBuffer_CC(
           std::move(credential->device_public_key->signature)));
       extension_outputs->setDevicePubKey(device_public_key_outputs);
     }
@@ -856,9 +856,9 @@ void OnGetAssertionComplete(
       if (credential->prf_results) {
         auto* values = AuthenticationExtensionsPRFValues::Create();
         values->setFirst(
-            VectorToDOMArrayBuffer(std::move(credential->prf_results->first)));
+            VectorToDOMArrayBuffer_CC(std::move(credential->prf_results->first)));
         if (credential->prf_results->second) {
-          values->setSecond(VectorToDOMArrayBuffer(
+          values->setSecond(VectorToDOMArrayBuffer_CC(
               std::move(credential->prf_results->second.value())));
         }
         prf_outputs->setResults(values);
@@ -867,7 +867,7 @@ void OnGetAssertionComplete(
     }
     resolver->Resolve(MakeGarbageCollected<PublicKeyCredential>(
         credential->info->id,
-        VectorToDOMArrayBuffer(std::move(credential->info->raw_id)),
+        VectorToDOMArrayBuffer_CC(std::move(credential->info->raw_id)),
         authenticator_response, credential->authenticator_attachment,
         extension_outputs));
     return;
diff --git a/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc b/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc
index 3e2b1812d..e2e86c10a 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc
@@ -19,7 +19,7 @@
 namespace blink {
 
 namespace {
-constexpr char kFederatedCredentialType[] = "federated";
+constexpr char kFederatedCredentialTypeFC[] = "federated";
 }  // namespace
 
 FederatedCredential* FederatedCredential::Create(
@@ -67,7 +67,7 @@ FederatedCredential::FederatedCredential(
     scoped_refptr<const SecurityOrigin> provider_origin,
     const String& name,
     const KURL& icon_url)
-    : Credential(id, kFederatedCredentialType),
+    : Credential(id, kFederatedCredentialTypeFC),
       provider_origin_(provider_origin),
       name_(name),
       icon_url_(icon_url) {
diff --git a/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc b/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc
index f9c13a814..f98229752 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc
@@ -21,7 +21,7 @@ namespace {
 using mojom::blink::LogoutRpsStatus;
 using mojom::blink::RequestTokenStatus;
 
-constexpr char kIdentityCredentialType[] = "identity";
+constexpr char kIdentityCredentialType2[] = "identity";
 
 // These values are persisted to logs. Entries should not be renumbered and
 // numeric values should never be reused.
@@ -88,7 +88,7 @@ bool IdentityCredential::IsRejectingPromiseDueToCSP(
 }
 
 IdentityCredential::IdentityCredential(const String& token)
-    : Credential(/* id = */ "", kIdentityCredentialType), token_(token) {}
+    : Credential(/* id = */ "", kIdentityCredentialType2), token_(token) {}
 
 bool IdentityCredential::IsIdentityCredential() const {
   return true;
diff --git a/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc b/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc
index 517ef6eb1..dd11eef62 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc
@@ -9,12 +9,12 @@
 
 namespace blink {
 
-namespace {
-constexpr char kOtpCredentialType[] = "otp";
+namespace i {
+constexpr static char kOtpCredentialType[] = "otp";
 }
 
 OTPCredential::OTPCredential(const String& code)
-    : Credential(String(), kOtpCredentialType), code_(code) {}
+    : Credential(String(), i::kOtpCredentialType), code_(code) {}
 
 bool OTPCredential::IsOTPCredential() const {
   return true;
diff --git a/third_party/blink/renderer/modules/hid/hid_device.cc b/third_party/blink/renderer/modules/hid/hid_device.cc
index 544b39df2..559b76731 100644
--- a/third_party/blink/renderer/modules/hid/hid_device.cc
+++ b/third_party/blink/renderer/modules/hid/hid_device.cc
@@ -34,7 +34,7 @@ const char kReceiveFeatureReportFailed[] =
 const char kUnexpectedClose[] = "The device was closed unexpectedly.";
 const char kArrayBufferTooBig[] =
     "The provided ArrayBuffer exceeds the maximum allowed size.";
-const char kContextGone[] = "Script context has shut down.";
+const char kContextGone2[] = "Script context has shut down.";
 
 bool IsProtected(
     const device::mojom::blink::HidUsageAndPage& hid_usage_and_page) {
@@ -248,7 +248,7 @@ ScriptPromise HIDDevice::open(ScriptState* script_state,
                               ExceptionState& exception_state) {
   if (!GetExecutionContext()) {
     exception_state.ThrowDOMException(DOMExceptionCode::kNotSupportedError,
-                                      kContextGone);
+                                      kContextGone2);
     return ScriptPromise();
   }
 
@@ -298,7 +298,7 @@ ScriptPromise HIDDevice::forget(ScriptState* script_state,
                                 ExceptionState& exception_state) {
   if (!GetExecutionContext()) {
     exception_state.ThrowDOMException(DOMExceptionCode::kNotSupportedError,
-                                      kContextGone);
+                                      kContextGone2);
     return ScriptPromise();
   }
 
diff --git a/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc b/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc
index 0aac5f9eb..4253f3280 100644
--- a/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc
@@ -122,15 +122,15 @@ void H264Encoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
   picture.iColorFormat = EVideoFormatType::videoFormatI420;
   picture.uiTimeStamp =
       (capture_timestamp - first_frame_timestamp_).InMilliseconds();
-  picture.iStride[0] = frame->stride(VideoFrame::kYPlane);
-  picture.iStride[1] = frame->stride(VideoFrame::kUPlane);
-  picture.iStride[2] = frame->stride(VideoFrame::kVPlane);
+  picture.iStride[0] = frame->stride(media::VideoFrame::kYPlane);
+  picture.iStride[1] = frame->stride(media::VideoFrame::kUPlane);
+  picture.iStride[2] = frame->stride(media::VideoFrame::kVPlane);
   picture.pData[0] =
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::kYPlane));
+      const_cast<uint8_t*>(frame->visible_data(media::VideoFrame::kYPlane));
   picture.pData[1] =
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::kUPlane));
+      const_cast<uint8_t*>(frame->visible_data(media::VideoFrame::kUPlane));
   picture.pData[2] =
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::kVPlane));
+      const_cast<uint8_t*>(frame->visible_data(media::VideoFrame::kVPlane));
 
   SFrameBSInfo info = {};
   if (openh264_encoder_->EncodeFrame(&picture, &info) != cmResultSuccess) {
diff --git a/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc b/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
index bc8f2d648..e20c67ee1 100644
--- a/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
@@ -14,8 +14,6 @@
 #include "third_party/blink/renderer/platform/instrumentation/tracing/trace_event.h"
 #include "ui/gfx/geometry/size.h"
 
-using media::VideoFrameMetadata;
-
 namespace blink {
 
 void VpxEncoder::VpxCodecDeleter::operator()(vpx_codec_ctx_t* codec) {
@@ -78,25 +76,25 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
   switch (frame->format()) {
     case media::PIXEL_FORMAT_NV12: {
       last_frame_had_alpha_ = false;
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kYPlane),
-               frame->stride(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kUVPlane),
-               frame->stride(VideoFrame::kUVPlane),
-               frame->visible_data(VideoFrame::kUVPlane) + 1,
-               frame->stride(VideoFrame::kUVPlane), duration, force_keyframe,
+      DoEncode(encoder_.get(), frame_size, frame->data(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kYPlane),
+               frame->stride(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kUVPlane),
+               frame->stride(media::VideoFrame::kUVPlane),
+               frame->visible_data(media::VideoFrame::kUVPlane) + 1,
+               frame->stride(media::VideoFrame::kUVPlane), duration, force_keyframe,
                data, &keyframe, VPX_IMG_FMT_NV12);
       break;
     }
     case media::PIXEL_FORMAT_I420: {
       last_frame_had_alpha_ = false;
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kYPlane),
-               frame->stride(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kUPlane),
-               frame->stride(VideoFrame::kUPlane),
-               frame->visible_data(VideoFrame::kVPlane),
-               frame->stride(VideoFrame::kVPlane), duration, force_keyframe,
+      DoEncode(encoder_.get(), frame_size, frame->data(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kYPlane),
+               frame->stride(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kUPlane),
+               frame->stride(media::VideoFrame::kUPlane),
+               frame->visible_data(media::VideoFrame::kVPlane),
+               frame->stride(media::VideoFrame::kVPlane), duration, force_keyframe,
                data, &keyframe, VPX_IMG_FMT_I420);
       break;
     }
@@ -111,15 +109,15 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
           return;
         }
         u_plane_stride_ = media::VideoFrame::RowBytes(
-            VideoFrame::kUPlane, frame->format(), frame_size.width());
+            media::VideoFrame::kUPlane, frame->format(), frame_size.width());
         v_plane_stride_ = media::VideoFrame::RowBytes(
-            VideoFrame::kVPlane, frame->format(), frame_size.width());
+            media::VideoFrame::kVPlane, frame->format(), frame_size.width());
         v_plane_offset_ = media::VideoFrame::PlaneSize(
-                              frame->format(), VideoFrame::kUPlane, frame_size)
+                              frame->format(), media::VideoFrame::kUPlane, frame_size)
                               .GetArea();
         alpha_dummy_planes_.resize(base::checked_cast<wtf_size_t>(
             v_plane_offset_ + media::VideoFrame::PlaneSize(frame->format(),
-                                                           VideoFrame::kVPlane,
+                                                           media::VideoFrame::kVPlane,
                                                            frame_size)
                                   .GetArea()));
         // It is more expensive to encode 0x00, so use 0x80 instead.
@@ -129,19 +127,19 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
       force_keyframe = !last_frame_had_alpha_;
       last_frame_had_alpha_ = true;
 
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kYPlane),
-               frame->stride(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kUPlane),
-               frame->stride(VideoFrame::kUPlane),
-               frame->visible_data(VideoFrame::kVPlane),
-               frame->stride(VideoFrame::kVPlane), duration, force_keyframe,
+      DoEncode(encoder_.get(), frame_size, frame->data(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kYPlane),
+               frame->stride(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kUPlane),
+               frame->stride(media::VideoFrame::kUPlane),
+               frame->visible_data(media::VideoFrame::kVPlane),
+               frame->stride(media::VideoFrame::kVPlane), duration, force_keyframe,
                data, &keyframe, VPX_IMG_FMT_I420);
 
       DoEncode(alpha_encoder_.get(), frame_size,
-               frame->data(VideoFrame::kAPlane),
-               frame->visible_data(VideoFrame::kAPlane),
-               frame->stride(VideoFrame::kAPlane), alpha_dummy_planes_.data(),
+               frame->data(media::VideoFrame::kAPlane),
+               frame->visible_data(media::VideoFrame::kAPlane),
+               frame->stride(media::VideoFrame::kAPlane), alpha_dummy_planes_.data(),
                base::checked_cast<int>(u_plane_stride_),
                alpha_dummy_planes_.data() + v_plane_offset_,
                base::checked_cast<int>(v_plane_stride_), duration, keyframe,
diff --git a/third_party/blink/renderer/modules/mediastream/BUILD.gn b/third_party/blink/renderer/modules/mediastream/BUILD.gn
index 8ce74e0a7..5697ae09c 100644
--- a/third_party/blink/renderer/modules/mediastream/BUILD.gn
+++ b/third_party/blink/renderer/modules/mediastream/BUILD.gn
@@ -113,6 +113,13 @@ blink_modules_sources("mediastream") {
     "webmediaplayer_ms_compositor.cc",
     "webmediaplayer_ms_compositor.h",
   ]
+
+  jumbo_excluded_sources = [
+    "input_device_info.cc",
+    "processed_local_audio_source.cc",
+    "user_media_processor.cc",
+  ]
+
   deps = [
     "//build:chromecast_buildflags",
     "//build:chromeos_buildflags",
diff --git a/third_party/blink/renderer/modules/payments/payment_instruments.cc b/third_party/blink/renderer/modules/payments/payment_instruments.cc
index f77fa0005..bf9474da7 100644
--- a/third_party/blink/renderer/modules/payments/payment_instruments.cc
+++ b/third_party/blink/renderer/modules/payments/payment_instruments.cc
@@ -78,7 +78,7 @@ bool rejectError(ScriptPromiseResolver* resolver,
   return false;
 }
 
-bool AllowedToUsePaymentFeatures(ScriptState* script_state) {
+bool AllowedToUsePaymentFeatures2(ScriptState* script_state) {
   if (!script_state->ContextIsValid())
     return false;
   return ExecutionContext::From(script_state)
@@ -107,7 +107,7 @@ ScriptPromise PaymentInstruments::deleteInstrument(
     ScriptState* script_state,
     const String& instrument_key,
     ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_.is_bound()) {
@@ -129,7 +129,7 @@ ScriptPromise PaymentInstruments::deleteInstrument(
 ScriptPromise PaymentInstruments::get(ScriptState* script_state,
                                       const String& instrument_key,
                                       ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_.is_bound()) {
@@ -150,7 +150,7 @@ ScriptPromise PaymentInstruments::get(ScriptState* script_state,
 
 ScriptPromise PaymentInstruments::keys(ScriptState* script_state,
                                        ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_.is_bound()) {
@@ -171,7 +171,7 @@ ScriptPromise PaymentInstruments::keys(ScriptState* script_state,
 ScriptPromise PaymentInstruments::has(ScriptState* script_state,
                                       const String& instrument_key,
                                       ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_.is_bound()) {
@@ -194,7 +194,7 @@ ScriptPromise PaymentInstruments::set(ScriptState* script_state,
                                       const String& instrument_key,
                                       const PaymentInstrument* details,
                                       ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_.is_bound()) {
@@ -228,7 +228,7 @@ ScriptPromise PaymentInstruments::set(ScriptState* script_state,
 
 ScriptPromise PaymentInstruments::clear(ScriptState* script_state,
                                         ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_.is_bound()) {
diff --git a/third_party/blink/renderer/modules/peerconnection/BUILD.gn b/third_party/blink/renderer/modules/peerconnection/BUILD.gn
index a3434145e..8800a986e 100644
--- a/third_party/blink/renderer/modules/peerconnection/BUILD.gn
+++ b/third_party/blink/renderer/modules/peerconnection/BUILD.gn
@@ -159,6 +159,12 @@ blink_modules_sources("peerconnection") {
     "webrtc_video_perf_reporter.h",
   ]
 
+  jumbo_excluded_sources = [
+    "peer_connection_tracker.cc",
+    "rtc_data_channel.cc",
+    "rtc_rtp_sender_impl.cc",
+  ]
+
   public_deps = [ "//third_party/webrtc_overrides:webrtc_component" ]
   deps = [
     "//build:chromecast_buildflags",
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc b/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
index 6830ce391..9d9977573 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
@@ -239,7 +239,7 @@ RTCIceCandidatePlatform* ConvertToRTCIceCandidatePlatform(
       candidate->usernameFragment());
 }
 
-webrtc::PeerConnectionInterface::IceTransportsType IceTransportPolicyFromString(
+webrtc::PeerConnectionInterface::IceTransportsType IceTransportPolicyFromString2(
     const String& policy) {
   if (policy == "relay")
     return webrtc::PeerConnectionInterface::kRelay;
@@ -282,11 +282,11 @@ webrtc::PeerConnectionInterface::RTCConfiguration ParseConfiguration(
   if (configuration->hasIceTransportPolicy()) {
     UseCounter::Count(context, WebFeature::kRTCConfigurationIceTransportPolicy);
     web_configuration.type =
-        IceTransportPolicyFromString(configuration->iceTransportPolicy());
+        IceTransportPolicyFromString2(configuration->iceTransportPolicy());
   } else if (configuration->hasIceTransports()) {
     UseCounter::Count(context, WebFeature::kRTCConfigurationIceTransports);
     web_configuration.type =
-        IceTransportPolicyFromString(configuration->iceTransports());
+        IceTransportPolicyFromString2(configuration->iceTransports());
   }
 
   if (configuration->bundlePolicy() == "max-compat") {
diff --git a/third_party/blink/renderer/modules/permissions/BUILD.gn b/third_party/blink/renderer/modules/permissions/BUILD.gn
index 2e4b14e09..ab20f6efd 100644
--- a/third_party/blink/renderer/modules/permissions/BUILD.gn
+++ b/third_party/blink/renderer/modules/permissions/BUILD.gn
@@ -15,4 +15,5 @@ blink_modules_sources("permissions") {
     "permissions.cc",
     "permissions.h",
   ]
+  jumbo_excluded_sources = [ "permission_utils.cc" ]
 }
diff --git a/third_party/blink/renderer/modules/webaudio/analyser_handler.cc b/third_party/blink/renderer/modules/webaudio/analyser_handler.cc
index a3ef095cd..c823c923a 100644
--- a/third_party/blink/renderer/modules/webaudio/analyser_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/analyser_handler.cc
@@ -14,8 +14,8 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kDefaultNumberOfInputChannels = 2;
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfInputChannels2 = 2;
+constexpr unsigned kDefaultNumberOfOutputChannels2 = 1;
 
 }  // namespace
 
@@ -23,8 +23,8 @@ AnalyserHandler::AnalyserHandler(AudioNode& node, float sample_rate)
     : AudioBasicInspectorHandler(kNodeTypeAnalyser, node, sample_rate),
       analyser_(
           node.context()->GetDeferredTaskHandler().RenderQuantumFrames()) {
-  channel_count_ = kDefaultNumberOfInputChannels;
-  AddOutput(kDefaultNumberOfOutputChannels);
+  channel_count_ = kDefaultNumberOfInputChannels2;
+  AddOutput(kDefaultNumberOfOutputChannels2);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc
index c2dd0776b..645ad54f8 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc
@@ -32,7 +32,7 @@ constexpr double kMaxRate = 1024.0;
 
 // Default to mono. A call to setBuffer() will set the number of output
 // channels to that of the buffer.
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfOutputChannelsABSH = 1;
 
 }  // namespace
 
@@ -47,7 +47,7 @@ AudioBufferSourceHandler::AudioBufferSourceHandler(
       playback_rate_(&playback_rate),
       detune_(&detune),
       grain_duration_(kDefaultGrainDuration) {
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsABSH);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
index b7e7359ee..7f591531a 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
@@ -35,7 +35,7 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfOutputChannels_QWH = 1;
 
 }  // namespace
 
@@ -69,7 +69,7 @@ AudioWorkletHandler::AudioWorkletHandler(
   for (unsigned i = 0; i < options->numberOfOutputs(); ++i) {
     // If `options->outputChannelCount` unspecified, all outputs are mono.
     AddOutput(is_output_channel_count_given_ ? options->outputChannelCount()[i]
-                                             : kDefaultNumberOfOutputChannels);
+                                             : kDefaultNumberOfOutputChannels_QWH);
   }
   // Same for the outputs as well.
   outputs_.ReserveInitialCapacity(options->numberOfOutputs());
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc b/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc
index 79aff99e1..11dedaaf7 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc
@@ -43,7 +43,7 @@ constexpr float kMinFrequencyValue = 0.0f;
 constexpr double kDefaultQValue = 1.0;
 constexpr double kDefaultGainValue = 0.0;
 constexpr float kMinGainValue = std::numeric_limits<float>::lowest();
-constexpr double kDefaultDetuneValue = 0.0;
+constexpr double kDefaultDetuneValueBFN = 0.0;
 
 }  // namespace
 
@@ -77,7 +77,7 @@ BiquadFilterNode::BiquadFilterNode(BaseAudioContext& context)
           context,
           Uuid(),
           AudioParamHandler::kParamTypeBiquadFilterDetune,
-          kDefaultDetuneValue,
+          kDefaultDetuneValueBFN,
           AudioParamHandler::AutomationRate::kAudio,
           AudioParamHandler::AutomationRateMode::kVariable,
           /*min_value=*/-1200 * log2f(std::numeric_limits<float>::max()),
diff --git a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
index e346f5c00..e20500c75 100644
--- a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
@@ -13,7 +13,7 @@ namespace blink {
 namespace {
 
 // A ConstantSource is always mono.
-constexpr unsigned kNumberOfOutputChannels = 1;
+constexpr unsigned kNumberOfOutputChannelsCSH = 1;
 
 }  // namespace
 
@@ -23,7 +23,7 @@ ConstantSourceHandler::ConstantSourceHandler(AudioNode& node,
     : AudioScheduledSourceHandler(kNodeTypeConstantSource, node, sample_rate),
       offset_(&offset),
       sample_accurate_values_(GetDeferredTaskHandler().RenderQuantumFrames()) {
-  AddOutput(kNumberOfOutputChannels);
+  AddOutput(kNumberOfOutputChannelsCSH);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/convolver_handler.cc b/third_party/blink/renderer/modules/webaudio/convolver_handler.cc
index 325e3fde4..78468d18a 100644
--- a/third_party/blink/renderer/modules/webaudio/convolver_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/convolver_handler.cc
@@ -31,14 +31,14 @@ namespace {
 constexpr unsigned kMaxFftSize = 32768;
 
 constexpr unsigned kDefaultNumberOfInputChannels = 2;
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfOutputChannelsCH = 1;
 
 }  // namespace
 
 ConvolverHandler::ConvolverHandler(AudioNode& node, float sample_rate)
     : AudioHandler(kNodeTypeConvolver, node, sample_rate) {
   AddInput();
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsCH);
 
   // Node-specific default mixing rules.
   channel_count_ = kDefaultNumberOfInputChannels;
diff --git a/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc b/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc
index 8b80f6da6..fd74e43af 100644
--- a/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc
@@ -19,7 +19,7 @@ namespace blink {
 namespace {
 
 // Set output to stereo by default.
-constexpr unsigned kDefaultNumberOfOutputChannels = 2;
+constexpr unsigned kDefaultNumberOfOutputChannelsDCH = 2;
 
 }  // namespace
 
@@ -39,7 +39,7 @@ DynamicsCompressorHandler::DynamicsCompressorHandler(
       attack_(&attack),
       release_(&release) {
   AddInput();
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsDCH);
 
   SetInternalChannelCountMode(kClampedMax);
 
@@ -108,7 +108,7 @@ void DynamicsCompressorHandler::Initialize() {
 
   AudioHandler::Initialize();
   dynamics_compressor_ = std::make_unique<DynamicsCompressor>(
-      Context()->sampleRate(), kDefaultNumberOfOutputChannels);
+      Context()->sampleRate(), kDefaultNumberOfOutputChannelsDCH);
 }
 
 bool DynamicsCompressorHandler::RequiresTailProcessing() const {
diff --git a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
index fc982fa3e..357ef5314 100644
--- a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
@@ -18,7 +18,7 @@ namespace blink {
 
 namespace {
 
-constexpr uint32_t kNumberOfChannels = 1;
+constexpr uint32_t kNumberOfChannelsIFH = 1;
 
 }  // namespace
 
@@ -33,7 +33,7 @@ IIRFilterHandler::IIRFilterHandler(AudioNode& node,
           sample_rate,
           std::make_unique<IIRProcessor>(
               sample_rate,
-              kNumberOfChannels,
+              kNumberOfChannelsIFH,
               node.context()->GetDeferredTaskHandler().RenderQuantumFrames(),
               feedforward_coef,
               feedback_coef,
diff --git a/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc b/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc
index cae58d329..9d748d711 100644
--- a/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc
@@ -27,7 +27,7 @@ namespace {
 
 // Default to stereo. This could change depending on what the media element
 // .src is set to.
-constexpr unsigned kDefaultNumberOfOutputChannels = 2;
+constexpr unsigned kDefaultNumberOfOutputChannelsMEASH = 2;
 
 }  // namespace
 
@@ -61,7 +61,7 @@ MediaElementAudioSourceHandler::MediaElementAudioSourceHandler(
       media_element_(media_element) {
   DCHECK(IsMainThread());
 
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsMEASH);
 
   if (Context()->GetExecutionContext()) {
     task_runner_ = Context()->GetExecutionContext()->GetTaskRunner(
diff --git a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
index c8e12f5ef..db68ca93b 100644
--- a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
@@ -26,7 +26,7 @@ namespace blink {
 namespace {
 
 // An oscillator is always mono.
-constexpr unsigned kNumberOfOutputChannels = 1;
+constexpr unsigned kNumberOfOutputChannelsOH = 1;
 
 // Convert the detune value (in cents) to a frequency scale multiplier:
 // 2^(d/1200)
@@ -184,7 +184,7 @@ OscillatorHandler::OscillatorHandler(AudioNode& node,
     }
   }
 
-  AddOutput(kNumberOfOutputChannels);
+  AddOutput(kNumberOfOutputChannelsOH);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc b/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc
index 92fad010f..6e27beff3 100644
--- a/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc
+++ b/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc
@@ -16,11 +16,11 @@ namespace {
 
 // Use for ref-counting of all RealtimeAudioWorkletThread instances in a
 // process. Incremented by the constructor and decremented by destructor.
-int ref_count = 0;
+int ref_count_RAWT = 0;
 
-void EnsureSharedBackingThread(const ThreadCreationParams& params) {
+void EnsureSharedBackingThread_RAWT(const ThreadCreationParams& params) {
   DCHECK(IsMainThread());
-  DCHECK_EQ(ref_count, 1);
+  DCHECK_EQ(ref_count_RAWT, 1);
   WorkletThreadHolder<RealtimeAudioWorkletThread>::EnsureInstance(params);
 }
 
@@ -54,15 +54,15 @@ RealtimeAudioWorkletThread::RealtimeAudioWorkletThread(
                  "RealtimeAudioWorkletThread() - kNormal");
   }
 
-  if (++ref_count == 1) {
-    EnsureSharedBackingThread(params);
+  if (++ref_count_RAWT == 1) {
+    EnsureSharedBackingThread_RAWT(params);
   }
 }
 
 RealtimeAudioWorkletThread::~RealtimeAudioWorkletThread() {
   DCHECK(IsMainThread());
-  DCHECK_GT(ref_count, 0);
-  if (--ref_count == 0) {
+  DCHECK_GT(ref_count_RAWT, 0);
+  if (--ref_count_RAWT == 0) {
     ClearSharedBackingThread();
   }
 }
@@ -74,7 +74,7 @@ WorkerBackingThread& RealtimeAudioWorkletThread::GetWorkerBackingThread() {
 
 void RealtimeAudioWorkletThread::ClearSharedBackingThread() {
   DCHECK(IsMainThread());
-  CHECK_EQ(ref_count, 0);
+  CHECK_EQ(ref_count_RAWT, 0);
   WorkletThreadHolder<RealtimeAudioWorkletThread>::ClearInstance();
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc b/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc
index 6fdc6a038..5357fcd15 100644
--- a/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc
+++ b/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc
@@ -16,11 +16,11 @@ namespace {
 
 // Use for ref-counting of all SemiRealtimeAudioWorkletThread instances in a
 // process. Incremented by the constructor and decremented by destructor.
-int ref_count = 0;
+int ref_count_SRAWT = 0;
 
-void EnsureSharedBackingThread(const ThreadCreationParams& params) {
+void EnsureSharedBackingThreadSRAWT(const ThreadCreationParams& params) {
   DCHECK(IsMainThread());
-  DCHECK_EQ(ref_count, 1);
+  DCHECK_EQ(ref_count_SRAWT, 1);
   WorkletThreadHolder<SemiRealtimeAudioWorkletThread>::EnsureInstance(params);
 }
 
@@ -49,15 +49,15 @@ SemiRealtimeAudioWorkletThread::SemiRealtimeAudioWorkletThread(
     params.base_thread_type = base::ThreadType::kDefault;
   }
 
-  if (++ref_count == 1) {
-    EnsureSharedBackingThread(params);
+  if (++ref_count_SRAWT == 1) {
+    EnsureSharedBackingThreadSRAWT(params);
   }
 }
 
 SemiRealtimeAudioWorkletThread::~SemiRealtimeAudioWorkletThread() {
   DCHECK(IsMainThread());
-  DCHECK_GT(ref_count, 0);
-  if (--ref_count == 0) {
+  DCHECK_GT(ref_count_SRAWT, 0);
+  if (--ref_count_SRAWT == 0) {
     ClearSharedBackingThread();
   }
 }
@@ -69,7 +69,7 @@ WorkerBackingThread& SemiRealtimeAudioWorkletThread::GetWorkerBackingThread() {
 
 void SemiRealtimeAudioWorkletThread::ClearSharedBackingThread() {
   DCHECK(IsMainThread());
-  CHECK_EQ(ref_count, 0);
+  CHECK_EQ(ref_count_SRAWT, 0);
   WorkletThreadHolder<SemiRealtimeAudioWorkletThread>::ClearInstance();
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
index 2c199fb02..2f4b24a1c 100644
--- a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
@@ -20,8 +20,8 @@ namespace blink {
 namespace {
 
 // A PannerNode only supports 1 or 2 channels
-constexpr unsigned kMinimumOutputChannels = 1;
-constexpr unsigned kMaximumOutputChannels = 2;
+constexpr unsigned kMinimumOutputChannels_SPH = 1;
+constexpr unsigned kMaximumOutputChannels_SPH = 2;
 
 }  // namespace
 
@@ -33,11 +33,11 @@ StereoPannerHandler::StereoPannerHandler(AudioNode& node,
       sample_accurate_pan_values_(
           GetDeferredTaskHandler().RenderQuantumFrames()) {
   AddInput();
-  AddOutput(kMaximumOutputChannels);
+  AddOutput(kMaximumOutputChannels_SPH);
 
   // The node-specific default mixing rules declare that StereoPannerNode
   // can handle mono to stereo and stereo to stereo conversion.
-  channel_count_ = kMaximumOutputChannels;
+  channel_count_ = kMaximumOutputChannels_SPH;
   SetInternalChannelCountMode(kClampedMax);
   SetInternalChannelInterpretation(AudioBus::kSpeakers);
 
@@ -112,8 +112,8 @@ void StereoPannerHandler::SetChannelCount(unsigned channel_count,
   DCHECK(IsMainThread());
   BaseAudioContext::GraphAutoLocker locker(Context());
 
-  if (channel_count >= kMinimumOutputChannels &&
-      channel_count <= kMaximumOutputChannels) {
+  if (channel_count >= kMinimumOutputChannels_SPH &&
+      channel_count <= kMaximumOutputChannels_SPH) {
     if (channel_count_ != channel_count) {
       channel_count_ = channel_count;
       if (InternalChannelCountMode() != kMax) {
@@ -124,8 +124,8 @@ void StereoPannerHandler::SetChannelCount(unsigned channel_count,
     exception_state.ThrowDOMException(
         DOMExceptionCode::kNotSupportedError,
         ExceptionMessages::IndexOutsideRange<uint32_t>(
-            "channelCount", channel_count, kMinimumOutputChannels,
-            ExceptionMessages::kInclusiveBound, kMaximumOutputChannels,
+            "channelCount", channel_count, kMinimumOutputChannels_SPH,
+            ExceptionMessages::kInclusiveBound, kMaximumOutputChannels_SPH,
             ExceptionMessages::kInclusiveBound));
   }
 }
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
index 761140006..b341934b6 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
@@ -14,7 +14,7 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kNumberOfChannels = 1;
+constexpr unsigned kNumberOfChannelsWSH = 1;
 
 }  // namespace
 
@@ -25,7 +25,7 @@ WaveShaperHandler::WaveShaperHandler(AudioNode& node, float sample_rate)
           sample_rate,
           std::make_unique<WaveShaperProcessor>(
               sample_rate,
-              kNumberOfChannels,
+              kNumberOfChannelsWSH,
               node.context()->GetDeferredTaskHandler().RenderQuantumFrames())) {
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webcodecs/BUILD.gn b/third_party/blink/renderer/modules/webcodecs/BUILD.gn
index 70f30624d..28205ad14 100644
--- a/third_party/blink/renderer/modules/webcodecs/BUILD.gn
+++ b/third_party/blink/renderer/modules/webcodecs/BUILD.gn
@@ -93,6 +93,11 @@ blink_modules_sources("webcodecs") {
     "webcodecs_logger.cc",
     "webcodecs_logger.h",
   ]
+  jumbo_excluded_sources = [
+    "video_decoder_broker.cc",
+    "video_encoder.cc",
+    "video_frame.cc",
+  ]
   deps = [
     "//build:chromeos_buildflags",
     "//media",
diff --git a/third_party/blink/renderer/modules/webcodecs/decoder_template.cc b/third_party/blink/renderer/modules/webcodecs/decoder_template.cc
index 011a44722..40f359ec2 100644
--- a/third_party/blink/renderer/modules/webcodecs/decoder_template.cc
+++ b/third_party/blink/renderer/modules/webcodecs/decoder_template.cc
@@ -55,7 +55,7 @@
 namespace blink {
 
 namespace {
-constexpr const char kCategory[] = "media";
+constexpr const char kCategory2[] = "media";
 
 base::AtomicSequenceNumber g_sequence_num_for_counters;
 }  // namespace
@@ -492,7 +492,7 @@ void DecoderTemplate<Traits>::Shutdown(DOMException* exception) {
   if (IsClosed())
     return;
 
-  TRACE_EVENT1(kCategory, GetTraceNames()->shutdown.c_str(), "has_exception",
+  TRACE_EVENT1(kCategory2, GetTraceNames()->shutdown.c_str(), "has_exception",
                !!exception);
 
   shutting_down_ = true;
@@ -550,7 +550,7 @@ void DecoderTemplate<Traits>::Shutdown(DOMException* exception) {
   }
 
   bool trace_enabled = false;
-  TRACE_EVENT_CATEGORY_GROUP_ENABLED(kCategory, &trace_enabled);
+  TRACE_EVENT_CATEGORY_GROUP_ENABLED(kCategory2, &trace_enabled);
   if (trace_enabled) {
     for (auto& pending_decode : pending_decodes_)
       pending_decode.value->decode_trace.reset();
@@ -754,12 +754,12 @@ void DecoderTemplate<Traits>::OnOutput(uint32_t reset_generation,
 
   OutputType* blink_output = std::move(output_or_error).value();
 
-  TRACE_EVENT_BEGIN1(kCategory, GetTraceNames()->output.c_str(), "timestamp",
+  TRACE_EVENT_BEGIN1(kCategory2, GetTraceNames()->output.c_str(), "timestamp",
                      blink_output->timestamp());
 
   output_cb_->InvokeAndReportException(nullptr, blink_output);
 
-  TRACE_EVENT_END0(kCategory, GetTraceNames()->output.c_str());
+  TRACE_EVENT_END0(kCategory2, GetTraceNames()->output.c_str());
 
   MarkCodecActive();
 }
@@ -767,7 +767,7 @@ void DecoderTemplate<Traits>::OnOutput(uint32_t reset_generation,
 template <typename Traits>
 void DecoderTemplate<Traits>::TraceQueueSizes() const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  TRACE_COUNTER_ID2(kCategory, GetTraceNames()->requests_counter.c_str(),
+  TRACE_COUNTER_ID2(kCategory2, GetTraceNames()->requests_counter.c_str(),
                     trace_counter_id_, "decodes", num_pending_decodes_, "other",
                     requests_.size() - num_pending_decodes_);
 }
@@ -830,7 +830,7 @@ void DecoderTemplate<Traits>::Trace(Visitor* visitor) const {
 
 template <typename Traits>
 void DecoderTemplate<Traits>::OnCodecReclaimed(DOMException* exception) {
-  TRACE_EVENT0(kCategory, GetTraceNames()->reclaimed.c_str());
+  TRACE_EVENT0(kCategory2, GetTraceNames()->reclaimed.c_str());
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(is_applying_codec_pressure());
 
@@ -883,7 +883,7 @@ void DecoderTemplate<Traits>::Request::StartTracing() {
   DCHECK(!is_tracing);
   is_tracing = true;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory, TraceNameFromType(), this);
+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory2, TraceNameFromType(), this);
 }
 
 template <typename Traits>
@@ -892,7 +892,7 @@ void DecoderTemplate<Traits>::Request::EndTracing(bool shutting_down) {
   DCHECK(is_tracing);
   is_tracing = false;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory, TraceNameFromType(), this,
+  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory2, TraceNameFromType(), this,
                                   "completed", !shutting_down);
 }
 
diff --git a/third_party/blink/renderer/modules/webcodecs/encoder_base.cc b/third_party/blink/renderer/modules/webcodecs/encoder_base.cc
index 671758b63..936bfdd09 100644
--- a/third_party/blink/renderer/modules/webcodecs/encoder_base.cc
+++ b/third_party/blink/renderer/modules/webcodecs/encoder_base.cc
@@ -45,9 +45,9 @@
 namespace blink {
 
 namespace {
-constexpr const char kCategory[] = "media";
+constexpr const char kCategory3[] = "media";
 
-base::AtomicSequenceNumber g_sequence_num_for_counters;
+base::AtomicSequenceNumber g_sequence_num_for_counters2;
 }  // namespace
 
 // static
@@ -66,7 +66,7 @@ EncoderBase<Traits>::EncoderBase(ScriptState* script_state,
                        ExecutionContext::From(script_state)),
       state_(V8CodecState::Enum::kUnconfigured),
       script_state_(script_state),
-      trace_counter_id_(g_sequence_num_for_counters.GetNext()) {
+      trace_counter_id_(g_sequence_num_for_counters2.GetNext()) {
   auto* context = ExecutionContext::From(script_state);
   callback_runner_ = context->GetTaskRunner(TaskType::kInternalMediaRealTime);
 
@@ -204,7 +204,7 @@ void EncoderBase<Traits>::reset(ExceptionState& exception_state) {
   if (ThrowIfCodecStateClosed(state_, "reset", exception_state))
     return;
 
-  TRACE_EVENT0(kCategory, GetTraceNames()->reset.c_str());
+  TRACE_EVENT0(kCategory3, GetTraceNames()->reset.c_str());
 
   state_ = V8CodecState(V8CodecState::Enum::kUnconfigured);
   ResetInternal();
@@ -253,7 +253,7 @@ void EncoderBase<Traits>::HandleError(DOMException* ex) {
   if (state_.AsEnum() == V8CodecState::Enum::kClosed)
     return;
 
-  TRACE_EVENT0(kCategory, GetTraceNames()->handle_error.c_str());
+  TRACE_EVENT0(kCategory3, GetTraceNames()->handle_error.c_str());
 
   // Save a temp before we clear the callback.
   V8WebCodecsErrorCallback* error_callback = error_callback_.Get();
@@ -362,7 +362,7 @@ void EncoderBase<Traits>::ProcessFlush(Request* request) {
 
 template <typename Traits>
 void EncoderBase<Traits>::OnCodecReclaimed(DOMException* exception) {
-  TRACE_EVENT0(kCategory, GetTraceNames()->reclaimed.c_str());
+  TRACE_EVENT0(kCategory3, GetTraceNames()->reclaimed.c_str());
   DCHECK_EQ(state_.AsEnum(), V8CodecState::Enum::kConfigured);
   HandleError(exception);
 }
@@ -381,7 +381,7 @@ bool EncoderBase<Traits>::HasPendingActivity() const {
 
 template <typename Traits>
 void EncoderBase<Traits>::TraceQueueSizes() const {
-  TRACE_COUNTER_ID2(kCategory, GetTraceNames()->requests_counter.c_str(),
+  TRACE_COUNTER_ID2(kCategory3, GetTraceNames()->requests_counter.c_str(),
                     trace_counter_id_, "encodes", requested_encodes_, "other",
                     requests_.size() - requested_encodes_);
 }
@@ -467,7 +467,7 @@ void EncoderBase<Traits>::Request::StartTracingVideoEncode(
   DCHECK(!is_tracing);
   is_tracing = true;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(kCategory, TraceNameFromType(), this,
+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(kCategory3, TraceNameFromType(), this,
                                     "key_frame", is_keyframe, "timestamp",
                                     timestamp);
 }
@@ -478,7 +478,7 @@ void EncoderBase<Traits>::Request::StartTracing() {
   DCHECK(!is_tracing);
   is_tracing = true;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory, TraceNameFromType(), this);
+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory3, TraceNameFromType(), this);
 }
 
 template <typename Traits>
@@ -487,7 +487,7 @@ void EncoderBase<Traits>::Request::EndTracing(bool aborted) {
   DCHECK(is_tracing);
   is_tracing = false;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory, TraceNameFromType(), this,
+  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory3, TraceNameFromType(), this,
                                   "aborted", aborted);
 }
 
diff --git a/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc b/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc
index e829dea84..8cf583fc5 100644
--- a/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc
+++ b/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc
@@ -20,14 +20,14 @@ MainThreadTaskRunnerRestricted AccessMainThreadForGpuFactories() {
 
 namespace {
 
-media::GpuVideoAcceleratorFactories* GetGpuFactoriesOnMainThread() {
+media::GpuVideoAcceleratorFactories* GetGpuFactoriesOnMainThread2() {
   DCHECK(IsMainThread());
   return Platform::Current()->GetGpuFactories();
 }
 
 void RetrieveGpuFactories(OutputCB result_callback) {
   if (IsMainThread()) {
-    std::move(result_callback).Run(GetGpuFactoriesOnMainThread());
+    std::move(result_callback).Run(GetGpuFactoriesOnMainThread2());
     return;
   }
 
@@ -36,7 +36,7 @@ void RetrieveGpuFactories(OutputCB result_callback) {
       ->PostTaskAndReplyWithResult(
           FROM_HERE,
           ConvertToBaseOnceCallback(
-              CrossThreadBindOnce(&GetGpuFactoriesOnMainThread)),
+              CrossThreadBindOnce(&GetGpuFactoriesOnMainThread2)),
           ConvertToBaseOnceCallback(std::move(result_callback)));
 }
 
diff --git a/third_party/blink/renderer/modules/webgpu/BUILD.gn b/third_party/blink/renderer/modules/webgpu/BUILD.gn
index c91cc379b..ab934a25d 100644
--- a/third_party/blink/renderer/modules/webgpu/BUILD.gn
+++ b/third_party/blink/renderer/modules/webgpu/BUILD.gn
@@ -96,6 +96,8 @@ blink_modules_sources("webgpu") {
     "texture_utils.cc",
     "texture_utils.h",
   ]
+  jumbo_excluded_sources = [ "dawn_enum_conversions.cc" ]
+
   deps = [
     "//gpu/command_buffer/client:webgpu_interface",
     "//services/metrics/public/cpp:ukm_builders",
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 415d024f2..88d991149 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1590,6 +1590,15 @@ jumbo_component("platform") {
     }
   }
 
+  jumbo_excluded_sources = [
+    "bindings/parkable_string_manager.cc",
+    "fonts/font_matching_metrics.cc",
+    "mediastream/media_stream_audio_source.cc",
+    "mediastream/media_stream_audio_track.cc",
+    "peerconnection/rtc_video_decoder_adapter.cc",
+    "peerconnection/rtc_video_decoder_factory.cc",
+  ]
+
   if (is_mac) {
     sources += [
       "audio/mac/fft_frame_mac.cc",
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/audio_delay_dsp_kernel_sse2.cc b/third_party/blink/renderer/platform/audio/cpu/x86/audio_delay_dsp_kernel_sse2.cc
index 0dc2d90f2..a7e6ee53b 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/audio_delay_dsp_kernel_sse2.cc
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/audio_delay_dsp_kernel_sse2.cc
@@ -4,7 +4,9 @@
 
 #include "third_party/blink/renderer/platform/audio/audio_delay_dsp_kernel.h"
 
+#include <emmintrin.h>
 #include <xmmintrin.h>
+#include <tuple>
 
 namespace blink {
 
diff --git a/third_party/blink/renderer/platform/audio/hrtf_panner.cc b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
index 363fcdd01..a8c258362 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_panner.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
@@ -40,7 +40,7 @@ namespace {
 // The value of 2 milliseconds is larger than the largest delay which exists in
 // any HRTFKernel from the default HRTFDatabase (0.0136 seconds).
 // We ASSERT the delay values used in process() with this value.
-constexpr double kMaxDelayTimeSeconds = 0.002;
+constexpr double kMaxDelayTimeSeconds2 = 0.002;
 
 constexpr int kUninitializedAzimuth = -1;
 
@@ -85,8 +85,8 @@ HRTFPanner::HRTFPanner(float sample_rate,
       convolver_r1_(FftSizeForSampleRate(sample_rate)),
       convolver_l2_(FftSizeForSampleRate(sample_rate)),
       convolver_r2_(FftSizeForSampleRate(sample_rate)),
-      delay_line_l_(kMaxDelayTimeSeconds, sample_rate, render_quantum_frames),
-      delay_line_r_(kMaxDelayTimeSeconds, sample_rate, render_quantum_frames),
+      delay_line_l_(kMaxDelayTimeSeconds2, sample_rate, render_quantum_frames),
+      delay_line_r_(kMaxDelayTimeSeconds2, sample_rate, render_quantum_frames),
       temp_l1_(render_quantum_frames),
       temp_r1_(render_quantum_frames),
       temp_l2_(render_quantum_frames),
@@ -253,10 +253,10 @@ void HRTFPanner::Pan(double desired_azimuth,
     DCHECK(kernel_r1);
     DCHECK(kernel_l2);
     DCHECK(kernel_r2);
-    DCHECK_LT(frame_delay_l1 / SampleRate(), kMaxDelayTimeSeconds);
-    DCHECK_LT(frame_delay_r1 / SampleRate(), kMaxDelayTimeSeconds);
-    DCHECK_LT(frame_delay_l2 / SampleRate(), kMaxDelayTimeSeconds);
-    DCHECK_LT(frame_delay_r2 / SampleRate(), kMaxDelayTimeSeconds);
+    DCHECK_LT(frame_delay_l1 / SampleRate(), kMaxDelayTimeSeconds2);
+    DCHECK_LT(frame_delay_r1 / SampleRate(), kMaxDelayTimeSeconds2);
+    DCHECK_LT(frame_delay_l2 / SampleRate(), kMaxDelayTimeSeconds2);
+    DCHECK_LT(frame_delay_r2 / SampleRate(), kMaxDelayTimeSeconds2);
 
     // Crossfade inter-aural delays based on transitions.
     const double frame_delay_l =
@@ -369,7 +369,7 @@ double HRTFPanner::TailTime() const {
   // the tailTime of the HRTFPanner is the sum of the tailTime of the
   // DelayKernel and the tailTime of the FFTConvolver, which is
   // MaxDelayTimeSeconds and fftSize() / 2, respectively.
-  return kMaxDelayTimeSeconds +
+  return kMaxDelayTimeSeconds2 +
          (FftSize() / 2) / static_cast<double>(SampleRate());
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
index c165a1703..6b5937647 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
@@ -61,11 +61,11 @@ namespace blink {
 
 namespace {
 
-constexpr hb_feature_t CreateFeature(char c1,
-                                     char c2,
-                                     char c3,
-                                     char c4,
-                                     uint32_t value = 0) {
+constexpr hb_feature_t CreateFeature2(char c1,
+                                      char c2,
+                                      char c3,
+                                      char c4,
+                                      uint32_t value = 0) {
   return {HB_TAG(c1, c2, c3, c4), value, 0 /* start */,
           static_cast<unsigned>(-1) /* end */};
 }
@@ -720,12 +720,12 @@ CapsFeatureSettingsScopedOverlay::CapsFeatureSettingsScopedOverlay(
 
 void CapsFeatureSettingsScopedOverlay::OverlayCapsFeatures(
     FontDescription::FontVariantCaps variant_caps) {
-  static constexpr hb_feature_t smcp = CreateFeature('s', 'm', 'c', 'p', 1);
-  static constexpr hb_feature_t pcap = CreateFeature('p', 'c', 'a', 'p', 1);
-  static constexpr hb_feature_t c2sc = CreateFeature('c', '2', 's', 'c', 1);
-  static constexpr hb_feature_t c2pc = CreateFeature('c', '2', 'p', 'c', 1);
-  static constexpr hb_feature_t unic = CreateFeature('u', 'n', 'i', 'c', 1);
-  static constexpr hb_feature_t titl = CreateFeature('t', 'i', 't', 'l', 1);
+  static constexpr hb_feature_t smcp = CreateFeature2('s', 'm', 'c', 'p', 1);
+  static constexpr hb_feature_t pcap = CreateFeature2('p', 'c', 'a', 'p', 1);
+  static constexpr hb_feature_t c2sc = CreateFeature2('c', '2', 's', 'c', 1);
+  static constexpr hb_feature_t c2pc = CreateFeature2('c', '2', 'p', 'c', 1);
+  static constexpr hb_feature_t unic = CreateFeature2('u', 'n', 'i', 'c', 1);
+  static constexpr hb_feature_t titl = CreateFeature2('t', 'i', 't', 'l', 1);
   if (variant_caps == FontDescription::kSmallCaps ||
       variant_caps == FontDescription::kAllSmallCaps) {
     PrependCounting(smcp);
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
index c8704ddeb..2e6ac4b5f 100644
--- a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
@@ -637,7 +637,7 @@ void PaintArtifactCompositor::Update(
     const Vector<const TransformPaintPropertyNode*>& scroll_translation_nodes,
     Vector<std::unique_ptr<cc::ViewTransitionRequest>> transition_requests) {
   const bool unification_enabled =
-      base::FeatureList::IsEnabled(features::kScrollUnification);
+      base::FeatureList::IsEnabled(::features::kScrollUnification);
   // See: |UpdateRepaintedLayers| for repaint updates.
   DCHECK(needs_update_);
   DCHECK(scroll_translation_nodes.empty() || unification_enabled);
diff --git a/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc b/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
index bbf10abdb..31c24ada0 100644
--- a/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
+++ b/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
@@ -49,6 +49,10 @@
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/skia/include/core/SkColorSpace.h"
 
+#if defined(OS_WIN)
+#include <basetsd.h>  // Included before jpeglib.h because of INT32 clash
+#endif                // OS_WIN
+
 extern "C" {
 #include <stdio.h>  // jpeglib.h needs stdio FILE.
 #include "jpeglib.h"
diff --git a/third_party/blink/renderer/platform/loader/web_url_request_util.cc b/third_party/blink/renderer/platform/loader/web_url_request_util.cc
index 209565038..c6f33cfc4 100644
--- a/third_party/blink/renderer/platform/loader/web_url_request_util.cc
+++ b/third_party/blink/renderer/platform/loader/web_url_request_util.cc
@@ -28,6 +28,7 @@
 #include "third_party/blink/public/platform/web_string.h"
 #include "third_party/blink/public/platform/web_url_request.h"
 #include "third_party/blink/renderer/platform/loader/mixed_content.h"
+#include "third_party/blink/renderer/platform/wtf/assertions.h"
 #include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
diff --git a/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc b/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc
index 142fdccf2..3b727c6bb 100644
--- a/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc
+++ b/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc
@@ -22,7 +22,7 @@ constexpr base::TimeDelta kCheckSimultaneousDecodersInterval = base::Seconds(5);
 
 // Number of StatsCollectingDecoder instances right now that have started
 // decoding.
-std::atomic_int* GetDecoderCounter() {
+std::atomic_int* GetDecoderCounter2() {
   static std::atomic_int s_counter(0);
   return &s_counter;
 }
@@ -59,7 +59,7 @@ int32_t StatsCollectingDecoder::Decode(const webrtc::EncodedImage& input_image,
   DCHECK_CALLED_ON_VALID_SEQUENCE(decoding_sequence_checker_);
   if (!first_frame_decoded_) {
     first_frame_decoded_ = true;
-    ++(*GetDecoderCounter());
+    ++(*GetDecoderCounter2());
   }
   {
     base::AutoLock auto_lock(lock_);
@@ -92,7 +92,7 @@ int32_t StatsCollectingDecoder::Release() {
   }
 
   if (first_frame_decoded_) {
-    --(*GetDecoderCounter());
+    --(*GetDecoderCounter2());
     first_frame_decoded_ = false;
   }
 
@@ -132,13 +132,13 @@ void StatsCollectingDecoder::Decoded(webrtc::VideoFrame& decodedImage,
   if ((now - last_check_for_simultaneous_decoders_) >
       kCheckSimultaneousDecodersInterval) {
     last_check_for_simultaneous_decoders_ = now;
-    DVLOG(3) << "Simultaneous decoders: " << *GetDecoderCounter();
+    DVLOG(3) << "Simultaneous decoders: " << *GetDecoderCounter2();
     if (active_stats_collection()) {
-      if (*GetDecoderCounter() > kMaximumDecodersToCollectStats) {
+      if (*GetDecoderCounter2() > kMaximumDecodersToCollectStats) {
         // Too many decoders, cancel stats collection.
         ClearStatsCollection();
       }
-    } else if (*GetDecoderCounter() <= kMaximumDecodersToCollectStats) {
+    } else if (*GetDecoderCounter2() <= kMaximumDecodersToCollectStats) {
       // Start up stats collection since there's only a single decoder active.
       StartStatsCollection();
     }
diff --git a/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc b/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc
index 3c828c7b1..83c3638a2 100644
--- a/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc
+++ b/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc
@@ -291,7 +291,7 @@ void LayerTreeView::WillCommit(const cc::CommitState&) {
   if (!delegate_)
     return;
   delegate_->WillCommitCompositorFrame();
-  if (base::FeatureList::IsEnabled(features::kNonBlockingCommit)) {
+  if (base::FeatureList::IsEnabled(::features::kNonBlockingCommit)) {
     widget_scheduler_->DidCommitFrameToCompositor();
   }
 }
@@ -301,7 +301,7 @@ void LayerTreeView::DidCommit(base::TimeTicks commit_start_time,
   if (!delegate_)
     return;
   delegate_->DidCommitCompositorFrame(commit_start_time, commit_finish_time);
-  if (!base::FeatureList::IsEnabled(features::kNonBlockingCommit)) {
+  if (!base::FeatureList::IsEnabled(::features::kNonBlockingCommit)) {
     widget_scheduler_->DidCommitFrameToCompositor();
   }
 }
diff --git a/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc b/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc
index 29eb15839..f1989a299 100644
--- a/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc
+++ b/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc
@@ -69,7 +69,7 @@ ElasticOverscrollController::ElasticOverscrollController(
 std::unique_ptr<ElasticOverscrollController>
 ElasticOverscrollController::Create(cc::ScrollElasticityHelper* helper) {
 #if BUILDFLAG(IS_WIN)
-  return base::FeatureList::IsEnabled(features::kElasticOverscroll)
+  return base::FeatureList::IsEnabled(::features::kElasticOverscroll)
              ? std::make_unique<ElasticOverscrollControllerBezier>(helper)
              : nullptr;
 #else
diff --git a/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc b/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc
index 89ae9b11d..c1d46cd85 100644
--- a/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc
+++ b/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc
@@ -161,7 +161,7 @@ mojom::InputEventResultState GetAckResult(WebInputEventResult processed) {
              : mojom::InputEventResultState::kConsumed;
 }
 
-bool IsGestureScroll(WebInputEvent::Type type) {
+bool IsGestureScrollWBIH(WebInputEvent::Type type) {
   switch (type) {
     case WebGestureEvent::Type::kGestureScrollBegin:
     case WebGestureEvent::Type::kGestureScrollUpdate:
@@ -565,7 +565,7 @@ void WidgetBaseInputHandler::InjectGestureScrollEvent(
     ui::ScrollGranularity granularity,
     cc::ElementId scrollable_area_element_id,
     WebInputEvent::Type injected_type) {
-  DCHECK(IsGestureScroll(injected_type));
+  DCHECK(IsGestureScrollWBIH(injected_type));
   // If we're currently handling an input event, cache the appropriate
   // parameters so we can dispatch the events directly once blink finishes
   // handling the event.
diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index b2e7e5a28..d7b0b902a 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -214,6 +214,10 @@ jumbo_component("base") {
 
   libs = []
 
+  jumbo_excluded_sources = [
+    "resource/resource_bundle.cc",
+  ]
+
   if (is_android) {
     sources += [
       "device_form_factor_android.cc",
diff --git a/ui/base/ime/win/BUILD.gn b/ui/base/ime/win/BUILD.gn
index 67ff94a8c..68f32bf48 100644
--- a/ui/base/ime/win/BUILD.gn
+++ b/ui/base/ime/win/BUILD.gn
@@ -34,6 +34,7 @@ jumbo_component("win") {
     "virtual_keyboard_debounce_timer.cc",
     "virtual_keyboard_debounce_timer.h",
   ]
+  jumbo_excluded_sources = [ "tsf_text_store.cc" ]
 
   defines = [ "IS_UI_BASE_IME_WIN_IMPL" ]
 
diff --git a/ui/base/x/BUILD.gn b/ui/base/x/BUILD.gn
index 70b57c65c..67a3aae27 100644
--- a/ui/base/x/BUILD.gn
+++ b/ui/base/x/BUILD.gn
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//build/config/linux/gtk/gtk.gni")
 import("//build/config/ozone.gni")
 import("//build/config/ui.gni")
@@ -10,7 +9,7 @@ import("//testing/libfuzzer/fuzzer_test.gni")
 
 assert(ozone_platform_x11)
 
-jumbo_component("x") {
+component("x") {
   output_name = "ui_base_x"
 
   sources = [
diff --git a/ui/color/BUILD.gn b/ui/color/BUILD.gn
index 1179f2721..3a9623e34 100644
--- a/ui/color/BUILD.gn
+++ b/ui/color/BUILD.gn
@@ -4,12 +4,11 @@
 
 import("//build/buildflag_header.gni")
 import("//build/config/chromeos/ui_mode.gni")
-import("//build/config/jumbo.gni")
 import("//mojo/public/tools/bindings/mojom.gni")
 import("//testing/test.gni")
 import("//ui/base/ui_features.gni")
 
-jumbo_source_set("color_headers") {
+source_set("color_headers") {
   sources = [
     "color_id.h",
     "color_id_macros.inc",
@@ -30,7 +29,7 @@ jumbo_source_set("color_headers") {
   ]
 }
 
-jumbo_component("color") {
+component("color") {
   sources = [
     "color_metrics.cc",
     "color_mixer.cc",
@@ -123,7 +122,7 @@ if (is_win) {
   }
 }
 
-jumbo_component("mixers") {
+component("mixers") {
   sources = [
     "color_mixers.cc",
     "color_mixers.h",
diff --git a/ui/gfx/geometry/transform_operations.cc b/ui/gfx/geometry/transform_operations.cc
index f9c2ee1b1..316b1aa68 100644
--- a/ui/gfx/geometry/transform_operations.cc
+++ b/ui/gfx/geometry/transform_operations.cc
@@ -139,7 +139,7 @@ bool TransformOperations::IsTranslation() const {
   return true;
 }
 
-static SkScalar TanDegrees(double degrees) {
+static SkScalar TanDegrees2(double degrees) {
   return SkDoubleToScalar(std::tan(DegToRad(degrees)));
 }
 
@@ -163,8 +163,8 @@ bool TransformOperations::ScaleComponent(SkScalar* scale) const {
       case TransformOperation::TRANSFORM_OPERATION_SKEWX:
       case TransformOperation::TRANSFORM_OPERATION_SKEWY:
       case TransformOperation::TRANSFORM_OPERATION_SKEW: {
-        SkScalar x_component = TanDegrees(operation.skew.x);
-        SkScalar y_component = TanDegrees(operation.skew.y);
+        SkScalar x_component = TanDegrees2(operation.skew.x);
+        SkScalar y_component = TanDegrees2(operation.skew.y);
         SkScalar x_scale = std::sqrt(x_component * x_component + 1);
         SkScalar y_scale = std::sqrt(y_component * y_component + 1);
         operations_scale *= std::max(x_scale, y_scale);
diff --git a/ui/gl/BUILD.gn b/ui/gl/BUILD.gn
index a7fa6c74c..da1cf1e74 100644
--- a/ui/gl/BUILD.gn
+++ b/ui/gl/BUILD.gn
@@ -223,6 +223,10 @@ jumbo_component("gl") {
         "gl_angle_util_vulkan.cc",
         "gl_angle_util_vulkan.h",
       ]
+
+      jumbo_excluded_sources = [
+        "gl_angle_util_vulkan.cc",
+      ]
     }
 
     if (is_linux || is_chromeos || use_ozone) {
diff --git a/ui/gl/direct_composition_surface_win.cc b/ui/gl/direct_composition_surface_win.cc
index 4db92d7da..4cd7637cf 100644
--- a/ui/gl/direct_composition_surface_win.cc
+++ b/ui/gl/direct_composition_surface_win.cc
@@ -24,7 +24,7 @@ namespace gl {
 
 namespace {
 
-bool SupportsLowLatencyPresentation() {
+bool SupportsLowLatencyPresentation2() {
   return base::FeatureList::IsEnabled(
       features::kDirectCompositionLowLatencyPresentation);
 }
@@ -172,7 +172,7 @@ void DirectCompositionSurfaceWin::SetVSyncEnabled(bool enabled) {
 void DirectCompositionSurfaceWin::OnVSync(base::TimeTicks vsync_time,
                                           base::TimeDelta interval) {
   // Main thread will run vsync callback in low latency presentation mode.
-  if (VSyncCallbackEnabled() && !SupportsLowLatencyPresentation()) {
+  if (VSyncCallbackEnabled() && !SupportsLowLatencyPresentation2()) {
     DCHECK(vsync_callback_);
     vsync_callback_.Run(vsync_time, interval);
   }
@@ -299,7 +299,7 @@ void DirectCompositionSurfaceWin::HandleVSyncOnMainThread(
   UMA_HISTOGRAM_COUNTS_100("GPU.DirectComposition.NumPendingFrames",
                            pending_frames_.size());
 
-  if (SupportsLowLatencyPresentation() && VSyncCallbackEnabled() &&
+  if (SupportsLowLatencyPresentation2() && VSyncCallbackEnabled() &&
       pending_frames_.size() < max_pending_frames_) {
     DCHECK(vsync_callback_);
     vsync_callback_.Run(vsync_time, interval);
diff --git a/ui/native_theme/BUILD.gn b/ui/native_theme/BUILD.gn
index b714e00e0..6b022564c 100644
--- a/ui/native_theme/BUILD.gn
+++ b/ui/native_theme/BUILD.gn
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//testing/test.gni")
 
@@ -23,7 +22,7 @@ component("features") {
   ]
 }
 
-jumbo_component("native_theme") {
+component("native_theme") {
   sources = [
     "caption_style.cc",
     "caption_style.h",
@@ -104,7 +103,7 @@ jumbo_component("native_theme") {
 }
 
 if (is_win) {
-  jumbo_component("native_theme_browser") {
+  component("native_theme_browser") {
     defines = [ "NATIVE_THEME_IMPLEMENTATION" ]
 
     # These files cannot work in the renderer on Windows.
@@ -126,11 +125,11 @@ if (is_win) {
     libs = [ "uxtheme.lib" ]
   }
 } else {
-  jumbo_source_set("native_theme_browser") {
+  source_set("native_theme_browser") {
   }
 }
 
-jumbo_source_set("test_support") {
+source_set("test_support") {
   testonly = true
 
   deps = [
-- 
2.43.0

