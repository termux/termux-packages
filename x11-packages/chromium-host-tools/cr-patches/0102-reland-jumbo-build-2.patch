https://github.com/qt/qtwebengine-chromium/commit/0e971d4a74288d5fa8b3dbebc2cc6423b034ed4a

diff --git a/base/BUILD.gn b/base/BUILD.gn
index 779a4f0b0e..3cabbdc5bf 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -1001,6 +1001,10 @@ jumbo_component("base") {
     ]
   }
 
+  jumbo_excluded_sources = [
+      "logging.cc",
+  ]
+
   if (is_linux || is_chromeos) {
     sources += [
       "debug/proc_maps_linux.cc",
@@ -1019,6 +1023,7 @@ jumbo_component("base") {
       "threading/thread_type_delegate.cc",
       "threading/thread_type_delegate.h",
     ]
+    jumbo_excluded_sources += [ "process/memory_linux.cc" ]
   }
 
   if (is_chromeos) {
@@ -1913,6 +1918,11 @@ jumbo_component("base") {
       "win/wrapped_window_proc.h",
     ]
 
+    # winternl.h and NTSecAPI.h have different definitions of UNICODE_STRING.
+    # There's only one client of NTSecAPI.h in base but several of winternl.h,
+    # so exclude the NTSecAPI.h one.
+    jumbo_excluded_sources += [ "rand_util_win.cc" ]
+
     deps += [ "//base/win:base_win_buildflags" ]
 
     if (com_init_check_hook_disabled) {
diff --git a/base/metrics/sample_map.cc b/base/metrics/sample_map.cc
index 427db0cce2..92d597cb12 100644
--- a/base/metrics/sample_map.cc
+++ b/base/metrics/sample_map.cc
@@ -20,14 +20,14 @@ namespace {
 // to that of the iterator for PersistentSampleMap but with different data
 // structures. Changes here likely need to be duplicated there.
 template <typename T, typename I>
-class IteratorTemplate : public SampleCountIterator {
+class IteratorTemplateSM : public SampleCountIterator {
  public:
-  explicit IteratorTemplate(T& sample_counts)
+  explicit IteratorTemplateSM(T& sample_counts)
       : iter_(sample_counts.begin()), end_(sample_counts.end()) {
     SkipEmptyBuckets();
   }
 
-  ~IteratorTemplate() override;
+  ~IteratorTemplateSM() override;
 
   // SampleCountIterator:
   bool Done() const override { return iter_ == end_; }
@@ -51,13 +51,13 @@ class IteratorTemplate : public SampleCountIterator {
   const I end_;
 };
 
-typedef std::map<HistogramBase::Sample, HistogramBase::Count> SampleToCountMap;
-typedef IteratorTemplate<const SampleToCountMap,
-                         SampleToCountMap::const_iterator>
+typedef std::map<HistogramBase::Sample, HistogramBase::Count> SampleToCountMapSM;
+typedef IteratorTemplateSM<const SampleToCountMapSM,
+                         SampleToCountMapSM::const_iterator>
     SampleMapIterator;
 
 template <>
-SampleMapIterator::~IteratorTemplate() = default;
+SampleMapIterator::~IteratorTemplateSM() = default;
 
 // Get() for an iterator of a SampleMap.
 template <>
@@ -73,11 +73,11 @@ void SampleMapIterator::Get(Sample* min, int64_t* max, Count* count) {
   *count = iter_->second;
 }
 
-typedef IteratorTemplate<SampleToCountMap, SampleToCountMap::iterator>
+typedef IteratorTemplateSM<SampleToCountMapSM, SampleToCountMapSM::iterator>
     ExtractingSampleMapIterator;
 
 template <>
-ExtractingSampleMapIterator::~IteratorTemplate() {
+ExtractingSampleMapIterator::~IteratorTemplateSM() {
   // Ensure that the user has consumed all the samples in order to ensure no
   // samples are lost.
   DCHECK(Done());
diff --git a/base/metrics/sample_vector.cc b/base/metrics/sample_vector.cc
index 8c45ddbccb..9b83989dcb 100644
--- a/base/metrics/sample_vector.cc
+++ b/base/metrics/sample_vector.cc
@@ -34,15 +34,15 @@ namespace {
 
 // An iterator for sample vectors.
 template <typename T>
-class IteratorTemplate : public SampleCountIterator {
+class IteratorTemplateSV : public SampleCountIterator {
  public:
-  IteratorTemplate(base::span<T> counts, const BucketRanges* bucket_ranges)
+  IteratorTemplateSV(base::span<T> counts, const BucketRanges* bucket_ranges)
       : counts_(counts), bucket_ranges_(bucket_ranges) {
     DCHECK_GE(bucket_ranges_->bucket_count(), counts_.size());
     SkipEmptyBuckets();
   }
 
-  ~IteratorTemplate() override;
+  ~IteratorTemplateSV() override;
 
   // SampleCountIterator:
   bool Done() const override { return index_ >= counts_.size(); }
@@ -83,14 +83,14 @@ class IteratorTemplate : public SampleCountIterator {
   size_t index_ = 0;
 };
 
-using SampleVectorIterator = IteratorTemplate<const HistogramBase::AtomicCount>;
+using SampleVectorIteratorSV = IteratorTemplateSV<const HistogramBase::AtomicCount>;
 
 template <>
-SampleVectorIterator::~IteratorTemplate() = default;
+SampleVectorIteratorSV::~IteratorTemplateSV() = default;
 
 // Get() for an iterator of a SampleVector.
 template <>
-void SampleVectorIterator::Get(HistogramBase::Sample* min,
+void SampleVectorIteratorSV::Get(HistogramBase::Sample* min,
                                int64_t* max,
                                HistogramBase::Count* count) {
   DCHECK(!Done());
@@ -100,10 +100,10 @@ void SampleVectorIterator::Get(HistogramBase::Sample* min,
 }
 
 using ExtractingSampleVectorIterator =
-    IteratorTemplate<HistogramBase::AtomicCount>;
+    IteratorTemplateSV<HistogramBase::AtomicCount>;
 
 template <>
-ExtractingSampleVectorIterator::~IteratorTemplate() {
+ExtractingSampleVectorIterator::~IteratorTemplateSV() {
   // Ensure that the user has consumed all the samples in order to ensure no
   // samples are lost.
   DCHECK(Done());
@@ -227,12 +227,12 @@ std::unique_ptr<SampleCountIterator> SampleVectorBase::Iterator() const {
 
   // Handle the multi-sample case.
   if (counts() || MountExistingCountsStorage()) {
-    return std::make_unique<SampleVectorIterator>(
+    return std::make_unique<SampleVectorIteratorSV>(
         base::make_span(counts(), counts_size()), bucket_ranges_);
   }
 
   // And the no-value case.
-  return std::make_unique<SampleVectorIterator>(
+  return std::make_unique<SampleVectorIteratorSV>(
       base::span<const HistogramBase::AtomicCount>(), bucket_ranges_);
 }
 
diff --git a/base/sampling_heap_profiler/sampling_heap_profiler.cc b/base/sampling_heap_profiler/sampling_heap_profiler.cc
index 324378ef37..e74841b00a 100644
--- a/base/sampling_heap_profiler/sampling_heap_profiler.cc
+++ b/base/sampling_heap_profiler/sampling_heap_profiler.cc
@@ -39,18 +39,18 @@ constexpr uint32_t kMaxStackEntries = 256;
 
 namespace {
 
-struct ThreadLocalData {
+struct ThreadLocalData_SHP {
   const char* thread_name = nullptr;
 };
 
-ThreadLocalData* GetThreadLocalData() {
+ThreadLocalData_SHP* GetThreadLocalData_SHP() {
 #if USE_LOCAL_TLS_EMULATION()
   static base::NoDestructor<
-      base::allocator::dispatcher::ThreadLocalStorage<ThreadLocalData>>
+      base::allocator::dispatcher::ThreadLocalStorage<ThreadLocalData_SHP>>
       thread_local_data("sampling_heap_profiler");
   return thread_local_data->GetThreadLocalData();
 #else
-  static thread_local ThreadLocalData thread_local_data;
+  static thread_local ThreadLocalData_SHP thread_local_data;
   return &thread_local_data;
 #endif
 }
@@ -99,7 +99,7 @@ const char* GetAndLeakThreadName() {
 }
 
 const char* UpdateAndGetThreadName(const char* name) {
-  ThreadLocalData* const thread_local_data = GetThreadLocalData();
+  ThreadLocalData_SHP* const thread_local_data = GetThreadLocalData_SHP();
   if (name)
     thread_local_data->thread_name = name;
   if (!thread_local_data->thread_name) {
@@ -322,7 +322,7 @@ std::vector<const char*> SamplingHeapProfiler::GetStrings() {
 
 // static
 void SamplingHeapProfiler::Init() {
-  GetThreadLocalData();
+  GetThreadLocalData_SHP();
   PoissonAllocationSampler::Init();
 }
 
diff --git a/base/task/sequence_manager/sequence_manager_impl.cc b/base/task/sequence_manager/sequence_manager_impl.cc
index 142bbad2ed..7fe962a084 100644
--- a/base/task/sequence_manager/sequence_manager_impl.cc
+++ b/base/task/sequence_manager/sequence_manager_impl.cc
@@ -159,7 +159,7 @@ char* PrependHexAddress(char* output, const void* address) {
 std::atomic_bool g_record_crash_keys = false;
 
 #if BUILDFLAG(IS_WIN)
-bool g_explicit_high_resolution_timer_win = true;
+bool g_explicit_high_resolution_timer_win_smi = true;
 #endif  // BUILDFLAG(IS_WIN)
 
 }  // namespace
@@ -297,7 +297,7 @@ void SequenceManagerImpl::InitializeFeatures() {
   MessagePump::InitializeFeatures();
   ThreadControllerWithMessagePumpImpl::InitializeFeatures();
 #if BUILDFLAG(IS_WIN)
-  g_explicit_high_resolution_timer_win =
+  g_explicit_high_resolution_timer_win_smi =
       FeatureList::IsEnabled(kExplicitHighResolutionTimerWin);
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -760,7 +760,7 @@ bool SequenceManagerImpl::HasPendingHighResolutionTasks() {
   // Only consider high-res tasks in the |wake_up_queue| (ignore the
   // |non_waking_wake_up_queue|).
 #if BUILDFLAG(IS_WIN)
-  if (g_explicit_high_resolution_timer_win) {
+  if (g_explicit_high_resolution_timer_win_smi) {
     absl::optional<WakeUp> wake_up =
         main_thread_only().wake_up_queue->GetNextDelayedWakeUp();
     if (!wake_up)
diff --git a/base/task/sequence_manager/task_order.cc b/base/task/sequence_manager/task_order.cc
index b2bdae4e9e..1e9635b289 100644
--- a/base/task/sequence_manager/task_order.cc
+++ b/base/task/sequence_manager/task_order.cc
@@ -17,7 +17,7 @@ namespace {
 // Returns true iff `task_order1` Comparator{} `task_order2`. Used to
 // implement other comparison operators.
 template <typename Comparator>
-static bool Compare(const base::sequence_manager::TaskOrder& task_order1,
+static bool CompareTO(const base::sequence_manager::TaskOrder& task_order1,
                     const base::sequence_manager::TaskOrder& task_order2) {
   Comparator cmp{};
 
@@ -60,19 +60,19 @@ TaskOrder& TaskOrder::operator=(const TaskOrder& other) = default;
 TaskOrder::~TaskOrder() = default;
 
 bool TaskOrder::operator>(const TaskOrder& other) const {
-  return Compare<std::greater<>>(*this, other);
+  return CompareTO<std::greater<>>(*this, other);
 }
 
 bool TaskOrder::operator<(const TaskOrder& other) const {
-  return Compare<std::less<>>(*this, other);
+  return CompareTO<std::less<>>(*this, other);
 }
 
 bool TaskOrder::operator<=(const TaskOrder& other) const {
-  return Compare<std::less_equal<>>(*this, other);
+  return CompareTO<std::less_equal<>>(*this, other);
 }
 
 bool TaskOrder::operator>=(const TaskOrder& other) const {
-  return Compare<std::greater_equal<>>(*this, other);
+  return CompareTO<std::greater_equal<>>(*this, other);
 }
 
 bool TaskOrder::operator==(const TaskOrder& other) const {
diff --git a/base/task/sequence_manager/task_queue_impl.cc b/base/task/sequence_manager/task_queue_impl.cc
index cb18ba61b8..8c509391e9 100644
--- a/base/task/sequence_manager/task_queue_impl.cc
+++ b/base/task/sequence_manager/task_queue_impl.cc
@@ -52,7 +52,7 @@ std::atomic<base::TimeDelta> g_max_precise_delay{kDefaultMaxPreciseDelay};
 #if BUILDFLAG(IS_WIN)
 // An atomic is used here because the flag is queried from other threads when
 // tasks are posted cross-thread, which can race with its initialization.
-std::atomic_bool g_explicit_high_resolution_timer_win{true};
+std::atomic_bool g_explicit_high_resolution_timer_win_tqi{true};
 #endif  // BUILDFLAG(IS_WIN)
 
 void RunTaskSynchronously(const AssociatedThreadId* associated_thread,
@@ -196,7 +196,7 @@ bool TaskQueueImpl::TaskRunner::RunsTasksInCurrentSequence() const {
 void TaskQueueImpl::InitializeFeatures() {
   g_max_precise_delay = kMaxPreciseDelay.Get();
 #if BUILDFLAG(IS_WIN)
-  g_explicit_high_resolution_timer_win.store(
+  g_explicit_high_resolution_timer_win_tqi.store(
       FeatureList::IsEnabled(kExplicitHighResolutionTimerWin),
       std::memory_order_relaxed);
 #endif  // BUILDFLAG(IS_WIN)
@@ -1050,7 +1050,7 @@ Task TaskQueueImpl::MakeDelayedTask(PostedTask delayed_task,
   WakeUpResolution resolution = WakeUpResolution::kLow;
 #if BUILDFLAG(IS_WIN)
   const bool explicit_high_resolution_timer_win =
-      g_explicit_high_resolution_timer_win.load(std::memory_order_relaxed);
+      g_explicit_high_resolution_timer_win_tqi.load(std::memory_order_relaxed);
 #endif  // BUILDFLAG(IS_WIN)
   if (absl::holds_alternative<base::TimeDelta>(
           delayed_task.delay_or_delayed_run_time)) {
diff --git a/base/task/single_thread_task_runner.cc b/base/task/single_thread_task_runner.cc
index 2b0ea0fe8e..995ad954c2 100644
--- a/base/task/single_thread_task_runner.cc
+++ b/base/task/single_thread_task_runner.cc
@@ -21,18 +21,18 @@ namespace base {
 namespace {
 
 ABSL_CONST_INIT thread_local SingleThreadTaskRunner::CurrentDefaultHandle*
-    current_default_handle = nullptr;
+    current_default_handleSTTR = nullptr;
 
 // This function can be removed, and the calls below replaced with direct
 // variable accesses, once the MSAN workaround is not necessary.
-SingleThreadTaskRunner::CurrentDefaultHandle* GetCurrentDefaultHandle() {
+SingleThreadTaskRunner::CurrentDefaultHandle* GetCurrentDefaultHandle2() {
   // Workaround false-positive MSAN use-of-uninitialized-value on
   // thread_local storage for loaded libraries:
   // https://github.com/google/sanitizers/issues/1265
-  MSAN_UNPOISON(&current_default_handle,
+  MSAN_UNPOISON(&current_default_handleSTTR,
                 sizeof(SingleThreadTaskRunner::CurrentDefaultHandle*));
 
-  return current_default_handle;
+  return current_default_handleSTTR;
 }
 
 }  // namespace
@@ -40,7 +40,7 @@ SingleThreadTaskRunner::CurrentDefaultHandle* GetCurrentDefaultHandle() {
 // static
 const scoped_refptr<SingleThreadTaskRunner>&
 SingleThreadTaskRunner::GetCurrentDefault() {
-  const auto* const handle = GetCurrentDefaultHandle();
+  const auto* const handle = GetCurrentDefaultHandle2();
   CHECK(handle)
       << "Error: This caller requires a single-threaded context (i.e. the "
          "current task needs to run from a SingleThreadTaskRunner). If you're "
@@ -56,12 +56,12 @@ SingleThreadTaskRunner::GetCurrentDefault() {
 
 // static
 bool SingleThreadTaskRunner::HasCurrentDefault() {
-  return !!GetCurrentDefaultHandle();
+  return !!GetCurrentDefaultHandle2();
 }
 
 SingleThreadTaskRunner::CurrentDefaultHandle::CurrentDefaultHandle(
     scoped_refptr<SingleThreadTaskRunner> task_runner)
-    : resetter_(&current_default_handle, this, nullptr),
+    : resetter_(&current_default_handleSTTR, this, nullptr),
       task_runner_(std::move(task_runner)),
       sequenced_task_runner_current_default_(task_runner_) {
   DCHECK(task_runner_->BelongsToCurrentThread());
@@ -69,7 +69,7 @@ SingleThreadTaskRunner::CurrentDefaultHandle::CurrentDefaultHandle(
 
 SingleThreadTaskRunner::CurrentDefaultHandle::~CurrentDefaultHandle() {
   DCHECK(task_runner_->BelongsToCurrentThread());
-  DCHECK_EQ(GetCurrentDefaultHandle(), this);
+  DCHECK_EQ(GetCurrentDefaultHandle2(), this);
 }
 
 SingleThreadTaskRunner::CurrentHandleOverride::CurrentHandleOverride(
@@ -92,7 +92,7 @@ SingleThreadTaskRunner::CurrentHandleOverride::CurrentHandleOverride(
 #if DCHECK_IS_ON()
   expected_task_runner_before_restore_ = overriding_task_runner.get();
 #endif
-  auto* const handle = GetCurrentDefaultHandle();
+  auto* const handle = GetCurrentDefaultHandle2();
   SequencedTaskRunner::SetCurrentDefaultHandleTaskRunner(
       handle->sequenced_task_runner_current_default_, overriding_task_runner);
   handle->task_runner_.swap(overriding_task_runner);
@@ -108,7 +108,7 @@ SingleThreadTaskRunner::CurrentHandleOverride::CurrentHandleOverride(
 
 SingleThreadTaskRunner::CurrentHandleOverride::~CurrentHandleOverride() {
   if (task_runner_to_restore_) {
-    auto* const handle = GetCurrentDefaultHandle();
+    auto* const handle = GetCurrentDefaultHandle2();
 #if DCHECK_IS_ON()
     DCHECK_EQ(expected_task_runner_before_restore_, handle->task_runner_.get())
         << "Nested overrides must expire their "
diff --git a/base/task/thread_pool/job_task_source_old.cc b/base/task/thread_pool/job_task_source_old.cc
index 5fb4856bd3..060e7d26c4 100644
--- a/base/task/thread_pool/job_task_source_old.cc
+++ b/base/task/thread_pool/job_task_source_old.cc
@@ -28,13 +28,13 @@ namespace internal {
 namespace {
 
 // Capped to allow assigning task_ids from a bitfield.
-constexpr size_t kMaxWorkersPerJob = 32;
+constexpr size_t kMaxWorkersPerJobJTSO = 32;
 static_assert(
-    kMaxWorkersPerJob <=
+    kMaxWorkersPerJobJTSO <=
         std::numeric_limits<
             std::invoke_result<decltype(&JobDelegate::GetTaskId),
                                JobDelegate>::type>::max(),
-    "AcquireTaskId return type isn't big enough to fit kMaxWorkersPerJob");
+    "AcquireTaskId return type isn't big enough to fit kMaxWorkersPerJobJTSO");
 
 }  // namespace
 
@@ -308,12 +308,12 @@ size_t JobTaskSourceOld::GetMaxConcurrency() const {
 
 size_t JobTaskSourceOld::GetMaxConcurrency(size_t worker_count) const {
   return std::min(max_concurrency_callback_.Run(worker_count),
-                  kMaxWorkersPerJob);
+                  kMaxWorkersPerJobJTSO);
 }
 
 uint8_t JobTaskSourceOld::AcquireTaskId() {
-  static_assert(kMaxWorkersPerJob <= sizeof(assigned_task_ids_) * 8,
-                "TaskId bitfield isn't big enough to fit kMaxWorkersPerJob.");
+  static_assert(kMaxWorkersPerJobJTSO <= sizeof(assigned_task_ids_) * 8,
+                "TaskId bitfield isn't big enough to fit kMaxWorkersPerJobJTSO.");
   uint32_t assigned_task_ids =
       assigned_task_ids_.load(std::memory_order_relaxed);
   uint32_t new_assigned_task_ids = 0;
diff --git a/base/task/thread_pool/thread_group_impl.cc b/base/task/thread_pool/thread_group_impl.cc
index c8e906d6b4..dab9496bfe 100644
--- a/base/task/thread_pool/thread_group_impl.cc
+++ b/base/task/thread_pool/thread_group_impl.cc
@@ -24,7 +24,7 @@ namespace internal {
 
 namespace {
 
-constexpr size_t kMaxNumberOfWorkers = 256;
+constexpr size_t kMaxNumberOfWorkers2 = 256;
 
 }  // namespace
 
@@ -595,10 +595,10 @@ size_t ThreadGroupImpl::NumberOfIdleWorkersForTesting() const {
 
 void ThreadGroupImpl::MaintainAtLeastOneIdleWorkerLockRequired(
     ScopedCommandsExecutor* executor) {
-  if (workers_.size() == kMaxNumberOfWorkers) {
+  if (workers_.size() == kMaxNumberOfWorkers2) {
     return;
   }
-  DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
+  DCHECK_LT(workers_.size(), kMaxNumberOfWorkers2);
 
   if (!idle_workers_set_.IsEmpty()) {
     return;
@@ -619,7 +619,7 @@ ThreadGroupImpl::CreateAndRegisterWorkerLockRequired(
     ScopedCommandsExecutor* executor) {
   DCHECK(!join_for_testing_started_);
   DCHECK_LT(workers_.size(), max_tasks_);
-  DCHECK_LT(workers_.size(), kMaxNumberOfWorkers);
+  DCHECK_LT(workers_.size(), kMaxNumberOfWorkers2);
   DCHECK(idle_workers_set_.IsEmpty());
 
   // WorkerThread needs |lock_| as a predecessor for its thread lock because in
diff --git a/base/trace_event/trace_log.cc b/base/trace_event/trace_log.cc
index 03e14fcd1c..ab4872eed8 100644
--- a/base/trace_event/trace_log.cc
+++ b/base/trace_event/trace_log.cc
@@ -166,13 +166,13 @@ bool DefaultIsTraceEventArgsAllowlisted(
 }
 
 #if BUILDFLAG(USE_PERFETTO_CLIENT_LIBRARY)
-class PerfettoProtoAppender
+class PerfettoProtoAppenderTL
     : public base::trace_event::ConvertableToTraceFormat::ProtoAppender {
  public:
-  explicit PerfettoProtoAppender(
+  explicit PerfettoProtoAppenderTL(
       perfetto::protos::pbzero::DebugAnnotation* proto)
       : annotation_proto_(proto) {}
-  ~PerfettoProtoAppender() override = default;
+  ~PerfettoProtoAppenderTL() override = default;
 
   // ProtoAppender implementation
   void AddBuffer(uint8_t* begin, uint8_t* end) override {
@@ -194,7 +194,7 @@ class PerfettoProtoAppender
 void AddConvertableToTraceFormat(
     base::trace_event::ConvertableToTraceFormat* value,
     perfetto::protos::pbzero::DebugAnnotation* annotation) {
-  PerfettoProtoAppender proto_appender(annotation);
+  PerfettoProtoAppenderTL proto_appender(annotation);
   if (value->AppendToProto(&proto_appender)) {
     return;
   }
diff --git a/build/config/jumbo.gni b/build/config/jumbo.gni
index dd8972423e..0253149088 100644
--- a/build/config/jumbo.gni
+++ b/build/config/jumbo.gni
@@ -78,7 +78,7 @@ template("internal_jumbo_target") {
   if (defined(invoker.never_build_jumbo) && invoker.never_build_jumbo) {
     use_jumbo_build_for_target = false
   }
-  if (is_nacl_irt || is_nacl_nonsfi) {
+  if (is_nacl_irt) {
     # The code is barely compatible with the nacl toolchain anymore and we
     # don't want to stress it further with jumbo compilation units.
     use_jumbo_build_for_target = false
diff --git a/cc/metrics/compositor_frame_reporter.cc b/cc/metrics/compositor_frame_reporter.cc
index 1392e85dc2..5435400e7c 100644
--- a/cc/metrics/compositor_frame_reporter.cc
+++ b/cc/metrics/compositor_frame_reporter.cc
@@ -175,12 +175,12 @@ void ReportEventLatencyMetric(
   }
 }
 
-constexpr char kTraceCategory[] =
+constexpr char kTraceCategory2[] =
     "cc,benchmark," TRACE_DISABLED_BY_DEFAULT("devtools.timeline.frame");
 
 bool IsTracingEnabled() {
   bool enabled;
-  TRACE_EVENT_CATEGORY_GROUP_ENABLED(kTraceCategory, &enabled);
+  TRACE_EVENT_CATEGORY_GROUP_ENABLED(kTraceCategory2, &enabled);
   return enabled;
 }
 
@@ -1304,7 +1304,7 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
   const auto trace_track =
       perfetto::Track(base::trace_event::GetNextGlobalTraceId());
   TRACE_EVENT_BEGIN(
-      kTraceCategory, "PipelineReporter", trace_track, args_.frame_time,
+      kTraceCategory2, "PipelineReporter", trace_track, args_.frame_time,
       [&](perfetto::EventContext context) {
         using perfetto::protos::pbzero::ChromeFrameReporter;
         ChromeFrameReporter::State state;
@@ -1385,7 +1385,7 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
 
     if (stage.stage_type == StageType::kSendBeginMainFrameToCommit) {
       TRACE_EVENT_BEGIN(
-          kTraceCategory, perfetto::StaticString{stage_name}, trace_track,
+          kTraceCategory2, perfetto::StaticString{stage_name}, trace_track,
           stage.start_time, [&](perfetto::EventContext context) {
             DCHECK(processed_blink_breakdown_);
             auto* reporter =
@@ -1435,7 +1435,7 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
             }
           });
     } else {
-      TRACE_EVENT_BEGIN(kTraceCategory, perfetto::StaticString{stage_name},
+      TRACE_EVENT_BEGIN(kTraceCategory2, perfetto::StaticString{stage_name},
                         trace_track, stage.start_time);
     }
 
@@ -1449,16 +1449,16 @@ void CompositorFrameReporter::ReportCompositorLatencyTraceEvents(
         if (start_time >= end_time)
           continue;
         const char* breakdown_name = GetVizBreakdownName(it.GetBreakdown());
-        TRACE_EVENT_BEGIN(kTraceCategory,
+        TRACE_EVENT_BEGIN(kTraceCategory2,
                           perfetto::StaticString{breakdown_name}, trace_track,
                           start_time);
-        TRACE_EVENT_END(kTraceCategory, trace_track, end_time);
+        TRACE_EVENT_END(kTraceCategory2, trace_track, end_time);
       }
     }
-    TRACE_EVENT_END(kTraceCategory, trace_track, stage.end_time);
+    TRACE_EVENT_END(kTraceCategory2, trace_track, stage.end_time);
   }
 
-  TRACE_EVENT_END(kTraceCategory, trace_track, frame_termination_time_);
+  TRACE_EVENT_END(kTraceCategory2, trace_track, frame_termination_time_);
 }
 
 void CompositorFrameReporter::ReportScrollJankMetrics() const {
diff --git a/cc/metrics/compositor_frame_reporting_controller.cc b/cc/metrics/compositor_frame_reporting_controller.cc
index 3efdc1dba6..938a6812c6 100644
--- a/cc/metrics/compositor_frame_reporting_controller.cc
+++ b/cc/metrics/compositor_frame_reporting_controller.cc
@@ -24,10 +24,10 @@ using SmoothThread = CompositorFrameReporter::SmoothThread;
 using StageType = CompositorFrameReporter::StageType;
 using FrameTerminationStatus = CompositorFrameReporter::FrameTerminationStatus;
 
-constexpr char kTraceCategory[] = "cc,benchmark";
-constexpr int kNumOfCompositorStages =
+constexpr char kTraceCategory3[] = "cc,benchmark";
+constexpr int kNumOfCompositorStages3 =
     static_cast<int>(StageType::kStageTypeCount) - 1;
-constexpr int kNumDispatchStages =
+constexpr int kNumDispatchStages3 =
     static_cast<int>(EventMetrics::DispatchStage::kMaxValue);
 constexpr base::TimeDelta kDefaultLatencyPredictionDeviationThreshold =
     viz::BeginFrameArgs::DefaultInterval() / 2;
@@ -47,8 +47,8 @@ CompositorFrameReportingController::CompositorFrameReportingController(
       previous_latency_predictions_main_(base::Microseconds(-1)),
       previous_latency_predictions_impl_(base::Microseconds(-1)),
       event_latency_predictions_(
-          CompositorFrameReporter::EventLatencyInfo(kNumDispatchStages,
-                                                    kNumOfCompositorStages)) {
+          CompositorFrameReporter::EventLatencyInfo(kNumDispatchStages3,
+                                                    kNumOfCompositorStages3)) {
   if (should_report_ukm) {
     // UKM metrics should be reported if and only if `latency_ukm_reporter` is
     // set on `global_trackers_`.
@@ -465,9 +465,9 @@ void CompositorFrameReportingController::ReportMultipleSwaps(
 
       const auto trace_track =
           perfetto::Track(base::trace_event::GetNextGlobalTraceId());
-      TRACE_EVENT_BEGIN(kTraceCategory, "MultipleSwaps", trace_track,
+      TRACE_EVENT_BEGIN(kTraceCategory3, "MultipleSwaps", trace_track,
                         latest_swap_times_.front());
-      TRACE_EVENT_END(kTraceCategory, trace_track, latest_swap_times_.back());
+      TRACE_EVENT_END(kTraceCategory3, trace_track, latest_swap_times_.back());
     }
   }
 }
diff --git a/cc/metrics/event_latency_tracing_recorder.cc b/cc/metrics/event_latency_tracing_recorder.cc
index fa2db3de1e..10fbbbc5bd 100644
--- a/cc/metrics/event_latency_tracing_recorder.cc
+++ b/cc/metrics/event_latency_tracing_recorder.cc
@@ -18,7 +18,7 @@ namespace {
 
 constexpr char kTracingCategory[] = "cc,benchmark,input,input.scrolling";
 
-bool IsTracingEnabled() {
+bool IsTracingEnabled2() {
   bool enabled;
   TRACE_EVENT_CATEGORY_GROUP_ENABLED(kTracingCategory, &enabled);
   return enabled;
@@ -215,7 +215,7 @@ void EventLatencyTracingRecorder::RecordEventLatencyTraceEvent(
     const CompositorFrameReporter::ProcessedVizBreakdown* viz_breakdown) {
   // As there are multiple teardown paths for EventMetrics, we want to denote
   // the attempt to trace, even if tracing is currently disabled.
-  if (IsTracingEnabled()) {
+  if (IsTracingEnabled2()) {
     RecordEventLatencyTraceEventInternal(event_metrics, termination_time,
                                          vsync_interval, stage_history,
                                          viz_breakdown);
diff --git a/cc/metrics/frame_sequence_tracker.cc b/cc/metrics/frame_sequence_tracker.cc
index 4988fad0fc..eb25741952 100644
--- a/cc/metrics/frame_sequence_tracker.cc
+++ b/cc/metrics/frame_sequence_tracker.cc
@@ -38,7 +38,7 @@ namespace cc {
 
 namespace {
 
-constexpr char kTraceCategory[] =
+constexpr char kTraceCategoryFST[] =
     "cc,benchmark," TRACE_DISABLED_BY_DEFAULT("devtools.timeline.frame");
 
 }  // namespace
@@ -91,7 +91,7 @@ FrameSequenceTracker::FrameSequenceTracker(FrameSequenceTrackerType type)
   // TODO(crbug.com/1158439): remove the trace event once the validation is
   // completed.
   TRACE_EVENT_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP1(
-      kTraceCategory, "TrackerValidation", TRACE_ID_LOCAL(this),
+      kTraceCategoryFST, "TrackerValidation", TRACE_ID_LOCAL(this),
       base::TimeTicks::Now(), "name", GetFrameSequenceTrackerTypeName(type));
 }
 
@@ -107,7 +107,7 @@ FrameSequenceTracker::FrameSequenceTracker(
 
 FrameSequenceTracker::~FrameSequenceTracker() {
   TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP2(
-      kTraceCategory, "TrackerValidation", TRACE_ID_LOCAL(this),
+      kTraceCategoryFST, "TrackerValidation", TRACE_ID_LOCAL(this),
       base::TimeTicks::Now(), "aborted_main", aborted_main_frame_,
       "no_damage_main", no_damage_draw_main_frames_);
   CleanUp();
diff --git a/cc/metrics/jank_metrics.cc b/cc/metrics/jank_metrics.cc
index c8ce4e823d..222cdc7f58 100644
--- a/cc/metrics/jank_metrics.cc
+++ b/cc/metrics/jank_metrics.cc
@@ -21,9 +21,9 @@ namespace cc {
 namespace {
 
 constexpr uint64_t kMaxNoUpdateFrameQueueLength = 100;
-constexpr int kBuiltinSequenceNum =
+constexpr int kBuiltinJankSequenceNum =
     static_cast<int>(FrameSequenceTrackerType::kMaxType) + 1;
-constexpr int kMaximumStaleHistogramIndex = kBuiltinSequenceNum;
+constexpr int kMaximumJankStaleHistogramIndex = kBuiltinJankSequenceNum;
 
 constexpr base::TimeDelta kStaleHistogramMin = base::Microseconds(1);
 constexpr base::TimeDelta kStaleHistogramMax = base::Milliseconds(1000);
@@ -182,7 +182,7 @@ void JankMetrics::AddPresentedFrame(
     if (tracker_type_ != FrameSequenceTrackerType::kCustom) {
       STATIC_HISTOGRAM_POINTER_GROUP(
           GetStaleHistogramName(tracker_type_),
-          GetIndexForStaleMetric(tracker_type_), kMaximumStaleHistogramIndex,
+          GetIndexForStaleMetric(tracker_type_), kMaximumJankStaleHistogramIndex,
           AddTimeMillisecondsGranularity(staleness),
           base::Histogram::FactoryTimeGet(
               GetStaleHistogramName(tracker_type_), kStaleHistogramMin,
@@ -209,7 +209,7 @@ void JankMetrics::ReportJankMetrics(int frames_expected) {
   // Report the max staleness metrics
   STATIC_HISTOGRAM_POINTER_GROUP(
       GetMaxStaleHistogramName(tracker_type_),
-      GetIndexForStaleMetric(tracker_type_), kMaximumStaleHistogramIndex,
+      GetIndexForStaleMetric(tracker_type_), kMaximumJankStaleHistogramIndex,
       AddTimeMillisecondsGranularity(max_staleness_),
       base::Histogram::FactoryTimeGet(
           GetMaxStaleHistogramName(tracker_type_), kStaleHistogramMin,
diff --git a/components/autofill/content/renderer/BUILD.gn b/components/autofill/content/renderer/BUILD.gn
index e4813b9dea..d779108937 100644
--- a/components/autofill/content/renderer/BUILD.gn
+++ b/components/autofill/content/renderer/BUILD.gn
@@ -40,6 +40,10 @@ jumbo_static_library("renderer") {
     "suggestion_properties.h",
   ]
 
+  jumbo_excluded_sources = [
+    "form_cache.cc",
+  ]
+
   deps = [
     "//base",
     "//base:i18n",
diff --git a/components/download/internal/common/BUILD.gn b/components/download/internal/common/BUILD.gn
index a75968d214..f5844398f4 100644
--- a/components/download/internal/common/BUILD.gn
+++ b/components/download/internal/common/BUILD.gn
@@ -2,6 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/jumbo.gni")
 import("//components/safe_browsing/buildflags.gni")
 
 if (is_android) {
@@ -10,7 +11,7 @@ if (is_android) {
   import("//third_party/jni_zero/jni_zero.gni")
 }
 
-source_set("internal") {
+jumbo_source_set("internal") {
   visibility = [
     ":for_tests",
     "//components/download/public/common:public",
diff --git a/components/guest_view/browser/BUILD.gn b/components/guest_view/browser/BUILD.gn
index 549f05877a..36c23e0ead 100644
--- a/components/guest_view/browser/BUILD.gn
+++ b/components/guest_view/browser/BUILD.gn
@@ -8,7 +8,9 @@
 # remove this assert.
 assert(!is_android)
 
-static_library("browser") {
+import("//build/config/jumbo.gni")
+
+jumbo_static_library("browser") {
   output_name = "guest_view_browser"
   sources = [
     "//components/guest_view/browser/bad_message.cc",
diff --git a/components/guest_view/renderer/BUILD.gn b/components/guest_view/renderer/BUILD.gn
index d12cd543e3..b6d9838916 100644
--- a/components/guest_view/renderer/BUILD.gn
+++ b/components/guest_view/renderer/BUILD.gn
@@ -8,7 +8,9 @@
 # remove this assert.
 assert(!is_android && !is_ios)
 
-static_library("renderer") {
+import("//build/config/jumbo.gni")
+
+jumbo_static_library("renderer") {
   sources = [
     "guest_view_container.cc",
     "guest_view_container.h",
diff --git a/components/metrics/BUILD.gn b/components/metrics/BUILD.gn
index 5bdc91344d..7cf71b05b6 100644
--- a/components/metrics/BUILD.gn
+++ b/components/metrics/BUILD.gn
@@ -298,7 +298,7 @@ if (!is_cronet_build || is_ios) {
     }
   }
 
-  jumvo_static_library("test_support") {
+  jumbo_static_library("test_support") {
     testonly = true
     sources = [
       "test/test_enabled_state_provider.cc",
diff --git a/components/metrics/metrics_log.cc b/components/metrics/metrics_log.cc
index 2fe044313f..605059bf52 100644
--- a/components/metrics/metrics_log.cc
+++ b/components/metrics/metrics_log.cc
@@ -332,8 +332,8 @@ void MetricsLog::RecordCoreSystemProfile(MetricsServiceClient* client,
   // Exclude these switches which are very frequently on the command line but
   // serve no meaningful purpose.
   static const char* const kSwitchesToFilter[] = {
-      switches::kFlagSwitchesBegin,
-      switches::kFlagSwitchesEnd,
+      ::switches::kFlagSwitchesBegin,
+      ::switches::kFlagSwitchesEnd,
   };
 
   for (const char* filter_switch : kSwitchesToFilter)
diff --git a/components/metrics/metrics_state_manager.cc b/components/metrics/metrics_state_manager.cc
index f51f4ed792..86a1db9715 100644
--- a/components/metrics/metrics_state_manager.cc
+++ b/components/metrics/metrics_state_manager.cc
@@ -527,8 +527,8 @@ MetricsStateManager::CreateEntropyProviders() {
   return std::make_unique<variations::EntropyProviders>(
       GetHighEntropySource(),
       variations::ValueInRange{
-          .value = base::checked_cast<uint32_t>(GetLowEntropySource()),
-          .range = EntropyState::kMaxLowEntropySize},
+          /*.value =*/ base::checked_cast<uint32_t>(GetLowEntropySource()),
+          /*.range =*/ EntropyState::kMaxLowEntropySize},
       ShouldEnableBenchmarking(entropy_params_.force_benchmarking_mode));
 }
 
diff --git a/components/performance_manager/BUILD.gn b/components/performance_manager/BUILD.gn
index 60b6e90efd..a877db3439 100644
--- a/components/performance_manager/BUILD.gn
+++ b/components/performance_manager/BUILD.gn
@@ -2,13 +2,14 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/jumbo.gni")
 import("//third_party/protobuf/proto_library.gni")
 
 proto_library("site_data_proto") {
   sources = [ "persistence/site_data/site_data.proto" ]
 }
 
-static_library("performance_manager") {
+jumbo_static_library("performance_manager") {
   sources = [
     "binders.cc",
     "browser_child_process_host_proxy.cc",
@@ -286,6 +287,7 @@ static_library("performance_manager") {
       "public/persistence/site_data/feature_usage.h",
       "public/persistence/site_data/site_data_reader.h",
     ]
+    jumbo_excluded_sources = [ "decorators/site_data_recorder.cc" ]
 
     public_deps += [
       ":site_data_proto",
diff --git a/components/performance_manager/decorators/page_live_state_decorator.cc b/components/performance_manager/decorators/page_live_state_decorator.cc
index fcceab286a..1d90cac3e5 100644
--- a/components/performance_manager/decorators/page_live_state_decorator.cc
+++ b/components/performance_manager/decorators/page_live_state_decorator.cc
@@ -285,8 +285,6 @@ class PageLiveStateDataImpl
   const raw_ptr<const PageNode> page_node_;
 };
 
-const char kDescriberName[] = "PageLiveStateDecorator";
-
 }  // namespace
 
 void PageLiveStateDecorator::Delegate::GetContentSettingsAndReply(
@@ -420,7 +418,7 @@ void PageLiveStateDecorator::SetIsDevToolsOpen(content::WebContents* contents,
 
 void PageLiveStateDecorator::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "PageLiveStateDecorator");
   graph->AddPageNodeObserver(this);
 }
 
diff --git a/components/performance_manager/decorators/page_load_tracker_decorator.cc b/components/performance_manager/decorators/page_load_tracker_decorator.cc
index a408640407..05f1122d10 100644
--- a/components/performance_manager/decorators/page_load_tracker_decorator.cc
+++ b/components/performance_manager/decorators/page_load_tracker_decorator.cc
@@ -68,8 +68,6 @@ const char* ToString(LoadIdleState state) {
   }
 }
 
-const char kDescriberName[] = "PageLoadTrackerDecorator";
-
 }  // namespace
 
 // static
@@ -94,7 +92,7 @@ void PageLoadTrackerDecorator::OnNetworkAlmostIdleChanged(
 void PageLoadTrackerDecorator::OnPassedToGraph(Graph* graph) {
   RegisterObservers(graph);
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "PageLoadTrackerDecorator");
 }
 
 void PageLoadTrackerDecorator::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/decorators/process_priority_aggregator.cc b/components/performance_manager/decorators/process_priority_aggregator.cc
index 71b56dd930..c36792fa58 100644
--- a/components/performance_manager/decorators/process_priority_aggregator.cc
+++ b/components/performance_manager/decorators/process_priority_aggregator.cc
@@ -25,15 +25,15 @@ namespace {
 
 const char kDescriberName[] = "ProcessPriorityAggregator";
 
-class DataImpl : public ProcessPriorityAggregator::Data,
-                 public NodeAttachedDataImpl<DataImpl> {
+class DataImplPPA : public ProcessPriorityAggregator::Data,
+                 public NodeAttachedDataImpl<DataImplPPA> {
  public:
   using StorageType = ProcessPriorityAggregatorAccess::StorageType;
 
   struct Traits : public NodeAttachedDataOwnedByNodeType<ProcessNodeImpl> {};
 
-  explicit DataImpl(const ProcessNode* process_node) {}
-  ~DataImpl() override {}
+  explicit DataImplPPA(const ProcessNode* process_node) {}
+  ~DataImplPPA() override {}
 
   static std::unique_ptr<NodeAttachedData>* GetUniquePtrStorage(
       ProcessNodeImpl* process_node) {
@@ -109,7 +109,7 @@ base::TaskPriority ProcessPriorityAggregator::Data::GetPriority() const {
 // static
 ProcessPriorityAggregator::Data* ProcessPriorityAggregator::Data::GetForTesting(
     ProcessNodeImpl* process_node) {
-  return DataImpl::Get(process_node);
+  return DataImplPPA::Get(process_node);
 }
 
 ProcessPriorityAggregator::ProcessPriorityAggregator() = default;
@@ -149,7 +149,7 @@ void ProcessPriorityAggregator::OnTakenFromGraph(Graph* graph) {
 
 base::Value::Dict ProcessPriorityAggregator::DescribeProcessNodeData(
     const ProcessNode* node) const {
-  DataImpl* data = DataImpl::Get(ProcessNodeImpl::FromNode(node));
+  DataImplPPA* data = DataImplPPA::Get(ProcessNodeImpl::FromNode(node));
   if (data == nullptr)
     return base::Value::Dict();
 
@@ -165,14 +165,14 @@ base::Value::Dict ProcessPriorityAggregator::DescribeProcessNodeData(
 void ProcessPriorityAggregator::OnProcessNodeAdded(
     const ProcessNode* process_node) {
   auto* process_node_impl = ProcessNodeImpl::FromNode(process_node);
-  DCHECK(!DataImpl::Get(process_node_impl));
+  DCHECK(!DataImplPPA::Get(process_node_impl));
 }
 
 void ProcessPriorityAggregator::OnBeforeProcessNodeRemoved(
     const ProcessNode* process_node) {
 #if DCHECK_IS_ON()
   auto* process_node_impl = ProcessNodeImpl::FromNode(process_node);
-  DataImpl* data = DataImpl::Get(process_node_impl);
+  DataImplPPA* data = DataImplPPA::Get(process_node_impl);
   if (data) {
     DCHECK(data->IsEmpty());
   }
@@ -182,7 +182,7 @@ void ProcessPriorityAggregator::OnBeforeProcessNodeRemoved(
 void ProcessPriorityAggregator::OnExecutionContextAdded(
     const execution_context::ExecutionContext* ec) {
   auto* process_node = ProcessNodeImpl::FromNode(ec->GetProcessNode());
-  DataImpl* data = DataImpl::GetOrCreate(process_node);
+  DataImplPPA* data = DataImplPPA::GetOrCreate(process_node);
   data->Increment(ec->GetPriorityAndReason().priority());
   // This is a nop if the priority didn't actually change.
   process_node->set_priority(data->GetPriority());
@@ -191,7 +191,7 @@ void ProcessPriorityAggregator::OnExecutionContextAdded(
 void ProcessPriorityAggregator::OnBeforeExecutionContextRemoved(
     const execution_context::ExecutionContext* ec) {
   auto* process_node = ProcessNodeImpl::FromNode(ec->GetProcessNode());
-  DataImpl* data = DataImpl::Get(process_node);
+  DataImplPPA* data = DataImplPPA::Get(process_node);
   data->Decrement(ec->GetPriorityAndReason().priority());
   // This is a nop if the priority didn't actually change.
   process_node->set_priority(data->GetPriority());
@@ -208,7 +208,7 @@ void ProcessPriorityAggregator::OnPriorityAndReasonChanged(
   // Update the distinct frame priority counts, and set the process priority
   // accordingly.
   auto* process_node = ProcessNodeImpl::FromNode(ec->GetProcessNode());
-  DataImpl* data = DataImpl::Get(process_node);
+  DataImplPPA* data = DataImplPPA::Get(process_node);
   data->Decrement(previous_value.priority());
   data->Increment(new_value.priority());
   // This is a nop if the priority didn't actually change.
diff --git a/components/performance_manager/execution_context_priority/frame_audible_voter.cc b/components/performance_manager/execution_context_priority/frame_audible_voter.cc
index 22baf9b8bc..4f2147692f 100644
--- a/components/performance_manager/execution_context_priority/frame_audible_voter.cc
+++ b/components/performance_manager/execution_context_priority/frame_audible_voter.cc
@@ -13,7 +13,7 @@ namespace execution_context_priority {
 
 namespace {
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext2(
     const FrameNode* frame_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              frame_node->GetGraph())
@@ -43,16 +43,16 @@ void FrameAudibleVoter::SetVotingChannel(VotingChannel voting_channel) {
 
 void FrameAudibleVoter::OnFrameNodeInitializing(const FrameNode* frame_node) {
   const Vote vote = GetVote(frame_node->IsAudible());
-  voting_channel_.SubmitVote(GetExecutionContext(frame_node), vote);
+  voting_channel_.SubmitVote(GetExecutionContext2(frame_node), vote);
 }
 
 void FrameAudibleVoter::OnFrameNodeTearingDown(const FrameNode* frame_node) {
-  voting_channel_.InvalidateVote(GetExecutionContext(frame_node));
+  voting_channel_.InvalidateVote(GetExecutionContext2(frame_node));
 }
 
 void FrameAudibleVoter::OnIsAudibleChanged(const FrameNode* frame_node) {
   const Vote new_vote = GetVote(frame_node->IsAudible());
-  voting_channel_.ChangeVote(GetExecutionContext(frame_node), new_vote);
+  voting_channel_.ChangeVote(GetExecutionContext2(frame_node), new_vote);
 }
 
 }  // namespace execution_context_priority
diff --git a/components/performance_manager/execution_context_priority/frame_visibility_voter.cc b/components/performance_manager/execution_context_priority/frame_visibility_voter.cc
index 1abbba23f5..e101384e78 100644
--- a/components/performance_manager/execution_context_priority/frame_visibility_voter.cc
+++ b/components/performance_manager/execution_context_priority/frame_visibility_voter.cc
@@ -14,7 +14,7 @@ namespace execution_context_priority {
 
 namespace {
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext5(
     const FrameNode* frame_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              frame_node->GetGraph())
@@ -23,7 +23,7 @@ const execution_context::ExecutionContext* GetExecutionContext(
 
 // Returns a vote with the appropriate priority depending on the frame's
 // |visibility|.
-Vote GetVote(FrameNode::Visibility visibility) {
+Vote GetVote2(FrameNode::Visibility visibility) {
   base::TaskPriority priority;
   switch (visibility) {
     case FrameNode::Visibility::kUnknown:
@@ -54,24 +54,24 @@ void FrameVisibilityVoter::SetVotingChannel(VotingChannel voting_channel) {
 
 void FrameVisibilityVoter::OnFrameNodeInitializing(
     const FrameNode* frame_node) {
-  const Vote vote = GetVote(frame_node->GetVisibility());
-  voting_channel_.SubmitVote(GetExecutionContext(frame_node), vote);
+  const Vote vote = GetVote2(frame_node->GetVisibility());
+  voting_channel_.SubmitVote(GetExecutionContext5(frame_node), vote);
 }
 
 void FrameVisibilityVoter::OnFrameNodeTearingDown(const FrameNode* frame_node) {
-  voting_channel_.InvalidateVote(GetExecutionContext(frame_node));
+  voting_channel_.InvalidateVote(GetExecutionContext5(frame_node));
 }
 
 void FrameVisibilityVoter::OnFrameVisibilityChanged(
     const FrameNode* frame_node,
     FrameNode::Visibility previous_value) {
-  const Vote new_vote = GetVote(frame_node->GetVisibility());
+  const Vote new_vote = GetVote2(frame_node->GetVisibility());
 
   // Nothing to change if the new priority is the same as the old one.
-  if (new_vote == GetVote(previous_value))
+  if (new_vote == GetVote2(previous_value))
     return;
 
-  voting_channel_.ChangeVote(GetExecutionContext(frame_node), new_vote);
+  voting_channel_.ChangeVote(GetExecutionContext5(frame_node), new_vote);
 }
 
 }  // namespace execution_context_priority
diff --git a/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc b/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc
index 92c1f24200..63af7c759c 100644
--- a/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc
+++ b/components/performance_manager/execution_context_priority/inherit_client_priority_voter.cc
@@ -16,14 +16,14 @@ namespace execution_context_priority {
 
 namespace {
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext_ICPV(
     const FrameNode* frame_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              frame_node->GetGraph())
       ->GetExecutionContextForFrameNode(frame_node);
 }
 
-const execution_context::ExecutionContext* GetExecutionContext(
+const execution_context::ExecutionContext* GetExecutionContext_ICPV(
     const WorkerNode* worker_node) {
   return execution_context::ExecutionContextRegistry::GetFromGraph(
              worker_node->GetGraph())
@@ -50,7 +50,7 @@ void InheritClientPriorityVoter::SetVotingChannel(
 
 void InheritClientPriorityVoter::OnFrameNodeAdded(const FrameNode* frame_node) {
   bool inserted = voting_channels_
-                      .emplace(GetExecutionContext(frame_node),
+                      .emplace(GetExecutionContext_ICPV(frame_node),
                                max_vote_aggregator_.GetVotingChannel())
                       .second;
   DCHECK(inserted);
@@ -60,7 +60,7 @@ void InheritClientPriorityVoter::OnFrameNodeAdded(const FrameNode* frame_node) {
 void InheritClientPriorityVoter::OnBeforeFrameNodeRemoved(
     const FrameNode* frame_node) {
   DCHECK(frame_node->GetChildWorkerNodes().empty());
-  size_t removed = voting_channels_.erase(GetExecutionContext(frame_node));
+  size_t removed = voting_channels_.erase(GetExecutionContext_ICPV(frame_node));
   DCHECK_EQ(removed, 1u);
 }
 
@@ -76,7 +76,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
   // The priority of a frame changed. All its children must inherit the new
   // priority.
 
-  auto it = voting_channels_.find(GetExecutionContext(frame_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(frame_node));
   DCHECK(it != voting_channels_.end());
 
   auto& voting_channel = it->second;
@@ -86,7 +86,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
   for (const WorkerNode* child_worker_node :
        frame_node->GetChildWorkerNodes()) {
     const ExecutionContext* child_execution_context =
-        GetExecutionContext(child_worker_node);
+        GetExecutionContext_ICPV(child_worker_node);
     voting_channel.ChangeVote(child_execution_context, inherited_vote);
   }
 }
@@ -94,7 +94,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
 void InheritClientPriorityVoter::OnWorkerNodeAdded(
     const WorkerNode* worker_node) {
   bool inserted = voting_channels_
-                      .emplace(GetExecutionContext(worker_node),
+                      .emplace(GetExecutionContext_ICPV(worker_node),
                                max_vote_aggregator_.GetVotingChannel())
                       .second;
   DCHECK(inserted);
@@ -104,7 +104,7 @@ void InheritClientPriorityVoter::OnWorkerNodeAdded(
 void InheritClientPriorityVoter::OnBeforeWorkerNodeRemoved(
     const WorkerNode* worker_node) {
   DCHECK(worker_node->GetChildWorkers().empty());
-  size_t removed = voting_channels_.erase(GetExecutionContext(worker_node));
+  size_t removed = voting_channels_.erase(GetExecutionContext_ICPV(worker_node));
   DCHECK_EQ(removed, 1u);
 }
 
@@ -115,14 +115,14 @@ void InheritClientPriorityVoter::OnClientFrameAdded(
   // priority.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_frame_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_frame_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
   const Vote inherited_vote(
       client_frame_node->GetPriorityAndReason().priority(),
       kPriorityInheritedReason);
-  voting_channel->SubmitVote(GetExecutionContext(worker_node), inherited_vote);
+  voting_channel->SubmitVote(GetExecutionContext_ICPV(worker_node), inherited_vote);
 }
 
 void InheritClientPriorityVoter::OnBeforeClientFrameRemoved(
@@ -132,11 +132,11 @@ void InheritClientPriorityVoter::OnBeforeClientFrameRemoved(
   // vote must be invalidated.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_frame_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_frame_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
-  voting_channel->InvalidateVote(GetExecutionContext(worker_node));
+  voting_channel->InvalidateVote(GetExecutionContext_ICPV(worker_node));
 }
 
 void InheritClientPriorityVoter::OnClientWorkerAdded(
@@ -146,14 +146,14 @@ void InheritClientPriorityVoter::OnClientWorkerAdded(
   // priority.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_worker_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_worker_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
   const Vote inherited_vote(
       client_worker_node->GetPriorityAndReason().priority(),
       kPriorityInheritedReason);
-  voting_channel->SubmitVote(GetExecutionContext(worker_node), inherited_vote);
+  voting_channel->SubmitVote(GetExecutionContext_ICPV(worker_node), inherited_vote);
 }
 
 void InheritClientPriorityVoter::OnBeforeClientWorkerRemoved(
@@ -163,11 +163,11 @@ void InheritClientPriorityVoter::OnBeforeClientWorkerRemoved(
   // vote must be invalidated.
 
   // Get the voting channel for the client.
-  auto it = voting_channels_.find(GetExecutionContext(client_worker_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(client_worker_node));
   DCHECK(it != voting_channels_.end());
   auto* voting_channel = &it->second;
 
-  voting_channel->InvalidateVote(GetExecutionContext(worker_node));
+  voting_channel->InvalidateVote(GetExecutionContext_ICPV(worker_node));
 }
 
 void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
@@ -182,7 +182,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
   // The priority of a worker changed. All its children must inherit the new
   // priority.
 
-  auto it = voting_channels_.find(GetExecutionContext(worker_node));
+  auto it = voting_channels_.find(GetExecutionContext_ICPV(worker_node));
   DCHECK(it != voting_channels_.end());
   auto& voting_channel = it->second;
 
@@ -190,7 +190,7 @@ void InheritClientPriorityVoter::OnPriorityAndReasonChanged(
                             kPriorityInheritedReason);
   for (const WorkerNode* child_worker_node : worker_node->GetChildWorkers()) {
     const ExecutionContext* child_execution_context =
-        GetExecutionContext(child_worker_node);
+        GetExecutionContext_ICPV(child_worker_node);
     voting_channel.ChangeVote(child_execution_context, inherited_vote);
   }
 }
diff --git a/components/performance_manager/graph/frame_node_impl_describer.cc b/components/performance_manager/graph/frame_node_impl_describer.cc
index 435e7b6005..bccca56b2a 100644
--- a/components/performance_manager/graph/frame_node_impl_describer.cc
+++ b/components/performance_manager/graph/frame_node_impl_describer.cc
@@ -18,8 +18,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "FrameNodeImpl";
-
 std::string IntersectsViewportToString(
     absl::optional<bool> intersects_viewport) {
   if (!intersects_viewport.has_value()) {
@@ -47,7 +45,7 @@ FrameNodeImplDescriber::~FrameNodeImplDescriber() = default;
 
 void FrameNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "FrameNodeImpl");
 }
 
 void FrameNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/graph/page_node_impl_describer.cc b/components/performance_manager/graph/page_node_impl_describer.cc
index f12ebb0542..f38c3daf4a 100644
--- a/components/performance_manager/graph/page_node_impl_describer.cc
+++ b/components/performance_manager/graph/page_node_impl_describer.cc
@@ -16,8 +16,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "PageNodeImpl";
-
 const char* FreezingVoteToString(
     absl::optional<freezing::FreezingVote> freezing_vote) {
   if (!freezing_vote)
@@ -33,7 +31,7 @@ PageNodeImplDescriber::~PageNodeImplDescriber() = default;
 
 void PageNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "PageNodeImpl");
 }
 
 void PageNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/graph/process_node_impl_describer.cc b/components/performance_manager/graph/process_node_impl_describer.cc
index b600c6346c..dbd8e51426 100644
--- a/components/performance_manager/graph/process_node_impl_describer.cc
+++ b/components/performance_manager/graph/process_node_impl_describer.cc
@@ -28,8 +28,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "ProcessNodeImpl";
-
 std::string ContentTypeToString(ProcessNode::ContentType content_type) {
   switch (content_type) {
     case ProcessNode::ContentType::kExtension:
@@ -141,7 +139,7 @@ base::Time TicksToTime(base::TimeTicks ticks) {
 
 void ProcessNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "ProcessNodeImpl");
 }
 
 void ProcessNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/graph/worker_node_impl_describer.cc b/components/performance_manager/graph/worker_node_impl_describer.cc
index 99fa33ab49..0d191ed6d3 100644
--- a/components/performance_manager/graph/worker_node_impl_describer.cc
+++ b/components/performance_manager/graph/worker_node_impl_describer.cc
@@ -16,8 +16,6 @@ namespace performance_manager {
 
 namespace {
 
-const char kDescriberName[] = "WorkerNode";
-
 const char* WorkerTypeToString(WorkerNode::WorkerType state) {
   switch (state) {
     case WorkerNode::WorkerType::kDedicated:
@@ -33,7 +31,7 @@ const char* WorkerTypeToString(WorkerNode::WorkerType state) {
 
 void WorkerNodeImplDescriber::OnPassedToGraph(Graph* graph) {
   graph->GetNodeDataDescriberRegistry()->RegisterDescriber(this,
-                                                           kDescriberName);
+                                                           "WorkerNode");
 }
 
 void WorkerNodeImplDescriber::OnTakenFromGraph(Graph* graph) {
diff --git a/components/performance_manager/performance_manager_registry_impl.cc b/components/performance_manager/performance_manager_registry_impl.cc
index a39bdd210b..e2d6ccea29 100644
--- a/components/performance_manager/performance_manager_registry_impl.cc
+++ b/components/performance_manager/performance_manager_registry_impl.cc
@@ -28,15 +28,15 @@
 
 namespace performance_manager {
 
-namespace {
+namespace performance_manager_registry_impl {
 
 PerformanceManagerRegistryImpl* g_instance = nullptr;
 
 }  // namespace
 
 PerformanceManagerRegistryImpl::PerformanceManagerRegistryImpl() {
-  DCHECK(!g_instance);
-  g_instance = this;
+  DCHECK(!performance_manager_registry_impl::g_instance);
+  performance_manager_registry_impl::g_instance = this;
 
   // The registry should be created after the PerformanceManager.
   DCHECK(PerformanceManager::IsAvailable());
@@ -49,7 +49,7 @@ PerformanceManagerRegistryImpl::~PerformanceManagerRegistryImpl() {
   // TearDown() should have been invoked to reset |g_instance| and clear
   // |web_contents_| and |render_process_user_data_| prior to destroying the
   // registry.
-  DCHECK(!g_instance);
+  DCHECK(!performance_manager_registry_impl::g_instance);
   DCHECK(web_contents_.empty());
   DCHECK(render_process_hosts_.empty());
   DCHECK(pm_owned_.empty());
@@ -60,7 +60,7 @@ PerformanceManagerRegistryImpl::~PerformanceManagerRegistryImpl() {
 
 // static
 PerformanceManagerRegistryImpl* PerformanceManagerRegistryImpl::GetInstance() {
-  return g_instance;
+  return performance_manager_registry_impl::g_instance;
 }
 
 void PerformanceManagerRegistryImpl::AddObserver(
@@ -246,8 +246,8 @@ void PerformanceManagerRegistryImpl::TearDown() {
     observer.OnBeforePerformanceManagerDestroyed();
   }
 
-  DCHECK_EQ(g_instance, this);
-  g_instance = nullptr;
+  DCHECK_EQ(performance_manager_registry_impl::g_instance, this);
+  performance_manager_registry_impl::g_instance = nullptr;
 
   // Destroy WorkerNodes before ProcessNodes, because ProcessNode checks that it
   // has no associated WorkerNode when torn down.
diff --git a/components/performance_manager/persistence/site_data/site_data_cache_factory.cc b/components/performance_manager/persistence/site_data/site_data_cache_factory.cc
index 9c8f5f591f..ecdc531713 100644
--- a/components/performance_manager/persistence/site_data/site_data_cache_factory.cc
+++ b/components/performance_manager/persistence/site_data/site_data_cache_factory.cc
@@ -18,29 +18,29 @@
 
 namespace performance_manager {
 
-namespace {
+namespace site_data_cache_factory {
 SiteDataCacheFactory* g_instance = nullptr;
 }  // namespace
 
 SiteDataCacheFactory::SiteDataCacheFactory() {
-  DCHECK(!g_instance);
-  g_instance = this;
+  DCHECK(!site_data_cache_factory::g_instance);
+  site_data_cache_factory::g_instance = this;
 }
 
 SiteDataCacheFactory::~SiteDataCacheFactory() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  DCHECK_EQ(this, g_instance);
+  DCHECK_EQ(this, site_data_cache_factory::g_instance);
   // Clear the cache map before unsetting |g_instance| as this will cause some
   // calls to |SetDataCacheInspectorForBrowserContext|.
   data_cache_map_.clear();
   for (const auto& iter : data_cache_map_)
     DCHECK_EQ(0, iter.second->Size());
-  g_instance = nullptr;
+  site_data_cache_factory::g_instance = nullptr;
 }
 
 // static
 SiteDataCacheFactory* SiteDataCacheFactory::GetInstance() {
-  return g_instance;
+  return site_data_cache_factory::g_instance;
 }
 
 SiteDataCache* SiteDataCacheFactory::GetDataCacheForBrowserContext(
diff --git a/components/policy/core/browser/url_blocklist_policy_handler.cc b/components/policy/core/browser/url_blocklist_policy_handler.cc
index 5a717a90c4..37ac7df468 100644
--- a/components/policy/core/browser/url_blocklist_policy_handler.cc
+++ b/components/policy/core/browser/url_blocklist_policy_handler.cc
@@ -31,7 +31,7 @@ namespace {
 // a wildcard in the hostname although it has no effect on the domain and
 // subdomains. Two example for such a common mistake are: 1- *.android.com 2-
 // developer.*.com which allow neither android.com nor developer.android.com
-bool ValidateHost(const std::string& host) {
+bool ValidateHostUBPH(const std::string& host) {
   return host == "*" || host.find('*') == std::string::npos;
 }
 
@@ -156,7 +156,7 @@ bool URLBlocklistPolicyHandler::ValidatePolicy(const std::string& url_pattern) {
              url_pattern, &components.scheme, &components.host,
              &components.match_subdomains, &components.port, &components.path,
              &components.query) &&
-         ValidateHost(components.host);
+         ValidateHostUBPH(components.host);
 }
 
 }  // namespace policy
diff --git a/components/policy/core/common/cloud/profile_cloud_policy_store.cc b/components/policy/core/common/cloud/profile_cloud_policy_store.cc
index 24173d8563..752b39c27b 100644
--- a/components/policy/core/common/cloud/profile_cloud_policy_store.cc
+++ b/components/policy/core/common/cloud/profile_cloud_policy_store.cc
@@ -20,7 +20,7 @@ namespace em = enterprise_management;
 namespace policy {
 namespace {
 
-const base::FilePath::CharType kPolicy[] = FILE_PATH_LITERAL("Policy");
+const base::FilePath::CharType kPolicyPCPS[] = FILE_PATH_LITERAL("Policy");
 const base::FilePath::CharType kPolicyCache[] =
     FILE_PATH_LITERAL("Profile Cloud Policy");
 const base::FilePath::CharType kKeyCache[] =
@@ -44,7 +44,7 @@ ProfileCloudPolicyStore::~ProfileCloudPolicyStore() = default;
 std::unique_ptr<ProfileCloudPolicyStore> ProfileCloudPolicyStore::Create(
     const base::FilePath& profile_dir,
     scoped_refptr<base::SequencedTaskRunner> background_task_runner) {
-  base::FilePath policy_dir = profile_dir.Append(kPolicy);
+  base::FilePath policy_dir = profile_dir.Append(kPolicyPCPS);
   base::FilePath policy_cache_file = policy_dir.Append(kPolicyCache);
   base::FilePath key_cache_file = policy_dir.Append(kKeyCache);
   return std::make_unique<ProfileCloudPolicyStore>(
diff --git a/components/policy/core/common/policy_proto_decoders.cc b/components/policy/core/common/policy_proto_decoders.cc
index f9f08f610c..3984e4de37 100644
--- a/components/policy/core/common/policy_proto_decoders.cc
+++ b/components/policy/core/common/policy_proto_decoders.cc
@@ -29,7 +29,7 @@ namespace {
 
 const char kValue[] = "Value";
 const char kLevel[] = "Level";
-const char kRecommended[] = "Recommended";
+const char kRecommendedLocal[] = "Recommended";
 
 // Returns true and sets |level| to a PolicyLevel if the policy has been set
 // at that level. Returns false if the policy is not set, or has been set at
@@ -254,7 +254,7 @@ bool ParseComponentPolicy(base::Value::Dict json_dict,
 
     PolicyLevel level = POLICY_LEVEL_MANDATORY;
     const std::string* level_string = description_dict.FindString(kLevel);
-    if (level_string && *level_string == kRecommended)
+    if (level_string && *level_string == kRecommendedLocal)
       level = POLICY_LEVEL_RECOMMENDED;
 
     policy->Set(policy_name, level, scope, source, std::move(value.value()),
diff --git a/components/printing/browser/BUILD.gn b/components/printing/browser/BUILD.gn
index cd2f244c1f..a5f46dda27 100644
--- a/components/printing/browser/BUILD.gn
+++ b/components/printing/browser/BUILD.gn
@@ -2,7 +2,9 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-static_library("browser") {
+import("//build/config/jumbo.gni")
+
+jumbo_static_library("browser") {
   sources = [
     "print_composite_client.cc",
     "print_composite_client.h",
diff --git a/components/storage_monitor/BUILD.gn b/components/storage_monitor/BUILD.gn
index 4f1e72155a..8f73984590 100644
--- a/components/storage_monitor/BUILD.gn
+++ b/components/storage_monitor/BUILD.gn
@@ -4,8 +4,9 @@
 
 import("//build/config/chromeos/ui_mode.gni")
 import("//build/config/features.gni")
+import("//build/config/jumbo.gni")
 
-static_library("storage_monitor") {
+jumbo_static_library("storage_monitor") {
   sources = [
     "media_storage_util.cc",
     "media_storage_util.h",
diff --git a/components/viz/host/host_frame_sink_manager.cc b/components/viz/host/host_frame_sink_manager.cc
index e893c89eb2..c36daec84a 100644
--- a/components/viz/host/host_frame_sink_manager.cc
+++ b/components/viz/host/host_frame_sink_manager.cc
@@ -201,7 +201,7 @@ void HostFrameSinkManager::CreateFrameSink(
     mojo::PendingReceiver<mojom::CompositorFrameSink> receiver,
     mojo::PendingRemote<mojom::CompositorFrameSinkClient> client) {
   FrameSinkData& data = frame_sink_data_map_[frame_sink_id];
-  DCHECK(data.IsFrameSinkRegistered());
+  // DCHECK(data.IsFrameSinkRegistered());
 
   // If GL context is lost a new CompositorFrameSink will be created. Destroy
   // the old CompositorFrameSink first.
diff --git a/components/viz/service/BUILD.gn b/components/viz/service/BUILD.gn
index 59c7ab0e69..6672e37ace 100644
--- a/components/viz/service/BUILD.gn
+++ b/components/viz/service/BUILD.gn
@@ -251,6 +251,22 @@ viz_component("service") {
     "transitions/transferable_resource_tracker.h",
   ]
 
+  # Keep sources with "ui/gl" includes separate to avoid mixing OpenGL sources
+  jumbo_excluded_sources = [
+    "display/display.cc",
+    "display/output_surface.cc",
+    "display/overlay_processor_on_gpu.cc",
+    "display_embedder/compositor_gpu_thread.cc",
+    "display_embedder/image_context_impl.cc",
+    "display_embedder/skia_output_device_gl.cc",
+    "display_embedder/skia_output_device_offscreen.cc",
+    "display_embedder/skia_output_surface_impl.cc",
+    "display_embedder/skia_output_surface_impl_on_gpu.cc",
+    "frame_sinks/frame_sink_manager_impl.cc",
+    "frame_sinks/video_capture/frame_sink_video_capturer_impl.cc",
+    "gl/gpu_service_impl.cc",
+  ]
+
   defines = [ "VIZ_SERVICE_IMPLEMENTATION" ]
 
   deps = [
@@ -431,6 +447,9 @@ viz_component("service") {
       "gl/info_collection_gpu_service_impl.cc",
       "gl/info_collection_gpu_service_impl.h",
     ]
+    jumbo_excluded_sources += [
+      "display_embedder/skia_output_device_dcomp.cc",
+    ]
 
     # SkiaOutputDeviceBufferQueue doesn't support Windows.
     sources -= [
@@ -441,6 +460,11 @@ viz_component("service") {
       "display_embedder/skia_output_device_buffer_queue.cc",
       "display_embedder/skia_output_device_buffer_queue.h",
     ]
+  } else {
+    jumbo_excluded_sources += [
+      "display_embedder/output_presenter_gl.cc",
+      "display_embedder/skia_output_device_buffer_queue.cc",
+    ]
   }
 
   if (is_fuchsia) {
@@ -462,6 +486,10 @@ viz_component("service") {
       "display_embedder/skia_output_device_vulkan.h",
     ]
 
+    jumbo_excluded_sources += [
+      "display_embedder/skia_output_device_vulkan.cc",
+    ]
+
     if (is_android) {
       sources += [
         "display_embedder/skia_output_device_vulkan_secondary_cb.cc",
diff --git a/components/viz/service/display_embedder/skia_output_device_webview.cc b/components/viz/service/display_embedder/skia_output_device_webview.cc
index bddc6ddf2c..6a3d89b14c 100644
--- a/components/viz/service/display_embedder/skia_output_device_webview.cc
+++ b/components/viz/service/display_embedder/skia_output_device_webview.cc
@@ -21,7 +21,7 @@
 namespace viz {
 
 namespace {
-constexpr auto kSurfaceColorType = kRGBA_8888_SkColorType;
+constexpr auto kMySurfaceColorType = kRGBA_8888_SkColorType;
 }
 
 SkiaOutputDeviceWebView::SkiaOutputDeviceWebView(
@@ -47,9 +47,9 @@ SkiaOutputDeviceWebView::SkiaOutputDeviceWebView(
   DCHECK(context_state_->context());
 
   capabilities_.sk_color_types[static_cast<int>(gfx::BufferFormat::RGBA_8888)] =
-      kSurfaceColorType;
+      kMySurfaceColorType;
   capabilities_.sk_color_types[static_cast<int>(gfx::BufferFormat::BGRA_8888)] =
-      kSurfaceColorType;
+      kMySurfaceColorType;
 }
 
 SkiaOutputDeviceWebView::~SkiaOutputDeviceWebView() = default;
@@ -111,7 +111,7 @@ void SkiaOutputDeviceWebView::InitSkiaSurface(unsigned int fbo) {
   GrGLFramebufferInfo framebuffer_info;
   framebuffer_info.fFBOID = fbo;
   framebuffer_info.fFormat = GL_RGBA8;
-  SkColorType color_type = kSurfaceColorType;
+  SkColorType color_type = kMySurfaceColorType;
 
   auto render_target =
       GrBackendRenderTargets::MakeGL(size_.width(), size_.height(),
diff --git a/components/viz/service/transitions/transferable_resource_tracker.cc b/components/viz/service/transitions/transferable_resource_tracker.cc
index 84b8ac61de..ae8c20277d 100644
--- a/components/viz/service/transitions/transferable_resource_tracker.cc
+++ b/components/viz/service/transitions/transferable_resource_tracker.cc
@@ -4,7 +4,7 @@
 
 #include "components/viz/service/transitions/transferable_resource_tracker.h"
 
-#include <GLES2/gl2.h>
+#include "third_party/khronos/GLES2/gl2.h"
 
 #include <limits>
 #include <memory>
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 6422a52f1f..e546c41a10 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -33,6 +33,96 @@ if (is_android) {
   import("//third_party/jni_zero/jni_zero.gni")
 }
 
+jumbo_static_library("devtools_protocol") {
+  configs += [
+    "//build/config:precompiled_headers",
+    "//content:content_implementation",
+  ]
+
+  deps = [
+    "//base",
+    "//content/browser/devtools:devtools_background_services_proto",
+    "//content/browser/devtools:protocol_sources",
+    "//content/common:buildflags",
+    "//services/viz/privileged/mojom",
+    "//third_party/blink/public/mojom:mojom_platform",
+    "//third_party/inspector_protocol:crdtp",
+  ]
+
+  sources = [
+    "$target_gen_dir/devtools/protocol/audits.cc",
+    "$target_gen_dir/devtools/protocol/audits.h",
+    "$target_gen_dir/devtools/protocol/background_service.cc",
+    "$target_gen_dir/devtools/protocol/background_service.h",
+    "$target_gen_dir/devtools/protocol/browser.cc",
+    "$target_gen_dir/devtools/protocol/browser.h",
+    "$target_gen_dir/devtools/protocol/device_access.cc",
+    "$target_gen_dir/devtools/protocol/device_access.h",
+    "$target_gen_dir/devtools/protocol/dom.cc",
+    "$target_gen_dir/devtools/protocol/dom.h",
+    "$target_gen_dir/devtools/protocol/emulation.cc",
+    "$target_gen_dir/devtools/protocol/emulation.h",
+    "$target_gen_dir/devtools/protocol/fed_cm.cc",
+    "$target_gen_dir/devtools/protocol/fed_cm.h",
+    "$target_gen_dir/devtools/protocol/fetch.cc",
+    "$target_gen_dir/devtools/protocol/fetch.h",
+    "$target_gen_dir/devtools/protocol/forward.h",
+    "$target_gen_dir/devtools/protocol/input.cc",
+    "$target_gen_dir/devtools/protocol/input.h",
+    "$target_gen_dir/devtools/protocol/inspector.cc",
+    "$target_gen_dir/devtools/protocol/inspector.h",
+    "$target_gen_dir/devtools/protocol/io.cc",
+    "$target_gen_dir/devtools/protocol/io.h",
+    "$target_gen_dir/devtools/protocol/log.cc",
+    "$target_gen_dir/devtools/protocol/log.h",
+    "$target_gen_dir/devtools/protocol/memory.cc",
+    "$target_gen_dir/devtools/protocol/memory.h",
+    "$target_gen_dir/devtools/protocol/network.cc",
+    "$target_gen_dir/devtools/protocol/network.h",
+    "$target_gen_dir/devtools/protocol/overlay.cc",
+    "$target_gen_dir/devtools/protocol/overlay.h",
+    "$target_gen_dir/devtools/protocol/page.cc",
+    "$target_gen_dir/devtools/protocol/page.h",
+    "$target_gen_dir/devtools/protocol/preload.cc",
+    "$target_gen_dir/devtools/protocol/preload.h",
+    "$target_gen_dir/devtools/protocol/protocol.h",
+    "$target_gen_dir/devtools/protocol/runtime.cc",
+    "$target_gen_dir/devtools/protocol/runtime.h",
+    "$target_gen_dir/devtools/protocol/schema.cc",
+    "$target_gen_dir/devtools/protocol/schema.h",
+    "$target_gen_dir/devtools/protocol/security.cc",
+    "$target_gen_dir/devtools/protocol/security.h",
+    "$target_gen_dir/devtools/protocol/service_worker.cc",
+    "$target_gen_dir/devtools/protocol/service_worker.h",
+    "$target_gen_dir/devtools/protocol/storage.cc",
+    "$target_gen_dir/devtools/protocol/storage.h",
+    "$target_gen_dir/devtools/protocol/system_info.cc",
+    "$target_gen_dir/devtools/protocol/system_info.h",
+    "$target_gen_dir/devtools/protocol/target.cc",
+    "$target_gen_dir/devtools/protocol/target.h",
+    "$target_gen_dir/devtools/protocol/tethering.cc",
+    "$target_gen_dir/devtools/protocol/tethering.h",
+    "$target_gen_dir/devtools/protocol/tracing.cc",
+    "$target_gen_dir/devtools/protocol/tracing.h",
+  ]
+  if (!is_android) {
+    # The WebAuthn devtools protocol API is not supported in Android yet.
+    sources += [
+      "$target_gen_dir/devtools/protocol/web_authn.cc",
+      "$target_gen_dir/devtools/protocol/web_authn.h",
+    ]
+  }
+
+  if (use_viz_debugger) {
+    sources += [
+      "$target_gen_dir/devtools/protocol/visual_debugger.cc",
+      "$target_gen_dir/devtools/protocol/visual_debugger.h",
+      "devtools/protocol/visual_debugger_handler.cc",
+      "devtools/protocol/visual_debugger_handler.h",
+    ]
+  }
+}
+
 jumbo_source_set("browser") {
   # Only the public target should depend on this. All other targets (even
   # internal content ones) should depend on the public one.
@@ -128,8 +218,6 @@ jumbo_source_set("browser") {
     "//content/browser/cache_storage:cache_storage_proto",
     "//content/browser/content_index:content_index_proto",
     "//content/browser/cookie_store:cookie_store_proto",
-    "//content/browser/devtools:devtools_background_services_proto",
-    "//content/browser/devtools:protocol_sources",
     "//content/browser/download:proto",
     "//content/browser/file_system_access:proto",
     "//content/browser/indexed_db:mojo_bindings",
@@ -292,6 +380,7 @@ jumbo_source_set("browser") {
     "//ui/strings:ax_strings",
     "//ui/touch_selection",
     "//v8:v8_version",
+    ":devtools_protocol",
   ]
 
   public_deps = [
@@ -306,60 +395,6 @@ jumbo_source_set("browser") {
   ]
 
   sources = [
-    "$target_gen_dir/devtools/protocol/audits.cc",
-    "$target_gen_dir/devtools/protocol/audits.h",
-    "$target_gen_dir/devtools/protocol/background_service.cc",
-    "$target_gen_dir/devtools/protocol/background_service.h",
-    "$target_gen_dir/devtools/protocol/browser.cc",
-    "$target_gen_dir/devtools/protocol/browser.h",
-    "$target_gen_dir/devtools/protocol/device_access.cc",
-    "$target_gen_dir/devtools/protocol/device_access.h",
-    "$target_gen_dir/devtools/protocol/dom.cc",
-    "$target_gen_dir/devtools/protocol/dom.h",
-    "$target_gen_dir/devtools/protocol/emulation.cc",
-    "$target_gen_dir/devtools/protocol/emulation.h",
-    "$target_gen_dir/devtools/protocol/fed_cm.cc",
-    "$target_gen_dir/devtools/protocol/fed_cm.h",
-    "$target_gen_dir/devtools/protocol/fetch.cc",
-    "$target_gen_dir/devtools/protocol/fetch.h",
-    "$target_gen_dir/devtools/protocol/forward.h",
-    "$target_gen_dir/devtools/protocol/input.cc",
-    "$target_gen_dir/devtools/protocol/input.h",
-    "$target_gen_dir/devtools/protocol/inspector.cc",
-    "$target_gen_dir/devtools/protocol/inspector.h",
-    "$target_gen_dir/devtools/protocol/io.cc",
-    "$target_gen_dir/devtools/protocol/io.h",
-    "$target_gen_dir/devtools/protocol/log.cc",
-    "$target_gen_dir/devtools/protocol/log.h",
-    "$target_gen_dir/devtools/protocol/memory.cc",
-    "$target_gen_dir/devtools/protocol/memory.h",
-    "$target_gen_dir/devtools/protocol/network.cc",
-    "$target_gen_dir/devtools/protocol/network.h",
-    "$target_gen_dir/devtools/protocol/overlay.cc",
-    "$target_gen_dir/devtools/protocol/overlay.h",
-    "$target_gen_dir/devtools/protocol/page.cc",
-    "$target_gen_dir/devtools/protocol/page.h",
-    "$target_gen_dir/devtools/protocol/preload.cc",
-    "$target_gen_dir/devtools/protocol/preload.h",
-    "$target_gen_dir/devtools/protocol/protocol.h",
-    "$target_gen_dir/devtools/protocol/runtime.cc",
-    "$target_gen_dir/devtools/protocol/runtime.h",
-    "$target_gen_dir/devtools/protocol/schema.cc",
-    "$target_gen_dir/devtools/protocol/schema.h",
-    "$target_gen_dir/devtools/protocol/security.cc",
-    "$target_gen_dir/devtools/protocol/security.h",
-    "$target_gen_dir/devtools/protocol/service_worker.cc",
-    "$target_gen_dir/devtools/protocol/service_worker.h",
-    "$target_gen_dir/devtools/protocol/storage.cc",
-    "$target_gen_dir/devtools/protocol/storage.h",
-    "$target_gen_dir/devtools/protocol/system_info.cc",
-    "$target_gen_dir/devtools/protocol/system_info.h",
-    "$target_gen_dir/devtools/protocol/target.cc",
-    "$target_gen_dir/devtools/protocol/target.h",
-    "$target_gen_dir/devtools/protocol/tethering.cc",
-    "$target_gen_dir/devtools/protocol/tethering.h",
-    "$target_gen_dir/devtools/protocol/tracing.cc",
-    "$target_gen_dir/devtools/protocol/tracing.h",
     "about_url_loader_factory.cc",
     "about_url_loader_factory.h",
     "accessibility/accessibility_tree_formatter_blink.cc",
@@ -2392,6 +2427,8 @@ jumbo_source_set("browser") {
     ]
   }
 
+  jumbo_excluded_sources = []
+
   # TODO(crbug.com/1327384): Remove `permissions_common`.
   # DO NOT add unrelated entries to this block.
   deps += [ "//components/permissions:permissions_common" ]
@@ -2750,6 +2787,9 @@ jumbo_source_set("browser") {
       ]
       public_deps += [ "//ui/base/cursor" ]
       deps += [ "//third_party/webrtc_overrides:webrtc_component" ]
+      jumbo_excluded_sources += [
+        "media/capture/desktop_capture_device.cc",
+      ]
     }
     if (use_aura) {
       sources += [
@@ -3229,6 +3269,12 @@ jumbo_source_set("browser") {
       "webid/digital_credentials/digital_credential_provider_android.h",
     ]
 
+    jumbo_excluded_sources += [
+      # Files with kJavaLangClass and similar constants:
+      # Bug https://crbug.com/787557.
+      "android/java/java_method.cc",  # and in gin_java_bound_object.cc.
+    ]
+
     deps += [
       ":reflection_jni_headers",
       "//build/config/freetype",
@@ -3260,9 +3306,6 @@ jumbo_source_set("browser") {
   } else {
     # Not Android.
     sources += [
-      # The WebAuthn devtools protocol API is not supported in Android yet.
-      "$target_gen_dir/devtools/protocol/web_authn.cc",
-      "$target_gen_dir/devtools/protocol/web_authn.h",
       "devtools/protocol/webauthn_handler.cc",
       "devtools/protocol/webauthn_handler.h",
       "media/session/audio_focus_delegate_default.cc",
diff --git a/content/browser/attribution_reporting/attribution_internals_handler_impl.cc b/content/browser/attribution_reporting/attribution_internals_handler_impl.cc
index cba9c38723..a681cfe037 100644
--- a/content/browser/attribution_reporting/attribution_internals_handler_impl.cc
+++ b/content/browser/attribution_reporting/attribution_internals_handler_impl.cc
@@ -96,7 +96,7 @@ attribution_internals::mojom::WebUISourcePtr WebUISource(
       source.debug_cookie_set(), attributability);
 }
 
-void ForwardSourcesToWebUI(
+void ForwardSourcesToWebUI2(
     attribution_internals::mojom::Handler::GetActiveSourcesCallback
         web_ui_callback,
     std::vector<StoredSource> active_sources) {
@@ -208,7 +208,7 @@ attribution_internals::mojom::WebUIReportPtr WebUIReport(
       std::move(status), std::move(data));
 }
 
-void ForwardReportsToWebUI(
+void ForwardReportsToWebUI2(
     attribution_internals::mojom::Handler::GetReportsCallback web_ui_callback,
     std::vector<AttributionReport> pending_reports) {
   std::vector<attribution_internals::mojom::WebUIReportPtr> web_ui_reports;
@@ -271,7 +271,7 @@ void AttributionInternalsHandlerImpl::GetActiveSources(
   if (AttributionManager* manager =
           AttributionManager::FromWebContents(web_ui_->GetWebContents())) {
     manager->GetActiveSourcesForWebUI(
-        base::BindOnce(&ForwardSourcesToWebUI, std::move(callback)));
+        base::BindOnce(&ForwardSourcesToWebUI2, std::move(callback)));
   } else {
     std::move(callback).Run({});
   }
@@ -283,7 +283,7 @@ void AttributionInternalsHandlerImpl::GetReports(
           AttributionManager::FromWebContents(web_ui_->GetWebContents())) {
     manager->GetPendingReportsForInternalUse(
         /*limit=*/1000,
-        base::BindOnce(&ForwardReportsToWebUI, std::move(callback)));
+        base::BindOnce(&ForwardReportsToWebUI2, std::move(callback)));
   } else {
     std::move(callback).Run({});
   }
diff --git a/content/browser/attribution_reporting/attribution_storage_sql.cc b/content/browser/attribution_reporting/attribution_storage_sql.cc
index 51d75e97c0..a84eb9d532 100644
--- a/content/browser/attribution_reporting/attribution_storage_sql.cc
+++ b/content/browser/attribution_reporting/attribution_storage_sql.cc
@@ -97,7 +97,7 @@ using ::attribution_reporting::SuitableOrigin;
 using ::attribution_reporting::mojom::SourceType;
 using ::attribution_reporting::mojom::TriggerDataMatching;
 
-const base::FilePath::CharType kDatabasePath[] =
+const base::FilePath::CharType kDatabasePathASS[] =
     FILE_PATH_LITERAL("Conversions");
 
 constexpr int64_t kUnsetRecordId = -1;
@@ -456,7 +456,7 @@ AttributionStorageSql::ReadSourceToAttribute(StoredSource::Id source_id) {
 namespace {
 
 base::FilePath DatabasePath(const base::FilePath& user_data_directory) {
-  return user_data_directory.Append(kDatabasePath);
+  return user_data_directory.Append(kDatabasePathASS);
 }
 
 }  // namespace
diff --git a/content/browser/attribution_reporting/store_source_result.cc b/content/browser/attribution_reporting/store_source_result.cc
index b766078e34..9a1348e4d0 100644
--- a/content/browser/attribution_reporting/store_source_result.cc
+++ b/content/browser/attribution_reporting/store_source_result.cc
@@ -11,41 +11,41 @@
 namespace content {
 
 namespace {
-using Status = ::attribution_reporting::mojom::StoreSourceResult;
+using StatusSSR = ::attribution_reporting::mojom::StoreSourceResult;
 }  // namespace
 
-Status StoreSourceResult::status() const {
+StatusSSR StoreSourceResult::status() const {
   return absl::visit(
       base::Overloaded{
-          [](Success) { return Status::kSuccess; },
-          [](InternalError) { return Status::kInternalError; },
+          [](Success) { return StatusSSR::kSuccess; },
+          [](InternalError) { return StatusSSR::kInternalError; },
           [](InsufficientSourceCapacity) {
-            return Status::kInsufficientSourceCapacity;
+            return StatusSSR::kInsufficientSourceCapacity;
           },
           [](InsufficientUniqueDestinationCapacity) {
-            return Status::kInsufficientUniqueDestinationCapacity;
+            return StatusSSR::kInsufficientUniqueDestinationCapacity;
           },
           [](ExcessiveReportingOrigins) {
-            return Status::kExcessiveReportingOrigins;
+            return StatusSSR::kExcessiveReportingOrigins;
           },
           [](ProhibitedByBrowserPolicy) {
-            return Status::kProhibitedByBrowserPolicy;
+            return StatusSSR::kProhibitedByBrowserPolicy;
           },
-          [](SuccessNoised) { return Status::kSuccessNoised; },
+          [](SuccessNoised) { return StatusSSR::kSuccessNoised; },
           [](DestinationReportingLimitReached) {
-            return Status::kDestinationReportingLimitReached;
+            return StatusSSR::kDestinationReportingLimitReached;
           },
           [](DestinationGlobalLimitReached) {
-            return Status::kDestinationGlobalLimitReached;
+            return StatusSSR::kDestinationGlobalLimitReached;
           },
           [](DestinationBothLimitsReached) {
-            return Status::kDestinationBothLimitsReached;
+            return StatusSSR::kDestinationBothLimitsReached;
           },
           [](ReportingOriginsPerSiteLimitReached) {
-            return Status::kReportingOriginsPerSiteLimitReached;
+            return StatusSSR::kReportingOriginsPerSiteLimitReached;
           },
           [](ExceedsMaxChannelCapacity) {
-            return Status::kExceedsMaxChannelCapacity;
+            return StatusSSR::kExceedsMaxChannelCapacity;
           },
       },
       result_);
diff --git a/content/browser/cookie_store/cookie_change_subscription.cc b/content/browser/cookie_store/cookie_change_subscription.cc
index dbe3c5b8a6..df3a1baf1d 100644
--- a/content/browser/cookie_store/cookie_change_subscription.cc
+++ b/content/browser/cookie_store/cookie_change_subscription.cc
@@ -12,14 +12,15 @@
 #include "net/cookies/cookie_constants.h"
 #include "net/cookies/cookie_util.h"
 #include "services/network/public/cpp/is_potentially_trustworthy.h"
+#include "third_party/blink/renderer/platform/wtf/assertions.h"
 
 namespace content {
 
 namespace {
 
-#define STATIC_ASSERT_ENUM(a, b)                            \
-  static_assert(static_cast<int>(a) == static_cast<int>(b), \
-                "mismatching enums: " #a)
+//#define STATIC_ASSERT_ENUM(a, b)                            \
+//  static_assert(static_cast<int>(a) == static_cast<int>(b), \
+//                "mismatching enums: " #a)
 
 STATIC_ASSERT_ENUM(network::mojom::CookieMatchType::EQUALS,
                    proto::CookieMatchType::EQUALS);
diff --git a/content/browser/devtools/BUILD.gn b/content/browser/devtools/BUILD.gn
index d9812e6c60..fe08bf22bd 100644
--- a/content/browser/devtools/BUILD.gn
+++ b/content/browser/devtools/BUILD.gn
@@ -82,7 +82,7 @@ action("concatenate_protocols") {
 }
 
 inspector_protocol_generate("protocol_sources") {
-  visibility = [ "//content/browser" ]
+  visibility = [ "//content/browser:*" ]
   deps = [ ":concatenate_protocols" ]
   inspector_protocol_dir = "//third_party/inspector_protocol"
   out_dir = target_gen_dir
diff --git a/content/browser/devtools/protocol/page_handler.cc b/content/browser/devtools/protocol/page_handler.cc
index 3ac4273bdb..b2f0a69488 100644
--- a/content/browser/devtools/protocol/page_handler.cc
+++ b/content/browser/devtools/protocol/page_handler.cc
@@ -84,7 +84,7 @@ namespace {
 constexpr const char* kMhtml = "mhtml";
 constexpr int kDefaultScreenshotQuality = 80;
 constexpr int kMaxScreencastFramesInFlight = 2;
-constexpr char kCommandIsOnlyAvailableAtTopTarget[] =
+constexpr char kCommandIsOnlyAvailableAtTopTarget2[] =
     "Command can only be executed on top-level targets";
 constexpr char kErrorNotAttached[] = "Not attached to a page";
 constexpr char kErrorInactivePage[] = "Not attached to an active page";
@@ -2006,7 +2006,7 @@ Response PageHandler::AssureTopLevelActiveFrame() {
     return Response::ServerError(kErrorNotAttached);
 
   if (host_->GetParentOrOuterDocument())
-    return Response::ServerError(kCommandIsOnlyAvailableAtTopTarget);
+    return Response::ServerError(kCommandIsOnlyAvailableAtTopTarget2);
 
   if (!host_->IsActive())
     return Response::ServerError(kErrorInactivePage);
diff --git a/content/browser/devtools/protocol/target_handler.cc b/content/browser/devtools/protocol/target_handler.cc
index aca11bfa74..72e4331eb9 100644
--- a/content/browser/devtools/protocol/target_handler.cc
+++ b/content/browser/devtools/protocol/target_handler.cc
@@ -68,7 +68,7 @@ constexpr net::NetworkTrafficAnnotationTag
           "Not implemented, only used in DevTools and is behind a switch."
       })");
 
-static const char kNotAllowedError[] = "Not allowed";
+static const char kNotAllowedErrorTH[] = "Not allowed";
 static const char kMethod[] = "method";
 static const char kResumeMethod[] = "Runtime.runIfWaitingForDebugger";
 
@@ -973,7 +973,7 @@ Response TargetHandler::SetDiscoverTargets(
     bool discover,
     Maybe<protocol::Array<protocol::Target::FilterEntry>> filter) {
   if (access_mode_ == AccessMode::kAutoAttachOnly)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   if (!discover && filter && !filter->empty()) {
     return Response::InvalidParams(
         "Filter should not be present with `discover` is off");
@@ -1080,7 +1080,7 @@ Response TargetHandler::AttachToTarget(const std::string& target_id,
                                        Maybe<bool> flatten,
                                        std::string* out_session_id) {
   if (access_mode_ == AccessMode::kAutoAttachOnly)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   // TODO(dgozman): only allow reported hosts.
   scoped_refptr<DevToolsAgentHost> agent_host =
       DevToolsAgentHost::GetForId(target_id);
@@ -1093,7 +1093,7 @@ Response TargetHandler::AttachToTarget(const std::string& target_id,
 
 Response TargetHandler::AttachToBrowserTarget(std::string* out_session_id) {
   if (access_mode_ != AccessMode::kBrowser)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   scoped_refptr<DevToolsAgentHost> agent_host =
       DevToolsAgentHost::CreateForBrowser(
           nullptr, DevToolsAgentHost::CreateServerSocketCallback());
@@ -1104,7 +1104,7 @@ Response TargetHandler::AttachToBrowserTarget(std::string* out_session_id) {
 Response TargetHandler::DetachFromTarget(Maybe<std::string> session_id,
                                          Maybe<std::string> target_id) {
   if (access_mode_ == AccessMode::kAutoAttachOnly)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   Session* session = nullptr;
   Response response =
       FindSession(std::move(session_id), std::move(target_id), &session);
@@ -1137,7 +1137,7 @@ Response TargetHandler::GetTargetInfo(
   const std::string& target_id = maybe_target_id.value_or(owner_target_id_);
   if (access_mode_ == AccessMode::kAutoAttachOnly &&
       target_id != owner_target_id_) {
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   }
   // TODO(dgozman): only allow reported hosts.
   scoped_refptr<DevToolsAgentHost> agent_host(
@@ -1150,7 +1150,7 @@ Response TargetHandler::GetTargetInfo(
 
 Response TargetHandler::ActivateTarget(const std::string& target_id) {
   if (access_mode_ == AccessMode::kAutoAttachOnly)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   // TODO(dgozman): only allow reported hosts.
   scoped_refptr<DevToolsAgentHost> agent_host(
       DevToolsAgentHost::GetForId(target_id));
@@ -1163,7 +1163,7 @@ Response TargetHandler::ActivateTarget(const std::string& target_id) {
 Response TargetHandler::CloseTarget(const std::string& target_id,
                                     bool* out_success) {
   if (access_mode_ == AccessMode::kAutoAttachOnly)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   scoped_refptr<DevToolsAgentHost> agent_host =
       DevToolsAgentHost::GetForId(target_id);
   if (!agent_host)
@@ -1178,7 +1178,7 @@ Response TargetHandler::ExposeDevToolsProtocol(
     const std::string& target_id,
     Maybe<std::string> binding_name) {
   if (access_mode_ != AccessMode::kBrowser)
-    return Response::InvalidParams(kNotAllowedError);
+    return Response::InvalidParams(kNotAllowedErrorTH);
   scoped_refptr<DevToolsAgentHost> agent_host =
       DevToolsAgentHost::GetForId(target_id);
   if (!agent_host)
@@ -1208,7 +1208,7 @@ Response TargetHandler::CreateTarget(const std::string& url,
                                      Maybe<bool> for_tab,
                                      std::string* out_target_id) {
   if (access_mode_ == AccessMode::kAutoAttachOnly)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   DevToolsManagerDelegate* delegate =
       DevToolsManager::GetInstance()->delegate();
   if (!delegate)
@@ -1234,7 +1234,7 @@ Response TargetHandler::GetTargets(
     Maybe<protocol::Array<protocol::Target::FilterEntry>> filter,
     std::unique_ptr<protocol::Array<Target::TargetInfo>>* target_infos) {
   if (access_mode_ == AccessMode::kAutoAttachOnly)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   std::unique_ptr<TargetFilter> passed_filter =
       filter.has_value() || !discover_target_filter_
           ? TargetFilter::Create(std::move(filter))
@@ -1309,7 +1309,7 @@ void TargetHandler::CreateBrowserContext(
     Maybe<protocol::Array<String>> in_originsToGrantUniversalNetworkAccess,
     std::unique_ptr<CreateBrowserContextCallback> callback) {
   if (access_mode_ != AccessMode::kBrowser) {
-    callback->sendFailure(Response::ServerError(kNotAllowedError));
+    callback->sendFailure(Response::ServerError(kNotAllowedErrorTH));
     return;
   }
   DevToolsManagerDelegate* delegate =
@@ -1387,7 +1387,7 @@ void TargetHandler::CreateBrowserContext(
 protocol::Response TargetHandler::GetBrowserContexts(
     std::unique_ptr<protocol::Array<protocol::String>>* browser_context_ids) {
   if (access_mode_ != AccessMode::kBrowser)
-    return Response::ServerError(kNotAllowedError);
+    return Response::ServerError(kNotAllowedErrorTH);
   DevToolsManagerDelegate* delegate =
       DevToolsManager::GetInstance()->delegate();
   if (!delegate)
@@ -1405,7 +1405,7 @@ void TargetHandler::DisposeBrowserContext(
     const std::string& context_id,
     std::unique_ptr<DisposeBrowserContextCallback> callback) {
   if (access_mode_ != AccessMode::kBrowser) {
-    callback->sendFailure(Response::ServerError(kNotAllowedError));
+    callback->sendFailure(Response::ServerError(kNotAllowedErrorTH));
     return;
   }
   DevToolsManagerDelegate* delegate =
diff --git a/content/browser/devtools/web_contents_devtools_agent_host.cc b/content/browser/devtools/web_contents_devtools_agent_host.cc
index 0569c749cf..adeefaad3d 100644
--- a/content/browser/devtools/web_contents_devtools_agent_host.cc
+++ b/content/browser/devtools/web_contents_devtools_agent_host.cc
@@ -18,14 +18,14 @@ namespace content {
 namespace {
 using WebContentsDevToolsMap =
     std::map<WebContents*, WebContentsDevToolsAgentHost*>;
-base::LazyInstance<WebContentsDevToolsMap>::Leaky g_agent_host_instances =
+base::LazyInstance<WebContentsDevToolsMap>::Leaky g_agent_host_instances2 =
     LAZY_INSTANCE_INITIALIZER;
 
 WebContentsDevToolsAgentHost* FindAgentHost(WebContents* wc) {
-  if (!g_agent_host_instances.IsCreated())
+  if (!g_agent_host_instances2.IsCreated())
     return nullptr;
-  auto it = g_agent_host_instances.Get().find(wc);
-  return it == g_agent_host_instances.Get().end() ? nullptr : it->second;
+  auto it = g_agent_host_instances2.Get().find(wc);
+  return it == g_agent_host_instances2.Get().end() ? nullptr : it->second;
 }
 
 // This implements the DevTools definition of outermost web contents,
@@ -178,13 +178,13 @@ void WebContentsDevToolsAgentHost::InnerAttach(WebContents* wc) {
   // a different host created.
   // TODO(caseq): find a better solution. See also a similar comment in
   // RenderFrameDevToolsAgentHost::SetFrameTreeNode();
-  auto prev_entry = g_agent_host_instances.Get().find(wc);
-  if (prev_entry != g_agent_host_instances.Get().end()) {
+  auto prev_entry = g_agent_host_instances2.Get().find(wc);
+  if (prev_entry != g_agent_host_instances2.Get().end()) {
     CHECK_NE(prev_entry->second, this);
     prev_entry->second->InnerDetach();
   }
   const bool inserted =
-      g_agent_host_instances.Get().insert(std::make_pair(wc, this)).second;
+      g_agent_host_instances2.Get().insert(std::make_pair(wc, this)).second;
   CHECK(inserted);
   auto_attacher_->SetWebContents(wc);
   Observe(wc);
@@ -196,7 +196,7 @@ void WebContentsDevToolsAgentHost::InnerAttach(WebContents* wc) {
 void WebContentsDevToolsAgentHost::InnerDetach() {
   DCHECK_EQ(this, FindAgentHost(web_contents()));
   auto_attacher_->SetWebContents(nullptr);
-  g_agent_host_instances.Get().erase(web_contents());
+  g_agent_host_instances2.Get().erase(web_contents());
   Observe(nullptr);
   // We may or may not be destruced here, depending on embedders
   // potentially retaining references.
diff --git a/content/browser/gpu/compositor_util.cc b/content/browser/gpu/compositor_util.cc
index 8cc30d6e8e..c1a203f863 100644
--- a/content/browser/gpu/compositor_util.cc
+++ b/content/browser/gpu/compositor_util.cc
@@ -108,7 +108,7 @@ const GpuFeatureData GetGpuFeatureData(
       {"canvas_oop_rasterization",
        SafeGetFeatureStatus(gpu_feature_info,
                             gpu::GPU_FEATURE_TYPE_CANVAS_OOP_RASTERIZATION),
-       !features::IsCanvasOopRasterizationEnabled() ||
+       !::features::IsCanvasOopRasterizationEnabled() ||
            command_line.HasSwitch(switches::kDisableAccelerated2dCanvas),
 #if 0
      // TODO(crbug.com/1240756): Remove the "#if 0" once OOPR-Canvas is fully
@@ -196,7 +196,7 @@ const GpuFeatureData GetGpuFeatureData(
       {"surface_control",
        SafeGetFeatureStatus(gpu_feature_info,
                             gpu::GPU_FEATURE_TYPE_ANDROID_SURFACE_CONTROL),
-       !features::IsAndroidSurfaceControlEnabled(),
+       !::features::IsAndroidSurfaceControlEnabled(),
        DisableInfo::Problem(
            "Surface Control has been disabled by Finch trial or command line."),
        false},
@@ -224,7 +224,7 @@ const GpuFeatureData GetGpuFeatureData(
       {"skia_graphite",
        SafeGetFeatureStatus(gpu_feature_info,
                             gpu::GPU_FEATURE_TYPE_SKIA_GRAPHITE),
-       !base::FeatureList::IsEnabled(features::kSkiaGraphite) &&
+       !base::FeatureList::IsEnabled(::features::kSkiaGraphite) &&
            !command_line.HasSwitch(switches::kEnableSkiaGraphite),
        DisableInfo::NotProblem(), false},
   };
@@ -455,7 +455,7 @@ bool IsZeroCopyUploadEnabled() {
 
 bool IsPartialRasterEnabled() {
   // Partial raster is not supported with RawDraw.
-  if (features::IsUsingRawDraw()) {
+  if (::features::IsUsingRawDraw()) {
     return false;
   }
   const auto& command_line = *base::CommandLine::ForCurrentProcess();
@@ -465,7 +465,7 @@ bool IsPartialRasterEnabled() {
 bool IsGpuMemoryBufferCompositorResourcesEnabled() {
   // To use Raw Draw, the Raw Draw shared image backing should be used, so
   // not use GPU memory buffer shared image backings for compositor resources.
-  if (features::IsUsingRawDraw()) {
+  if (::features::IsUsingRawDraw()) {
     return false;
   }
   const base::CommandLine& command_line =
@@ -482,7 +482,7 @@ bool IsGpuMemoryBufferCompositorResourcesEnabled() {
 #if BUILDFLAG(IS_APPLE)
   return true;
 #elif BUILDFLAG(IS_CHROMEOS_LACROS)
-  return features::IsDelegatedCompositingEnabled();
+  return ::features::IsDelegatedCompositingEnabled();
 #else
   return false;
 #endif
diff --git a/content/browser/gpu/gpu_process_host.cc b/content/browser/gpu/gpu_process_host.cc
index c062520d8e..70b4878c96 100644
--- a/content/browser/gpu/gpu_process_host.cc
+++ b/content/browser/gpu/gpu_process_host.cc
@@ -750,7 +750,7 @@ GpuProcessHost::GpuProcessHost(int host_id, GpuProcessKind kind)
 #if !BUILDFLAG(IS_ANDROID)
   if (!in_process_ && kind != GPU_PROCESS_KIND_INFO_COLLECTION &&
       base::FeatureList::IsEnabled(
-          features::kForwardMemoryPressureEventsToGpuProcess)) {
+          ::features::kForwardMemoryPressureEventsToGpuProcess)) {
     memory_pressure_listener_ = std::make_unique<base::MemoryPressureListener>(
         FROM_HERE, base::BindRepeating(&GpuProcessHost::OnMemoryPressure,
                                        base::Unretained(this)));
diff --git a/content/browser/interest_group/bidding_and_auction_serializer.cc b/content/browser/interest_group/bidding_and_auction_serializer.cc
index a662460231..16ef6662ad 100644
--- a/content/browser/interest_group/bidding_and_auction_serializer.cc
+++ b/content/browser/interest_group/bidding_and_auction_serializer.cc
@@ -27,7 +27,7 @@ namespace content {
 
 namespace {
 
-const size_t kFramingHeaderSize = 5;  // bytes
+const size_t kFramingHeaderSizeBAAS = 5;  // bytes
 
 const uint8_t kRequestVersion = 0;
 const uint8_t kRequestVersionBitOffset = 5;
@@ -255,7 +255,7 @@ BiddingAndAuctionData BiddingAndAuctionSerializer::Build() {
   std::optional<std::vector<uint8_t>> maybe_msg = cbor::Writer::Write(message);
   DCHECK(maybe_msg);
 
-  size_t size_before_padding = kFramingHeaderSize + maybe_msg->size();
+  size_t size_before_padding = kFramingHeaderSizeBAAS + maybe_msg->size();
   size_t desired_size = absl::bit_ceil(size_before_padding);
 
   std::vector<uint8_t> request(desired_size);
@@ -267,8 +267,8 @@ BiddingAndAuctionData BiddingAndAuctionSerializer::Build() {
   request[2] = (request_size >> 16) & 0xff;
   request[3] = (request_size >> 8) & 0xff;
   request[4] = (request_size >> 0) & 0xff;
-  DCHECK_GE(request.size(), kFramingHeaderSize + maybe_msg->size());
-  memcpy(&request[kFramingHeaderSize], maybe_msg->data(), maybe_msg->size());
+  DCHECK_GE(request.size(), kFramingHeaderSizeBAAS + maybe_msg->size());
+  memcpy(&request[kFramingHeaderSizeBAAS], maybe_msg->data(), maybe_msg->size());
 
   data.request = std::move(request);
   return data;
diff --git a/content/browser/interest_group/interest_group_manager_impl.cc b/content/browser/interest_group/interest_group_manager_impl.cc
index 95009f773f..b0c1e7bc1a 100644
--- a/content/browser/interest_group/interest_group_manager_impl.cc
+++ b/content/browser/interest_group/interest_group_manager_impl.cc
@@ -54,7 +54,7 @@ constexpr base::TimeDelta kMaxReportingRoundDuration = base::Minutes(10);
 // The time interval to wait before sending the next report after sending one.
 constexpr base::TimeDelta kReportingInterval = base::Milliseconds(50);
 
-constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotation =
+constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotationIGMI =
     net::DefineNetworkTrafficAnnotation("auction_report_sender", R"(
         semantics {
           sender: "Interest group based Ad Auction report"
@@ -138,7 +138,7 @@ std::unique_ptr<network::ResourceRequest> BuildUncredentialedRequest(
 std::unique_ptr<network::SimpleURLLoader> BuildSimpleUrlLoader(
     std::unique_ptr<network::ResourceRequest> resource_request) {
   auto simple_url_loader = network::SimpleURLLoader::Create(
-      std::move(resource_request), kTrafficAnnotation);
+      std::move(resource_request), kTrafficAnnotationIGMI);
   simple_url_loader->SetTimeoutDuration(base::Seconds(30));
 
   simple_url_loader->SetAllowHttpErrorResults(true);
diff --git a/content/browser/interest_group/interest_group_permissions_checker.cc b/content/browser/interest_group/interest_group_permissions_checker.cc
index c101a5144c..3ae72fceff 100644
--- a/content/browser/interest_group/interest_group_permissions_checker.cc
+++ b/content/browser/interest_group/interest_group_permissions_checker.cc
@@ -28,7 +28,7 @@ namespace content {
 
 namespace {
 
-constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotation =
+constexpr net::NetworkTrafficAnnotationTag kTrafficAnnotationIGPC =
     net::DefineNetworkTrafficAnnotation("interest_group_well_known_fetcher", R"(
         semantics {
           sender: "Interest group well-known fetcher"
@@ -142,7 +142,7 @@ void InterestGroupPermissionsChecker::CheckPermissions(
 
     active_request->second->simple_url_loader =
         network::SimpleURLLoader::Create(std::move(resource_request),
-                                         kTrafficAnnotation);
+                                         kTrafficAnnotationIGPC);
     active_request->second->simple_url_loader->SetTimeoutDuration(
         kRequestTimeout);
     active_request->second->simple_url_loader->SetRequestID(
diff --git a/content/browser/media/media_internals_cdm_helper.cc b/content/browser/media/media_internals_cdm_helper.cc
index 85e33ac608..eb345851ae 100644
--- a/content/browser/media/media_internals_cdm_helper.cc
+++ b/content/browser/media/media_internals_cdm_helper.cc
@@ -118,7 +118,7 @@ base::Value::Dict CdmInfoToDict(const CdmInfo& cdm_info) {
   return dict;
 }
 
-std::u16string SerializeUpdate(base::StringPiece function,
+std::u16string SerializeUpdate2(base::StringPiece function,
                                const base::Value::List& value) {
   base::ValueView args[] = {value};
   return content::WebUI::GetJavascriptCall(function, args);
@@ -149,7 +149,7 @@ void MediaInternalsCdmHelper::OnKeySystemCapabilitiesUpdated(
   }
 
   return MediaInternals::GetInstance()->SendUpdate(
-      SerializeUpdate("media.updateRegisteredCdms", cdm_list));
+      SerializeUpdate2("media.updateRegisteredCdms", cdm_list));
 }
 
 }  // namespace content
diff --git a/content/browser/media/media_license_database.cc b/content/browser/media/media_license_database.cc
index faf90f2eb7..71f7286143 100644
--- a/content/browser/media/media_license_database.cc
+++ b/content/browser/media/media_license_database.cc
@@ -19,9 +19,9 @@ using MediaLicenseStorageHostOpenError =
 
 namespace {
 
-static const int kVersionNumber = 1;
+static const int kVersionNumberMLD = 1;
 
-const char kUmaPrefix[] = "Media.EME.MediaLicenseDatabaseSQLiteError";
+const char kUmaPrefixMLD[] = "Media.EME.MediaLicenseDatabaseSQLiteError";
 const char kUmaPrefixWithPeriod[] =
     "Media.EME.MediaLicenseDatabaseSQLiteError.";
 
@@ -230,7 +230,7 @@ MediaLicenseStorageHostOpenError MediaLicenseDatabase::OpenDatabase(
   }
 
   sql::MetaTable meta_table;
-  if (!meta_table.Init(&db_, kVersionNumber, kVersionNumber)) {
+  if (!meta_table.Init(&db_, kVersionNumberMLD, kVersionNumberMLD)) {
     DVLOG(1) << "Could not initialize Media License database metadata table.";
     // Wipe the database and start over. If we've already wiped the database and
     // are still failing, just return false.
@@ -239,12 +239,12 @@ MediaLicenseStorageHostOpenError MediaLicenseDatabase::OpenDatabase(
                     : OpenDatabase(/*is_retry=*/true);
   }
 
-  if (meta_table.GetCompatibleVersionNumber() > kVersionNumber) {
+  if (meta_table.GetCompatibleVersionNumber() > kVersionNumberMLD) {
     // This should only happen if the user downgrades the Chrome channel (for
     // example, from Beta to Stable). If that results in an incompatible schema,
     // we need to wipe the database and start over.
     DVLOG(1) << "Media License database is too new, kVersionNumber"
-             << kVersionNumber << ", GetCompatibleVersionNumber="
+             << kVersionNumberMLD << ", GetCompatibleVersionNumber="
              << meta_table.GetCompatibleVersionNumber();
     db_.Raze();
     return is_retry ? MediaLicenseStorageHostOpenError::kDatabaseRazeError
@@ -273,7 +273,7 @@ MediaLicenseStorageHostOpenError MediaLicenseDatabase::OpenDatabase(
 void MediaLicenseDatabase::OnDatabaseError(int error, sql::Statement* stmt) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
-  sql::UmaHistogramSqliteResult(kUmaPrefix, error);
+  sql::UmaHistogramSqliteResult(kUmaPrefixMLD, error);
 
   if (last_operation_) {
     sql::UmaHistogramSqliteResult(kUmaPrefixWithPeriod + *last_operation_,
diff --git a/content/browser/media/media_license_manager.cc b/content/browser/media/media_license_manager.cc
index 92f3e698da..91a171a133 100644
--- a/content/browser/media/media_license_manager.cc
+++ b/content/browser/media/media_license_manager.cc
@@ -41,7 +41,7 @@ using MediaLicenseStorageHostOpenError =
 namespace {
 
 // Creates a task runner suitable for running SQLite database operations.
-scoped_refptr<base::SequencedTaskRunner> CreateDatabaseTaskRunner() {
+scoped_refptr<base::SequencedTaskRunner> CreateDatabaseTaskRunner_MLM() {
   // We use a SequencedTaskRunner so that there is a global ordering to a
   // storage key's directory operations.
   return base::ThreadPool::CreateSequencedTaskRunner({
@@ -64,7 +64,7 @@ MediaLicenseManager::MediaLicenseManager(
     bool in_memory,
     scoped_refptr<storage::SpecialStoragePolicy> special_storage_policy,
     scoped_refptr<storage::QuotaManagerProxy> quota_manager_proxy)
-    : db_runner_(CreateDatabaseTaskRunner()),
+    : db_runner_(CreateDatabaseTaskRunner_MLM()),
       in_memory_(in_memory),
       special_storage_policy_(std::move(special_storage_policy)),
       quota_manager_proxy_(std::move(quota_manager_proxy)),
diff --git a/content/browser/network/cross_origin_embedder_policy_reporter.cc b/content/browser/network/cross_origin_embedder_policy_reporter.cc
index 1e1ab5c3c5..1b291b57be 100644
--- a/content/browser/network/cross_origin_embedder_policy_reporter.cc
+++ b/content/browser/network/cross_origin_embedder_policy_reporter.cc
@@ -14,7 +14,7 @@ namespace content {
 
 namespace {
 
-constexpr char kType[] = "coep";
+constexpr char kTypeCoep[] = "coep";
 
 GURL StripUsernameAndPassword(const GURL& url) {
   GURL::Replacements replacements;
@@ -109,7 +109,7 @@ void CrossOriginEmbedderPolicyReporter::QueueAndNotify(
         blink::mojom::ReportBodyElement::New("disposition", disposition));
 
     observer_->Notify(blink::mojom::Report::New(
-        kType, context_url_, blink::mojom::ReportBody::New(std::move(list))));
+        kTypeCoep, context_url_, blink::mojom::ReportBody::New(std::move(list))));
   }
   if (endpoint) {
     base::Value::Dict body_to_pass;
@@ -120,7 +120,7 @@ void CrossOriginEmbedderPolicyReporter::QueueAndNotify(
 
     if (auto* storage_partition = storage_partition_.get()) {
       storage_partition->GetNetworkContext()->QueueReport(
-          kType, *endpoint, context_url_, reporting_source_,
+          kTypeCoep, *endpoint, context_url_, reporting_source_,
           network_anonymization_key_,
           /*user_agent=*/std::nullopt, std::move(body_to_pass));
     }
diff --git a/content/browser/preloading/prefetch/prefetch_url_loader_interceptor.cc b/content/browser/preloading/prefetch/prefetch_url_loader_interceptor.cc
index 6b6997d1b1..ad1f672cd1 100644
--- a/content/browser/preloading/prefetch/prefetch_url_loader_interceptor.cc
+++ b/content/browser/preloading/prefetch/prefetch_url_loader_interceptor.cc
@@ -25,7 +25,7 @@
 namespace content {
 namespace {
 
-BrowserContext* BrowserContextFromFrameTreeNodeId(int frame_tree_node_id) {
+BrowserContext* BrowserContextFromFrameTreeNodeIdPULI(int frame_tree_node_id) {
   WebContents* web_content =
       WebContents::FromFrameTreeNodeId(frame_tree_node_id);
   if (!web_content)
@@ -188,7 +188,7 @@ void PrefetchURLLoaderInterceptor::OnGetPrefetchComplete(
   // TODO (https://crbug.com/1369766): Investigate if header_client param should
   // be non-null, and then how to utilize it.
   GetContentClient()->browser()->WillCreateURLLoaderFactory(
-      BrowserContextFromFrameTreeNodeId(frame_tree_node_id_), render_frame_host,
+      BrowserContextFromFrameTreeNodeIdPULI(frame_tree_node_id_), render_frame_host,
       render_frame_host->GetProcess()->GetID(),
       ContentBrowserClient::URLLoaderFactoryType::kNavigation, url::Origin(),
       navigation_request->GetNavigationId(),
diff --git a/content/browser/preloading/preloading_config.cc b/content/browser/preloading/preloading_config.cc
index bb2ce4b4f3..cf5a1a33ac 100644
--- a/content/browser/preloading/preloading_config.cc
+++ b/content/browser/preloading/preloading_config.cc
@@ -27,7 +27,7 @@ namespace {
 //    logged in UKM. See crbug.com/1411841#c3 to see how the sampling_likelihood
 //    default values are determined.
 constexpr base::FeatureParam<std::string> kPreloadingConfigParam{
-    &features::kPreloadingConfig, "preloading_config", R"(
+    &::features::kPreloadingConfig, "preloading_config", R"(
 [{
   "preloading_type": "NoStatePrefetch",
   "preloading_predictor": "LinkRel",
@@ -125,7 +125,7 @@ PreloadingConfig* PreloadingConfig::OverrideForTesting(
 void PreloadingConfig::ParseConfig() {
   entries_.clear();
 
-  if (!base::FeatureList::IsEnabled(features::kPreloadingConfig)) {
+  if (!base::FeatureList::IsEnabled(::features::kPreloadingConfig)) {
     return;
   }
   // Throughout parsing the config, if we fail to parse, we silently skip the
diff --git a/content/browser/push_messaging/push_messaging_router.cc b/content/browser/push_messaging/push_messaging_router.cc
index 3726401f32..086fb99f33 100644
--- a/content/browser/push_messaging/push_messaging_router.cc
+++ b/content/browser/push_messaging/push_messaging_router.cc
@@ -263,7 +263,7 @@ void PushMessagingRouter::FireSubscriptionChangeEvent(
     blink::mojom::PushSubscriptionPtr old_subscription,
     PushEventCallback subscription_change_callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DCHECK(base::FeatureList::IsEnabled(features::kPushSubscriptionChangeEvent));
+  DCHECK(base::FeatureList::IsEnabled(::features::kPushSubscriptionChangeEvent));
 
   StartServiceWorkerForDispatch(
       ServiceWorkerMetrics::EventType::PUSH_SUBSCRIPTION_CHANGE,
@@ -282,7 +282,7 @@ void PushMessagingRouter::FireSubscriptionChangeEventToWorker(
     scoped_refptr<ServiceWorkerContextWrapper> service_worker_context,
     blink::ServiceWorkerStatusCode status) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  DCHECK(base::FeatureList::IsEnabled(features::kPushSubscriptionChangeEvent));
+  DCHECK(base::FeatureList::IsEnabled(::features::kPushSubscriptionChangeEvent));
 
   if (!service_worker) {
     DCHECK_NE(blink::ServiceWorkerStatusCode::kOk, status);
diff --git a/content/browser/renderer_host/agent_scheduling_group_host.cc b/content/browser/renderer_host/agent_scheduling_group_host.cc
index c2fb50fcc7..b2c5456b52 100644
--- a/content/browser/renderer_host/agent_scheduling_group_host.cc
+++ b/content/browser/renderer_host/agent_scheduling_group_host.cc
@@ -36,14 +36,6 @@ namespace {
 using ::IPC::ChannelMojo;
 using ::IPC::ChannelProxy;
 using ::IPC::Listener;
-using ::mojo::AssociatedReceiver;
-using ::mojo::AssociatedRemote;
-using ::mojo::PendingAssociatedReceiver;
-using ::mojo::PendingAssociatedRemote;
-using ::mojo::PendingReceiver;
-using ::mojo::PendingRemote;
-using ::mojo::Receiver;
-using ::mojo::Remote;
 
 static constexpr char kAgentSchedulingGroupHostDataKey[] =
     "AgentSchedulingGroupHostUserDataKey";
@@ -68,10 +60,10 @@ struct AgentSchedulingGroupHostUserData : public base::SupportsUserData::Data {
 #endif
 };
 
-static features::MBIMode GetMBIMode() {
-  return base::FeatureList::IsEnabled(features::kMBIMode)
-             ? features::kMBIModeParam.Get()
-             : features::MBIMode::kLegacy;
+static ::features::MBIMode GetMBIMode() {
+  return base::FeatureList::IsEnabled(::features::kMBIMode)
+             ? ::features::kMBIModeParam.Get()
+             : ::features::MBIMode::kLegacy;
 }
 
 }  // namespace
@@ -93,8 +85,8 @@ AgentSchedulingGroupHost* AgentSchedulingGroupHost::GetOrCreate(
 
   DCHECK(data);
 
-  if (GetMBIMode() == features::MBIMode::kLegacy ||
-      GetMBIMode() == features::MBIMode::kEnabledPerRenderProcessHost) {
+  if (GetMBIMode() == ::features::MBIMode::kLegacy ||
+      GetMBIMode() == ::features::MBIMode::kEnabledPerRenderProcessHost) {
     // We don't use |data->site_instance_groups| at all when
     // AgentSchedulingGroupHost is 1:1 with RenderProcessHost.
 #if DCHECK_IS_ON()
@@ -118,7 +110,7 @@ AgentSchedulingGroupHost* AgentSchedulingGroupHost::GetOrCreate(
     return data->owned_host_set.begin()->get();
   }
 
-  DCHECK_EQ(GetMBIMode(), features::MBIMode::kEnabledPerSiteInstance);
+  DCHECK_EQ(GetMBIMode(), ::features::MBIMode::kEnabledPerSiteInstance);
 
   // If we're in an MBI mode that creates multiple AgentSchedulingGroupHosts
   // per RenderProcessHost, then this will be called whenever SiteInstance needs
@@ -237,7 +229,7 @@ void AgentSchedulingGroupHost::AddFilter(BrowserMessageFilter* filter) {
   DCHECK(filter);
   // When MBI mode is disabled, we forward these kinds of requests straight to
   // the underlying `RenderProcessHost`.
-  if (GetMBIMode() == features::MBIMode::kLegacy) {
+  if (GetMBIMode() == ::features::MBIMode::kLegacy) {
     process_->AddFilter(filter);
     return;
   }
@@ -278,7 +270,7 @@ base::SafeRef<AgentSchedulingGroupHost> AgentSchedulingGroupHost::GetSafeRef()
 ChannelProxy* AgentSchedulingGroupHost::GetChannel() {
   DCHECK_EQ(state_, LifecycleState::kBound);
 
-  if (GetMBIMode() == features::MBIMode::kLegacy)
+  if (GetMBIMode() == ::features::MBIMode::kLegacy)
     return process_->GetChannel();
 
   DCHECK(channel_);
@@ -290,7 +282,7 @@ bool AgentSchedulingGroupHost::Send(IPC::Message* message) {
 
   std::unique_ptr<IPC::Message> msg(message);
 
-  if (GetMBIMode() == features::MBIMode::kLegacy)
+  if (GetMBIMode() == ::features::MBIMode::kLegacy)
     return process_->Send(msg.release());
 
   // This DCHECK is too idealistic for now - messages that are handled by
@@ -422,7 +414,7 @@ void AgentSchedulingGroupHost::SetUpIPC() {
   // 3. All the ASGH's other associated interfaces can now be initialized via
   //    `mojo_remote_`, and will be transitively associated with the appropriate
   //    IPC channel/pipe.
-  if (GetMBIMode() == features::MBIMode::kLegacy) {
+  if (GetMBIMode() == ::features::MBIMode::kLegacy) {
     process_->GetRendererInterface()->CreateAssociatedAgentSchedulingGroup(
         mojo_remote_.BindNewEndpointAndPassReceiver(),
         broker_receiver_.BindNewPipeAndPassRemote());
@@ -430,7 +422,7 @@ void AgentSchedulingGroupHost::SetUpIPC() {
     auto io_task_runner = GetIOThreadTaskRunner({});
 
     // Empty interface endpoint to pass pipes more easily.
-    PendingRemote<IPC::mojom::ChannelBootstrap> bootstrap;
+    mojo::PendingRemote<IPC::mojom::ChannelBootstrap> bootstrap;
 
     process_->GetRendererInterface()->CreateAgentSchedulingGroup(
         bootstrap.InitWithNewPipeAndPassReceiver(),
diff --git a/content/browser/renderer_host/code_cache_host_impl.h b/content/browser/renderer_host/code_cache_host_impl.h
index e4069b9828..54a76218c3 100644
--- a/content/browser/renderer_host/code_cache_host_impl.h
+++ b/content/browser/renderer_host/code_cache_host_impl.h
@@ -12,6 +12,8 @@
 #include "base/memory/weak_ptr.h"
 #include "build/build_config.h"
 #include "components/services/storage/public/mojom/cache_storage_control.mojom.h"
+#include "content/browser/code_cache/generated_code_cache.h"
+#include "content/browser/code_cache/generated_code_cache_context.h"
 #include "content/common/content_export.h"
 #include "mojo/public/cpp/base/big_buffer.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
@@ -24,8 +26,8 @@ class GURL;
 
 namespace content {
 
-class GeneratedCodeCache;
-class GeneratedCodeCacheContext;
+// class GeneratedCodeCache;
+// class GeneratedCodeCacheContext;
 
 // The implementation of a CodeCacheHost, which stores and retrieves resource
 // metadata, either bytecode or native code, generated by a renderer process.
diff --git a/content/browser/renderer_host/media/media_stream_manager.cc b/content/browser/renderer_host/media/media_stream_manager.cc
index 5db8665f14..90eb0fbb4a 100644
--- a/content/browser/renderer_host/media/media_stream_manager.cc
+++ b/content/browser/renderer_host/media/media_stream_manager.cc
@@ -193,7 +193,7 @@ MediaStreamType ConvertToMediaStreamType(MediaDeviceType type) {
   return MediaStreamType::NO_SERVICE;
 }
 
-const char* DeviceTypeToString(MediaDeviceType type) {
+const char* DeviceTypeToStringMSM(MediaDeviceType type) {
   switch (type) {
     case MediaDeviceType::kMediaAudioInput:
       return "DEVICE_AUDIO_INPUT";
@@ -358,7 +358,7 @@ std::string GetStopStreamDeviceLogString(
       requester_id, device_id.c_str(), session_id.ToString().c_str());
 }
 
-void SendLogMessage(const std::string& message) {
+void SendLogMessageMSM(const std::string& message) {
   MediaStreamManager::SendMessageToNativeLog("MSM::" + message);
 }
 
@@ -625,7 +625,7 @@ class MediaStreamManager::DeviceRequest {
         audio_type_(MediaStreamType::NO_SERVICE),
         video_type_(MediaStreamType::NO_SERVICE),
         target_render_frame_host_id_(-1, -1) {
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::DeviceRequest({requesting_process_id=%d}, "
         "{requesting_frame_id=%d}, {requester_id=%d}, {request_type=%s})",
         requesting_render_frame_host_id.child_id,
@@ -643,7 +643,7 @@ class MediaStreamManager::DeviceRequest {
   void SetAudioType(MediaStreamType audio_type) {
     DCHECK(blink::IsAudioInputMediaType(audio_type) ||
            audio_type == MediaStreamType::NO_SERVICE);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::SetAudioType([requester_id=%d] {audio_type=%s})", requester_id,
         StreamTypeToString(audio_type)));
     audio_type_ = audio_type;
@@ -674,7 +674,7 @@ class MediaStreamManager::DeviceRequest {
   void CreateUIRequest(const std::string& requested_audio_device_id,
                        const std::string& requested_video_device_id) {
     DCHECK(!ui_request_);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::CreateUIRequest([requester_id=%d] {requested_audio_device_id=%s}, "
         "{requested_video_device_id=%s})",
         requester_id, requested_audio_device_id.c_str(),
@@ -720,7 +720,7 @@ class MediaStreamManager::DeviceRequest {
 
   // Update the request state and notify observers.
   void SetState(MediaStreamType stream_type, MediaRequestState new_state) {
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "DR::SetState([requester_id=%d] {stream_type=%s}, {new_state=%s})",
         requester_id, StreamTypeToString(stream_type),
         RequestStateToString(new_state)));
@@ -1069,7 +1069,7 @@ class MediaStreamManager::MediaAccessRequest
       const blink::mojom::StreamDevicesSet& stream_devices_set) override {
     DCHECK_CURRENTLY_ON(BrowserThread::IO);
     DCHECK(media_access_request_cb_);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "FinalizeMediaAccessRequest({label=%s}, {requester_id="
         "%d}, {request_type=%s})",
         label.c_str(), requester_id, RequestTypeToString(request_type())));
@@ -1142,7 +1142,7 @@ class MediaStreamManager::CreateDeviceRequest
     const blink::mojom::StreamDevices& new_devices =
         *stream_devices_set.stream_devices[0];
 
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "FinalizeChangeDevice({label=%s}, {requester_id="
         "%d}, {request_type=%s})",
         label.c_str(), requester_id, RequestTypeToString(request_type())));
@@ -1451,7 +1451,7 @@ class MediaStreamManager::OpenDeviceRequest
   void FinalizeRequest(const std::string& label) override {
     DCHECK_CURRENTLY_ON(BrowserThread::IO);
     DCHECK(open_device_cb_);
-    SendLogMessage(base::StringPrintf(
+    SendLogMessageMSM(base::StringPrintf(
         "FinalizeOpenDevice({label=%s}, {requester_id="
         "%d}, {request_type=%s})",
         label.c_str(), requester_id, RequestTypeToString(request_type())));
@@ -1505,7 +1505,7 @@ MediaStreamManager* MediaStreamManager::GetInstance() {
 
 MediaStreamManager::MediaStreamManager(media::AudioSystem* audio_system)
     : MediaStreamManager(audio_system, nullptr) {
-  SendLogMessage(base::StringPrintf("MediaStreamManager([this=%p]))", this));
+  SendLogMessageMSM(base::StringPrintf("MediaStreamManager([this=%p]))", this));
 }
 
 MediaStreamManager::MediaStreamManager(
@@ -1706,7 +1706,7 @@ void MediaStreamManager::GenerateStreams(
         device_capture_configuration_change_cb,
     DeviceCaptureHandleChangeCallback device_capture_handle_change_cb) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(GetGenerateStreamsLogString(render_frame_host_id, requester_id,
+  SendLogMessageMSM(GetGenerateStreamsLogString(render_frame_host_id, requester_id,
                                              page_request_id));
   std::unique_ptr<DeviceRequest> request =
       std::make_unique<GenerateStreamsRequest>(
@@ -1827,7 +1827,7 @@ void MediaStreamManager::CancelRequest(const std::string& label) {
 
   const DeviceRequests::const_iterator request_it = FindRequestIterator(label);
   if (request_it == requests_.end()) {
-    SendLogMessage(
+    SendLogMessageMSM(
         base::StringPrintf("CancelRequest({label=%s})", label.c_str()));
     LOG(ERROR) << "The request with label = " << label << " does not exist.";
     return;
@@ -1862,7 +1862,7 @@ void MediaStreamManager::StopStreamDevice(
     const std::string& device_id,
     const base::UnguessableToken& session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(GetStopStreamDeviceLogString(
+  SendLogMessageMSM(GetStopStreamDeviceLogString(
       render_frame_host_id, requester_id, device_id, session_id));
 
   // Find the first request for this `render_frame_host_id`
@@ -1961,7 +1961,7 @@ base::UnguessableToken MediaStreamManager::VideoDeviceIdToSessionId(
 void MediaStreamManager::StopDevice(MediaStreamType type,
                                     const base::UnguessableToken& session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("StopDevice({type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("StopDevice({type=%s}, {session_id=%s})",
                                     StreamTypeToString(type),
                                     session_id.ToString().c_str()));
   DeviceRequests::const_iterator request_it = requests_.begin();
@@ -2024,7 +2024,7 @@ void MediaStreamManager::StopDevice(MediaStreamType type,
 void MediaStreamManager::CloseDevice(MediaStreamType type,
                                      const base::UnguessableToken& session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("CloseDevice({type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("CloseDevice({type=%s}, {session_id=%s})",
                                     StreamTypeToString(type),
                                     session_id.ToString().c_str()));
   GetDeviceManager(type)->Close(session_id);
@@ -2081,7 +2081,7 @@ void MediaStreamManager::OpenDevice(
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(type == MediaStreamType::DEVICE_AUDIO_CAPTURE ||
          type == MediaStreamType::DEVICE_VIDEO_CAPTURE);
-  SendLogMessage(GetOpenDeviceLogString(render_frame_host_id, requester_id,
+  SendLogMessageMSM(GetOpenDeviceLogString(render_frame_host_id, requester_id,
                                         page_request_id, device_id, type));
   StreamControls controls;
   if (blink::IsAudioInputMediaType(type)) {
@@ -2131,9 +2131,9 @@ void MediaStreamManager::StopRemovedDevice(
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(type == MediaDeviceType::kMediaAudioInput ||
          type == MediaDeviceType::kMediaVideoInput);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
                      "StopRemovedDevice({type=%s}, {device=[id: %s, name: %s]}",
-                     DeviceTypeToString(type),
+                     DeviceTypeToStringMSM(type),
                      media_device_info.device_id.c_str(),
                      media_device_info.label.c_str())
                      .c_str());
@@ -2220,7 +2220,7 @@ void MediaStreamManager::TranslateDeviceIdToSourceId(
 void MediaStreamManager::StartEnumeration(DeviceRequest* request,
                                           const std::string& label) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("StartEnumeration({requester_id=%d}, {label=%s})",
                          request->requester_id, label.c_str()));
 
@@ -2265,7 +2265,7 @@ MediaStreamManager::AddRequest(std::unique_ptr<DeviceRequest> request) {
     unique_label = base::Uuid::GenerateRandomV4().AsLowercaseString();
   } while (FindRequest(unique_label) != nullptr);
 
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("AddRequest([requester_id=%d]) => (label=%s)",
                          request->requester_id, unique_label.c_str()));
   request->SetLabel(unique_label);
@@ -2437,7 +2437,7 @@ void MediaStreamManager::CancelRequest(
   const std::string& label = request_it->first;
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("CancelRequest({label=%s})", label.c_str()));
 
   // This is a request for closing one or more devices.
@@ -2474,7 +2474,7 @@ void MediaStreamManager::DeleteRequest(
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(request_it != requests_.end());
 
-  SendLogMessage(base::StringPrintf("DeleteRequest([label=%s])",
+  SendLogMessageMSM(base::StringPrintf("DeleteRequest([label=%s])",
                                     request_it->first.c_str()));
 #if BUILDFLAG(IS_CHROMEOS)
   if (request_it->second->IsGetAllScreensMedia()) {
@@ -2529,7 +2529,7 @@ void MediaStreamManager::PostRequestToUI(
     return;
   }
   DCHECK(request->HasUIRequest());
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("PostRequestToUI({label=%s}, ", label.c_str()));
 
   const MediaStreamType audio_type = request->audio_type();
@@ -2567,7 +2567,7 @@ void MediaStreamManager::SetUpRequest(const std::string& label) {
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("SetUpRequest([requester_id=%d] {label=%s})",
                          request->requester_id, label.c_str()));
 
@@ -2674,7 +2674,7 @@ bool MediaStreamManager::SetUpDeviceCaptureRequest(
           request->audio_type() == MediaStreamType::NO_SERVICE) &&
          (request->video_type() == MediaStreamType::DEVICE_VIDEO_CAPTURE ||
           request->video_type() == MediaStreamType::NO_SERVICE));
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "SetUpDeviceCaptureRequest([requester_id=%d])", request->requester_id));
   std::string audio_device_id;
   if (request->stream_controls().audio.requested() &&
@@ -2979,7 +2979,7 @@ void MediaStreamManager::FinalizeGenerateStreams(const std::string& label,
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(request);
   DCHECK_EQ(request->request_type(), blink::MEDIA_GENERATE_STREAM);
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("FinalizeGenerateStreams({label=%s}, {requester_id="
                          "%d}, {request_type=%s})",
                          label.c_str(), request->requester_id,
@@ -3035,7 +3035,7 @@ void MediaStreamManager::FinalizeGetOpenDevice(const std::string& label,
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(request);
   DCHECK_EQ(request->request_type(), blink::MEDIA_GET_OPEN_DEVICE);
-  SendLogMessage(
+  SendLogMessageMSM(
       base::StringPrintf("FinalizeGetOpenDevice({label=%s}, {requester_id="
                          "%d}, {request_type=%s})",
                          label.c_str(), request->requester_id,
@@ -3078,7 +3078,7 @@ void MediaStreamManager::PanTiltZoomPermissionChecked(
     return;
   }
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "PanTiltZoomPermissionChecked({label=%s}, {requester_id="
       "%d}, {request_type=%s}, {pan_tilt_zoom_allowed=%d})",
       label.c_str(), request->requester_id,
@@ -3128,7 +3128,7 @@ void MediaStreamManager::FinalizeRequestFailed(
 
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "FinalizeRequestFailed({label=%s}, {requester_id=%d}, {result=%s})",
       request_it->first.c_str(), request->requester_id,
       RequestResultToString(result)));
@@ -3220,7 +3220,7 @@ void MediaStreamManager::InitializeMaybeAsync(
                                   std::move(video_capture_provider)));
     return;
   }
-  SendLogMessage(base::StringPrintf("InitializeMaybeAsync([this=%p])", this));
+  SendLogMessageMSM(base::StringPrintf("InitializeMaybeAsync([this=%p])", this));
 
   // Store a pointer to |this| on the IO thread to avoid having to jump to
   // the UI thread to fetch a pointer to the MSM. In particular on Android,
@@ -3257,7 +3257,7 @@ void MediaStreamManager::Opened(
     MediaStreamType stream_type,
     const base::UnguessableToken& capture_session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("Opened({stream_type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("Opened({stream_type=%s}, {session_id=%s})",
                                     StreamTypeToString(stream_type),
                                     capture_session_id.ToString().c_str()));
 
@@ -3370,7 +3370,7 @@ void MediaStreamManager::Closed(
     MediaStreamType stream_type,
     const base::UnguessableToken& capture_session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("Closed({stream_type=%s}, {session_id=%s})",
+  SendLogMessageMSM(base::StringPrintf("Closed({stream_type=%s}, {session_id=%s})",
                                     StreamTypeToString(stream_type),
                                     capture_session_id.ToString().c_str()));
 }
@@ -3388,7 +3388,7 @@ void MediaStreamManager::DevicesEnumerated(
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "DevicesEnumerated({label=%s}, {requester_id=%d}, {request_type=%s})",
       label.c_str(), request->requester_id,
       RequestTypeToString(request->request_type())));
@@ -3419,7 +3419,7 @@ void MediaStreamManager::Aborted(
     MediaStreamType stream_type,
     const base::UnguessableToken& capture_session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "Aborted({stream_type=%s}, {session_id=%s})",
       StreamTypeToString(stream_type), capture_session_id.ToString().c_str()));
   StopDevice(stream_type, capture_session_id);
@@ -3486,7 +3486,7 @@ void MediaStreamManager::HandleAccessRequestResponse(
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "HandleAccessRequestResponse({label=%s}, {request=%s}, {result=%s})",
       label.c_str(), RequestTypeToString(request->request_type()),
       RequestResultToString(result)));
@@ -3588,7 +3588,7 @@ void MediaStreamManager::HandleAccessRequestResponse(
               *request->stream_devices_set.stream_devices[stream_index],
               device);
           request->SetState(device.type, state);
-          SendLogMessage(base::StringPrintf(
+          SendLogMessageMSM(base::StringPrintf(
               "HandleAccessRequestResponse([label=%s]) => "
               "(already opened device: [id: %s, session_id: %s])",
               label.c_str(), device.id.c_str(),
@@ -3610,7 +3610,7 @@ void MediaStreamManager::HandleAccessRequestResponse(
           current_state != MEDIA_REQUEST_STATE_ERROR) {
         request->SetState(device.type, MEDIA_REQUEST_STATE_OPENING);
       }
-      SendLogMessage(
+      SendLogMessageMSM(
           base::StringPrintf("HandleAccessRequestResponse([label=%s]) => "
                              "(opening device: [id: %s, session_id: %s])",
                              label.c_str(), device.id.c_str(),
@@ -3699,7 +3699,7 @@ void MediaStreamManager::StopMediaStreamFromBrowser(const std::string& label) {
   }
   DeviceRequest* const request = request_it->second.get();
 
-  SendLogMessage(base::StringPrintf("StopMediaStreamFromBrowser({label=%s})",
+  SendLogMessageMSM(base::StringPrintf("StopMediaStreamFromBrowser({label=%s})",
                                     label.c_str()));
 
   // Notify renderers that the devices in the stream will be stopped.
@@ -3753,7 +3753,7 @@ void MediaStreamManager::ChangeMediaStreamSourceFromBrowser(
     }
   }
 
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "ChangeMediaStreamSourceFromBrowser({label=%s})", label.c_str()));
 
   SetUpDesktopCaptureChangeSourceRequest(request, label, media_id);
@@ -3771,7 +3771,7 @@ void MediaStreamManager::OnRequestStateChangeFromBrowser(
     return;
   }
 
-  SendLogMessage(base::StringPrintf("RequestStateChangeFromBrowser({label=%s})",
+  SendLogMessageMSM(base::StringPrintf("RequestStateChangeFromBrowser({label=%s})",
                                     label.c_str()));
 
   request->OnRequestStateChangeFromBrowser(label, media_id, new_state);
@@ -3804,8 +3804,8 @@ void MediaStreamManager::NotifyDevicesChanged(
     MediaDeviceType device_type,
     const blink::WebMediaDeviceInfoArray& devices) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf("NotifyDevicesChanged({device_type=%s})",
-                                    DeviceTypeToString(device_type)));
+  SendLogMessageMSM(base::StringPrintf("NotifyDevicesChanged({device_type=%s})",
+                                    DeviceTypeToStringMSM(device_type)));
 
   MediaObserver* media_observer =
       GetContentClient()->browser()->GetMediaObserver();
@@ -3833,7 +3833,7 @@ void MediaStreamManager::NotifyDevicesChanged(
 
 bool MediaStreamManager::RequestDone(const DeviceRequest& request) const {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "RequestDone({requester_id=%d}, {request_type=%s})", request.requester_id,
       RequestTypeToString(request.request_type())));
 
@@ -4030,7 +4030,7 @@ void MediaStreamManager::OnStreamStarted(const std::string& label) {
   if (!request) {
     return;
   }
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSM(base::StringPrintf(
       "OnStreamStarted({label=%s}, {requester_id=%d}, {request_type=%s})",
       label.c_str(), request->requester_id,
       RequestTypeToString(request->request_type())));
diff --git a/content/browser/renderer_host/media/media_stream_power_logger.cc b/content/browser/renderer_host/media/media_stream_power_logger.cc
index 733d66510f..450a1eb28e 100644
--- a/content/browser/renderer_host/media/media_stream_power_logger.cc
+++ b/content/browser/renderer_host/media/media_stream_power_logger.cc
@@ -11,7 +11,7 @@
 namespace content {
 
 namespace {
-void SendLogMessage(const std::string& message) {
+void SendLogMessageMSPL(const std::string& message) {
   MediaStreamManager::SendMessageToNativeLog("MSPL::" + message);
 }
 }  // namespace
@@ -27,23 +27,23 @@ MediaStreamPowerLogger::~MediaStreamPowerLogger() {
 }
 
 void MediaStreamPowerLogger::OnSuspend() {
-  SendLogMessage(base::StringPrintf("OnSuspend([this=%p])", this));
+  SendLogMessageMSPL(base::StringPrintf("OnSuspend([this=%p])", this));
 }
 
 void MediaStreamPowerLogger::OnResume() {
-  SendLogMessage(base::StringPrintf("OnResume([this=%p])", this));
+  SendLogMessageMSPL(base::StringPrintf("OnResume([this=%p])", this));
 }
 
 void MediaStreamPowerLogger::OnThermalStateChange(
     base::PowerThermalObserver::DeviceThermalState new_state) {
   const char* state_name =
       base::PowerMonitorSource::DeviceThermalStateToString(new_state);
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSPL(base::StringPrintf(
       "OnThermalStateChange({this=%p}, {new_state=%s})", this, state_name));
 }
 
 void MediaStreamPowerLogger::OnSpeedLimitChange(int new_limit) {
-  SendLogMessage(base::StringPrintf(
+  SendLogMessageMSPL(base::StringPrintf(
       "OnSpeedLimitChange({this=%p}, {new_limit=%d})", this, new_limit));
 }
 
diff --git a/content/browser/renderer_host/media/render_frame_audio_input_stream_factory.cc b/content/browser/renderer_host/media/render_frame_audio_input_stream_factory.cc
index 587a9eeb2f..a574db0cee 100644
--- a/content/browser/renderer_host/media/render_frame_audio_input_stream_factory.cc
+++ b/content/browser/renderer_host/media/render_frame_audio_input_stream_factory.cc
@@ -86,7 +86,7 @@ void TranslateDeviceId(const std::string& device_id,
   // If we're unable to translate the device id, |cb| will not be run.
 }
 
-void GotSaltAndOrigin(
+void GotSaltAndOrigin2(
     int process_id,
     int frame_id,
     base::OnceCallback<void(const MediaDeviceSaltAndOrigin& salt_and_origin,
@@ -105,7 +105,7 @@ void GetSaltOriginAndPermissionsOnUIThread(
                             bool has_access)> cb) {
   GetMediaDeviceSaltAndOrigin(
       GlobalRenderFrameHostId(process_id, frame_id),
-      base::BindOnce(&GotSaltAndOrigin, process_id, frame_id, std::move(cb)));
+      base::BindOnce(&GotSaltAndOrigin2, process_id, frame_id, std::move(cb)));
 }
 
 }  // namespace
diff --git a/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc b/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc
index 292641a8d1..a5fa1392cd 100644
--- a/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc
+++ b/content/browser/renderer_host/pepper/pepper_internal_file_ref_backend.cc
@@ -81,7 +81,7 @@ void CallRemove(scoped_refptr<storage::FileSystemContext> file_system_context,
                                                   std::move(callback));
 }
 
-void CallTouchFile(
+void CallTouchFile2(
     scoped_refptr<storage::FileSystemContext> file_system_context,
     const storage::FileSystemURL& url,
     const base::Time& last_access_time,
@@ -247,7 +247,7 @@ int32_t PepperInternalFileRefBackend::Touch(
   GetIOThreadTaskRunner({})->PostTask(
       FROM_HERE,
       base::BindOnce(
-          CallTouchFile, GetFileSystemContext(), GetFileSystemURL(),
+          CallTouchFile2, GetFileSystemContext(), GetFileSystemURL(),
           last_access_time, last_modified_time,
           base::BindOnce(&PepperInternalFileRefBackend::DidFinishOnIOThread,
                          weak_factory_.GetWeakPtr(), reply_context,
diff --git a/content/browser/renderer_host/render_frame_proxy_host.cc b/content/browser/renderer_host/render_frame_proxy_host.cc
index b41f53a41a..58da6176c1 100644
--- a/content/browser/renderer_host/render_frame_proxy_host.cc
+++ b/content/browser/renderer_host/render_frame_proxy_host.cc
@@ -67,10 +67,10 @@ typedef std::unordered_map<RenderFrameProxyHostID,
 base::LazyInstance<RoutingIDFrameProxyMap>::DestructorAtExit
     g_routing_id_frame_proxy_map = LAZY_INSTANCE_INITIALIZER;
 
-using TokenFrameMap = std::unordered_map<blink::RemoteFrameToken,
-                                         RenderFrameProxyHost*,
-                                         blink::RemoteFrameToken::Hasher>;
-base::LazyInstance<TokenFrameMap>::Leaky g_token_frame_proxy_map =
+using TokenFrameProxyMap = std::unordered_map<blink::RemoteFrameToken,
+                                              RenderFrameProxyHost*,
+                                              blink::RemoteFrameToken::Hasher>;
+base::LazyInstance<TokenFrameProxyMap>::Leaky g_token_frame_proxy_map =
     LAZY_INSTANCE_INITIALIZER;
 
 }  // namespace
@@ -96,7 +96,7 @@ RenderFrameProxyHost* RenderFrameProxyHost::FromFrameToken(
     int process_id,
     const blink::RemoteFrameToken& frame_token) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  TokenFrameMap* frames = g_token_frame_proxy_map.Pointer();
+  TokenFrameProxyMap* frames = g_token_frame_proxy_map.Pointer();
   auto it = frames->find(frame_token);
   // The check against |process_id| isn't strictly necessary, but represents
   // an extra level of protection against a renderer trying to force a frame
@@ -110,7 +110,7 @@ RenderFrameProxyHost* RenderFrameProxyHost::FromFrameToken(
 bool RenderFrameProxyHost::IsFrameTokenInUse(
     const blink::RemoteFrameToken& frame_token) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  TokenFrameMap* frames = g_token_frame_proxy_map.Pointer();
+  TokenFrameProxyMap* frames = g_token_frame_proxy_map.Pointer();
   return frames->find(frame_token) != frames->end();
 }
 
diff --git a/content/browser/service_worker/embedded_worker_instance.cc b/content/browser/service_worker/embedded_worker_instance.cc
index af99f798df..9a88a1d70b 100644
--- a/content/browser/service_worker/embedded_worker_instance.cc
+++ b/content/browser/service_worker/embedded_worker_instance.cc
@@ -917,7 +917,7 @@ EmbeddedWorkerInstance::CreateFactoryBundle(
   non_network_factories[url::kDataScheme] = DataURLLoaderFactory::Create();
   // Allow service workers for chrome:// or chrome-untrusted:// based on flags.
   if (base::FeatureList::IsEnabled(
-          features::kEnableServiceWorkersForChromeScheme) &&
+          ::features::kEnableServiceWorkersForChromeScheme) &&
       origin.scheme() == content::kChromeUIScheme) {
     non_network_factories.emplace(
         content::kChromeUIScheme,
@@ -925,7 +925,7 @@ EmbeddedWorkerInstance::CreateFactoryBundle(
                                               content::kChromeUIScheme,
                                               base::flat_set<std::string>()));
   } else if (base::FeatureList::IsEnabled(
-                 features::kEnableServiceWorkersForChromeUntrusted) &&
+                 ::features::kEnableServiceWorkersForChromeUntrusted) &&
              origin.scheme() == content::kChromeUIUntrustedScheme) {
     non_network_factories.emplace(
         content::kChromeUIUntrustedScheme,
diff --git a/content/browser/service_worker/service_worker_context_wrapper.cc b/content/browser/service_worker/service_worker_context_wrapper.cc
index c0ece46d3a..b06d275455 100644
--- a/content/browser/service_worker/service_worker_context_wrapper.cc
+++ b/content/browser/service_worker/service_worker_context_wrapper.cc
@@ -1897,7 +1897,7 @@ ServiceWorkerContextWrapper::GetLoaderFactoryForBrowserInitiatedRequest(
   } else {
     DCHECK(storage_partition());
     if (base::FeatureList::IsEnabled(
-            features::kPrivateNetworkAccessForWorkers)) {
+            ::features::kPrivateNetworkAccessForWorkers)) {
       if (g_loader_factory_interceptor.Get()) {
         g_loader_factory_interceptor.Get().Run(&pending_receiver);
       }
@@ -1938,7 +1938,7 @@ ServiceWorkerContextWrapper::GetLoaderFactoryForBrowserInitiatedRequest(
     // create a `WebUI` or a `WebUIController` for WebUI Service Workers so we
     // register the URLDataSource directly.
     if (base::FeatureList::IsEnabled(
-            features::kEnableServiceWorkersForChromeScheme) &&
+            ::features::kEnableServiceWorkersForChromeScheme) &&
         scope.scheme_piece() == kChromeUIScheme) {
       config->RegisterURLDataSource(browser_context());
       static_cast<blink::PendingURLLoaderFactoryBundle*>(
@@ -1948,7 +1948,7 @@ ServiceWorkerContextWrapper::GetLoaderFactoryForBrowserInitiatedRequest(
                                         browser_context(), kChromeUIScheme,
                                         base::flat_set<std::string>()));
     } else if (base::FeatureList::IsEnabled(
-                   features::kEnableServiceWorkersForChromeUntrusted) &&
+                   ::features::kEnableServiceWorkersForChromeUntrusted) &&
                scope.scheme_piece() == kChromeUIUntrustedScheme) {
       config->RegisterURLDataSource(browser_context());
       static_cast<blink::PendingURLLoaderFactoryBundle*>(
diff --git a/content/browser/service_worker/service_worker_controllee_request_handler.cc b/content/browser/service_worker/service_worker_controllee_request_handler.cc
index 4956d30b55..55ef658f75 100644
--- a/content/browser/service_worker/service_worker_controllee_request_handler.cc
+++ b/content/browser/service_worker/service_worker_controllee_request_handler.cc
@@ -89,22 +89,22 @@ const char* FetchHandlerTypeToString(
 
 bool ShouldBypassFetchHandlerForMainResource(ServiceWorkerVersion& version) {
   if (!base::FeatureList::IsEnabled(
-          features::kServiceWorkerBypassFetchHandler)) {
+          ::features::kServiceWorkerBypassFetchHandler)) {
     return false;
   }
 
-  if (features::kServiceWorkerBypassFetchHandlerTarget.Get() !=
-      features::ServiceWorkerBypassFetchHandlerTarget::kMainResource) {
+  if (::features::kServiceWorkerBypassFetchHandlerTarget.Get() !=
+      ::features::ServiceWorkerBypassFetchHandlerTarget::kMainResource) {
     return false;
   }
 
   // If the feature is enabled, the main resource request bypasses ServiceWorker
   // and starts the worker in parallel for subsequent subresources.
-  switch (features::kServiceWorkerBypassFetchHandlerStrategy.Get()) {
+  switch (::features::kServiceWorkerBypassFetchHandlerStrategy.Get()) {
     // kFeatureOptIn means that the feature relies on the manual feature
     // toggle from about://flags etc, which is triggered by developers. We
     // bypass fetch handler regardless of the url matching in this case.
-    case features::ServiceWorkerBypassFetchHandlerStrategy::kFeatureOptIn:
+    case ::features::ServiceWorkerBypassFetchHandlerStrategy::kFeatureOptIn:
       RecordSkipReason(
           ServiceWorkerControlleeRequestHandler::FetchHandlerSkipReason::
               kMainResourceSkippedDueToFeatureFlag);
@@ -112,7 +112,7 @@ bool ShouldBypassFetchHandlerForMainResource(ServiceWorkerVersion& version) {
     // If kAllowList, the allowlist should be specified. In this case, main
     // resource fetch handlers are bypassed only when the sha256 checksum of the
     // script is in the allowlist.
-    case features::ServiceWorkerBypassFetchHandlerStrategy::kAllowList:
+    case ::features::ServiceWorkerBypassFetchHandlerStrategy::kAllowList:
       if (content::service_worker_loader_helpers::
               FetchHandlerBypassedHashStrings()
                   .contains(version.sha256_script_checksum())) {
@@ -551,12 +551,12 @@ void ServiceWorkerControlleeRequestHandler::ContinueWithActivatedVersion(
       active_version->CountFeature(
           blink::mojom::WebFeature::kServiceWorkerSkippedForEmptyFetchHandler);
       CompleteWithoutLoader();
-      if (!features::kStartServiceWorkerForEmptyFetchHandler.Get()) {
+      if (!::features::kStartServiceWorkerForEmptyFetchHandler.Get()) {
         return;
       }
-      if (features::kAsyncStartServiceWorkerForEmptyFetchHandler.Get()) {
+      if (::features::kAsyncStartServiceWorkerForEmptyFetchHandler.Get()) {
         int duration =
-            features::kAsyncStartServiceWorkerForEmptyFetchHandlerDurationInMs
+            ::features::kAsyncStartServiceWorkerForEmptyFetchHandlerDurationInMs
                 .Get();
         constexpr int kDurationThresholdInMs = 10 * 1000;  // 10 seconds.
         if (duration < 0 || duration > kDurationThresholdInMs) {
@@ -598,9 +598,9 @@ void ServiceWorkerControlleeRequestHandler::ContinueWithActivatedVersion(
       // isn't started yet, skip the fetch handler and then start the
       // ServiceWorker.
       if (base::FeatureList::IsEnabled(
-              features::kServiceWorkerBypassFetchHandler) &&
-          features::kServiceWorkerBypassFetchHandlerTarget.Get() ==
-              features::ServiceWorkerBypassFetchHandlerTarget::
+              ::features::kServiceWorkerBypassFetchHandler) &&
+          ::features::kServiceWorkerBypassFetchHandlerTarget.Get() ==
+              ::features::ServiceWorkerBypassFetchHandlerTarget::
                   kAllOnlyIfServiceWorkerNotStarted) {
         switch (active_version->running_status()) {
           case blink::EmbeddedWorkerStatus::kStopped:
diff --git a/content/browser/service_worker/service_worker_loader_helpers.cc b/content/browser/service_worker/service_worker_loader_helpers.cc
index b492e00437..59a0f70007 100644
--- a/content/browser/service_worker/service_worker_loader_helpers.cc
+++ b/content/browser/service_worker/service_worker_loader_helpers.cc
@@ -331,7 +331,7 @@ bool IsPathRestrictionSatisfiedWithoutHeader(const GURL& scope,
 const base::flat_set<std::string> FetchHandlerBypassedHashStrings() {
   const static base::NoDestructor<base::flat_set<std::string>> result(
       base::SplitString(
-          features::kServiceWorkerBypassFetchHandlerBypassedHashStrings.Get(),
+          ::features::kServiceWorkerBypassFetchHandlerBypassedHashStrings.Get(),
           ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY));
 
   return *result;
diff --git a/content/browser/service_worker/service_worker_main_resource_loader.cc b/content/browser/service_worker/service_worker_main_resource_loader.cc
index 14e5fe5906..50b53790da 100644
--- a/content/browser/service_worker/service_worker_main_resource_loader.cc
+++ b/content/browser/service_worker/service_worker_main_resource_loader.cc
@@ -94,24 +94,24 @@ bool IsEligibleForRaceNetworkRequestByOriginTrial(
 bool IsEligibleForRaceNetworkRequest(
     scoped_refptr<ServiceWorkerVersion> version) {
   if (!base::FeatureList::IsEnabled(
-          features::kServiceWorkerBypassFetchHandler)) {
+          ::features::kServiceWorkerBypassFetchHandler)) {
     return false;
   }
-  if (features::kServiceWorkerBypassFetchHandlerTarget.Get() !=
-      features::ServiceWorkerBypassFetchHandlerTarget::
+  if (::features::kServiceWorkerBypassFetchHandlerTarget.Get() !=
+      ::features::ServiceWorkerBypassFetchHandlerTarget::
           kAllWithRaceNetworkRequest) {
     return false;
   }
 
-  switch (features::kServiceWorkerBypassFetchHandlerStrategy.Get()) {
+  switch (::features::kServiceWorkerBypassFetchHandlerStrategy.Get()) {
     // kFeatureOptIn means that the feature relies on the manual feature
     // toggle from about://flags etc, which is triggered by developers.
-    case features::ServiceWorkerBypassFetchHandlerStrategy::kFeatureOptIn:
+    case ::features::ServiceWorkerBypassFetchHandlerStrategy::kFeatureOptIn:
       return true;
     // If kAllowList, the allowlist should be specified. In this case,
     // RaceNetworkRequest is allowed only when the sha256 checksum of the
     // script is in the allowlist.
-    case features::ServiceWorkerBypassFetchHandlerStrategy::kAllowList:
+    case ::features::ServiceWorkerBypassFetchHandlerStrategy::kAllowList:
       return HasRaceNetworkRequestEligibleScript(version);
   }
 }
@@ -481,7 +481,7 @@ bool ServiceWorkerMainResourceLoader::MaybeStartAutoPreload(
   // running, preload requests for both main resource and subresources are not
   // dispatched.
   if (base::GetFieldTrialParamByFeatureAsBool(
-          features::kServiceWorkerAutoPreload,
+          ::features::kServiceWorkerAutoPreload,
           "enable_only_when_service_worker_not_running",
           /*default_value=*/false) &&
       version->running_status() == blink::EmbeddedWorkerStatus::kRunning) {
@@ -504,7 +504,7 @@ bool ServiceWorkerMainResourceLoader::MaybeStartAutoPreload(
   // dispatched for subresources.
   version->set_fetch_handler_bypass_option(
       base::GetFieldTrialParamByFeatureAsBool(
-          features::kServiceWorkerAutoPreload, "enable_subresource_preload",
+          ::features::kServiceWorkerAutoPreload, "enable_subresource_preload",
           /*default_value=*/true)
           ? blink::mojom::ServiceWorkerFetchHandlerBypassOption::kAutoPreload
           : blink::mojom::ServiceWorkerFetchHandlerBypassOption::kDefault);
diff --git a/content/child/BUILD.gn b/content/child/BUILD.gn
index 6742fc9754..b409564b77 100644
--- a/content/child/BUILD.gn
+++ b/content/child/BUILD.gn
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 import("//build/config/features.gni")
+import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//device/vr/buildflags/buildflags.gni")
 import("//ppapi/buildflags/buildflags.gni")
@@ -12,9 +13,9 @@ if (is_android) {
 }
 
 if (is_component_build) {
-  link_target_type = "source_set"
+  link_target_type = "jumbo_source_set"
 } else {
-  link_target_type = "static_library"
+  link_target_type = "jumbo_static_library"
 }
 target(link_target_type, "child") {
   # Targets external to content should always link to the public API.
diff --git a/content/common/BUILD.gn b/content/common/BUILD.gn
index 250d68fe80..5ef417eef2 100644
--- a/content/common/BUILD.gn
+++ b/content/common/BUILD.gn
@@ -4,6 +4,7 @@
 
 import("//build/buildflag_header.gni")
 import("//build/config/features.gni")
+import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//content/public/common/zygote/features.gni")
 import("//ipc/features.gni")
@@ -61,7 +62,7 @@ if (is_linux || is_chromeos) {
   }
 }
 
-source_set("common") {
+jumbo_source_set("common") {
   # Targets external to content should always link to the public API.
   # In addition, targets outside of the content component (shell and tests)
   # must not link to this because it will duplicate the code in the component
@@ -235,6 +236,11 @@ source_set("common") {
     "webid/identity_url_loader_throttle.cc",
     "webid/identity_url_loader_throttle.h",
   ]
+  jumbo_excluded_sources = [
+    "common_param_traits.cc",
+    "content_message_generator.cc",
+    "content_param_traits.cc",
+  ]
 
   configs += [
     "//content:content_implementation",
@@ -544,6 +550,7 @@ mojom("mojo_bindings") {
   visibility = [ "//content/*" ]
 
   disable_variants = true
+  disable_jumbo = true
 
   sources = [
     "agent_scheduling_group.mojom",
diff --git a/content/renderer/pepper/pepper_plugin_instance_impl.h b/content/renderer/pepper/pepper_plugin_instance_impl.h
index d178eb807e..6ebcc2d186 100644
--- a/content/renderer/pepper/pepper_plugin_instance_impl.h
+++ b/content/renderer/pepper/pepper_plugin_instance_impl.h
@@ -67,6 +67,11 @@
 #include "v8/include/v8-forward.h"
 #include "v8/include/v8-persistent-handle.h"
 
+// Windows defines 'PostMessage', so we have to undef it.
+#ifdef PostMessage
+#undef PostMessage
+#endif
+
 struct PP_Point;
 
 namespace blink {
diff --git a/content/renderer/service_worker/web_service_worker_provider_impl.cc b/content/renderer/service_worker/web_service_worker_provider_impl.cc
index 11d4e235f6..5fd53b2897 100644
--- a/content/renderer/service_worker/web_service_worker_provider_impl.cc
+++ b/content/renderer/service_worker/web_service_worker_provider_impl.cc
@@ -32,7 +32,7 @@ const char kLostConnectionErrorMessage[] =
     "Lost connection to the service worker system.";
 
 template <typename T>
-static std::string MojoEnumToString(T mojo_enum) {
+static std::string MojoEnumToString2(T mojo_enum) {
   std::ostringstream oss;
   oss << mojo_enum;
   return oss.str();
@@ -232,7 +232,7 @@ void WebServiceWorkerProviderImpl::OnRegistered(
     blink::mojom::ServiceWorkerRegistrationObjectInfoPtr registration) {
   TRACE_EVENT_NESTABLE_ASYNC_END2(
       "ServiceWorker", "WebServiceWorkerProviderImpl::RegisterServiceWorker",
-      TRACE_ID_LOCAL(this), "Error", MojoEnumToString(error), "Message",
+      TRACE_ID_LOCAL(this), "Error", MojoEnumToString2(error), "Message",
       error_msg ? *error_msg : "Success");
   if (error != blink::mojom::ServiceWorkerErrorType::kNone) {
     DCHECK(error_msg);
@@ -258,7 +258,7 @@ void WebServiceWorkerProviderImpl::OnDidGetRegistration(
     blink::mojom::ServiceWorkerRegistrationObjectInfoPtr registration) {
   TRACE_EVENT_NESTABLE_ASYNC_END2(
       "ServiceWorker", "WebServiceWorkerProviderImpl::GetRegistration",
-      TRACE_ID_LOCAL(this), "Error", MojoEnumToString(error), "Message",
+      TRACE_ID_LOCAL(this), "Error", MojoEnumToString2(error), "Message",
       error_msg ? *error_msg : "Success");
   if (error != blink::mojom::ServiceWorkerErrorType::kNone) {
     DCHECK(error_msg);
@@ -288,7 +288,7 @@ void WebServiceWorkerProviderImpl::OnDidGetRegistrations(
         infos) {
   TRACE_EVENT_NESTABLE_ASYNC_END2(
       "ServiceWorker", "WebServiceWorkerProviderImpl::GetRegistrations",
-      TRACE_ID_LOCAL(this), "Error", MojoEnumToString(error), "Message",
+      TRACE_ID_LOCAL(this), "Error", MojoEnumToString2(error), "Message",
       error_msg ? *error_msg : "Success");
   if (error != blink::mojom::ServiceWorkerErrorType::kNone) {
     DCHECK(error_msg);
diff --git a/content/services/auction_worklet/BUILD.gn b/content/services/auction_worklet/BUILD.gn
index 99ec8a98c8..b95690a51f 100644
--- a/content/services/auction_worklet/BUILD.gn
+++ b/content/services/auction_worklet/BUILD.gn
@@ -2,6 +2,7 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/jumbo.gni")
 import("//third_party/inspector_protocol/inspector_protocol.gni")
 import("//v8/gni/v8.gni")
 
@@ -30,7 +31,7 @@ inspector_protocol_generate("protocol_sources") {
   ]
 }
 
-source_set("auction_worklet") {
+jumbo_source_set("auction_worklet") {
   sources = [
     "auction_v8_devtools_agent.cc",
     "auction_v8_devtools_agent.h",
@@ -84,6 +85,10 @@ source_set("auction_worklet") {
 
   sources += get_target_outputs(":protocol_sources")
 
+  jumbo_excluded_sources = [
+    "seller_worklet.cc",
+  ]
+
   configs += [
     "//build/config/compiler:wexit_time_destructors",
     "//v8:external_startup_data",
diff --git a/dbus/message.cc b/dbus/message.cc
index 41a8b21635..01ee427b62 100644
--- a/dbus/message.cc
+++ b/dbus/message.cc
@@ -777,7 +777,7 @@ bool MessageReader::PopBool(bool* value) {
   // Like MessageWriter::AppendBool(), we should copy |value| to
   // dbus_bool_t, as dbus_message_iter_get_basic() used in PopBasic()
   // expects four bytes for DBUS_TYPE_BOOLEAN.
-  dbus_bool_t dbus_value = FALSE;
+  dbus_bool_t dbus_value = 0; //FALSE;
   const bool success = PopBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
   *value = static_cast<bool>(dbus_value);
   return success;
@@ -972,7 +972,7 @@ bool MessageReader::PopVariantOfByte(uint8_t* value) {
 
 bool MessageReader::PopVariantOfBool(bool* value) {
   // See the comment at MessageReader::PopBool().
-  dbus_bool_t dbus_value = FALSE;
+  dbus_bool_t dbus_value = 0; //FALSE;
   const bool success = PopVariantOfBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
   *value = static_cast<bool>(dbus_value);
   return success;
diff --git a/device/fido/cable/cable_discovery_data.h b/device/fido/cable/cable_discovery_data.h
index 7d224c2b62..2a52e88d10 100644
--- a/device/fido/cable/cable_discovery_data.h
+++ b/device/fido/cable/cable_discovery_data.h
@@ -139,7 +139,7 @@ struct COMPONENT_EXPORT(DEVICE_FIDO) Pairing {
   // within the structure is validated by using `local_identity_seed` and
   // `handshake_hash`.
   static absl::optional<std::unique_ptr<Pairing>> Parse(
-      const cbor::Value& cbor,
+      const ::cbor::Value& cbor,
       tunnelserver::KnownDomainID domain,
       base::span<const uint8_t, kQRSeedSize> local_identity_seed,
       base::span<const uint8_t, 32> handshake_hash);
diff --git a/device/fido/public_key_credential_descriptor.h b/device/fido/public_key_credential_descriptor.h
index d6b40f93e4..9ba5c7456d 100644
--- a/device/fido/public_key_credential_descriptor.h
+++ b/device/fido/public_key_credential_descriptor.h
@@ -25,7 +25,7 @@ namespace device {
 class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialDescriptor {
  public:
   static absl::optional<PublicKeyCredentialDescriptor> CreateFromCBORValue(
-      const cbor::Value& cbor);
+      const ::cbor::Value& cbor);
 
   PublicKeyCredentialDescriptor();
   PublicKeyCredentialDescriptor(CredentialType credential_type,
@@ -54,7 +54,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialDescriptor {
 };
 
 COMPONENT_EXPORT(DEVICE_FIDO)
-cbor::Value AsCBOR(const PublicKeyCredentialDescriptor&);
+::cbor::Value AsCBOR(const PublicKeyCredentialDescriptor&);
 
 }  // namespace device
 
diff --git a/device/fido/public_key_credential_params.h b/device/fido/public_key_credential_params.h
index fe0c3b0632..34a266efb5 100644
--- a/device/fido/public_key_credential_params.h
+++ b/device/fido/public_key_credential_params.h
@@ -31,7 +31,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialParams {
   };
 
   static absl::optional<PublicKeyCredentialParams> CreateFromCBORValue(
-      const cbor::Value& cbor_value);
+      const ::cbor::Value& cbor_value);
 
   explicit PublicKeyCredentialParams(
       std::vector<CredentialInfo> credential_params);
@@ -49,7 +49,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialParams {
   std::vector<CredentialInfo> public_key_credential_params_;
 };
 
-cbor::Value AsCBOR(const PublicKeyCredentialParams&);
+::cbor::Value AsCBOR(const PublicKeyCredentialParams&);
 
 }  // namespace device
 
diff --git a/device/fido/public_key_credential_rp_entity.h b/device/fido/public_key_credential_rp_entity.h
index d59250fd13..5a3c194b0c 100644
--- a/device/fido/public_key_credential_rp_entity.h
+++ b/device/fido/public_key_credential_rp_entity.h
@@ -21,7 +21,7 @@ namespace device {
 struct COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialRpEntity {
  public:
   static absl::optional<PublicKeyCredentialRpEntity> CreateFromCBORValue(
-      const cbor::Value& cbor);
+      const ::cbor::Value& cbor);
 
   PublicKeyCredentialRpEntity();
   explicit PublicKeyCredentialRpEntity(std::string id);
@@ -38,7 +38,7 @@ struct COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialRpEntity {
   absl::optional<std::string> name;
 };
 
-cbor::Value AsCBOR(const PublicKeyCredentialRpEntity&);
+::cbor::Value AsCBOR(const PublicKeyCredentialRpEntity&);
 
 }  // namespace device
 
diff --git a/device/fido/public_key_credential_user_entity.h b/device/fido/public_key_credential_user_entity.h
index 88e5547443..87a3febf4b 100644
--- a/device/fido/public_key_credential_user_entity.h
+++ b/device/fido/public_key_credential_user_entity.h
@@ -23,7 +23,7 @@ namespace device {
 class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialUserEntity {
  public:
   static absl::optional<PublicKeyCredentialUserEntity> CreateFromCBORValue(
-      const cbor::Value& cbor);
+      const ::cbor::Value& cbor);
 
   PublicKeyCredentialUserEntity();
   explicit PublicKeyCredentialUserEntity(std::vector<uint8_t> id);
@@ -44,7 +44,7 @@ class COMPONENT_EXPORT(DEVICE_FIDO) PublicKeyCredentialUserEntity {
   absl::optional<std::string> display_name;
 };
 
-cbor::Value AsCBOR(const PublicKeyCredentialUserEntity&);
+::cbor::Value AsCBOR(const PublicKeyCredentialUserEntity&);
 
 }  // namespace device
 
diff --git a/extensions/browser/api/declarative_webrequest/webrequest_action.cc b/extensions/browser/api/declarative_webrequest/webrequest_action.cc
index 17a7b2b4d3..c017eede36 100644
--- a/extensions/browser/api/declarative_webrequest/webrequest_action.cc
+++ b/extensions/browser/api/declarative_webrequest/webrequest_action.cc
@@ -35,7 +35,7 @@ using extension_web_request_api_helpers::EventResponseDelta;
 namespace extensions {
 
 namespace helpers = extension_web_request_api_helpers;
-namespace keys = declarative_webrequest_constants;
+namespace keys_wa = declarative_webrequest_constants;
 
 namespace {
 // Error messages.
@@ -56,32 +56,32 @@ const char kEmptyDocumentUrl[] = "data:text/html,";
 
 helpers::RequestCookie ParseRequestCookie(const base::Value::Dict& dict) {
   helpers::RequestCookie result;
-  if (const std::string* name = dict.FindString(keys::kNameKey))
+  if (const std::string* name = dict.FindString(keys_wa::kNameKey))
     result.name = *name;
-  if (const std::string* value = dict.FindString(keys::kValueKey))
+  if (const std::string* value = dict.FindString(keys_wa::kValueKey))
     result.value = *value;
   return result;
 }
 
 void ParseResponseCookieImpl(const base::Value::Dict& dict,
                              helpers::ResponseCookie* cookie) {
-  if (const std::string* v = dict.FindString(keys::kNameKey))
+  if (const std::string* v = dict.FindString(keys_wa::kNameKey))
     cookie->name = *v;
-  if (const std::string* v = dict.FindString(keys::kValueKey))
+  if (const std::string* v = dict.FindString(keys_wa::kValueKey))
     cookie->value = *v;
-  if (const std::string* v = dict.FindString(keys::kExpiresKey))
+  if (const std::string* v = dict.FindString(keys_wa::kExpiresKey))
     cookie->expires = *v;
-  if (std::optional<int> v = dict.FindInt(keys::kMaxAgeKey)) {
+  if (std::optional<int> v = dict.FindInt(keys_wa::kMaxAgeKey)) {
     cookie->max_age = *v;
   }
-  if (const std::string* v = dict.FindString(keys::kDomainKey))
+  if (const std::string* v = dict.FindString(keys_wa::kDomainKey))
     cookie->domain = *v;
-  if (const std::string* v = dict.FindString(keys::kPathKey))
+  if (const std::string* v = dict.FindString(keys_wa::kPathKey))
     cookie->path = *v;
-  if (std::optional<bool> v = dict.FindBool(keys::kSecureKey)) {
+  if (std::optional<bool> v = dict.FindBool(keys_wa::kSecureKey)) {
     cookie->secure = *v;
   }
-  if (std::optional<bool> v = dict.FindBool(keys::kHttpOnlyKey)) {
+  if (std::optional<bool> v = dict.FindBool(keys_wa::kHttpOnlyKey)) {
     cookie->http_only = *v;
   }
 }
@@ -97,13 +97,13 @@ helpers::FilterResponseCookie ParseFilterResponseCookie(
   helpers::FilterResponseCookie result;
   ParseResponseCookieImpl(dict, &result);
 
-  if (std::optional<int> v = dict.FindInt(keys::kAgeUpperBoundKey)) {
+  if (std::optional<int> v = dict.FindInt(keys_wa::kAgeUpperBoundKey)) {
     result.age_upper_bound = *v;
   }
-  if (std::optional<int> v = dict.FindInt(keys::kAgeLowerBoundKey)) {
+  if (std::optional<int> v = dict.FindInt(keys_wa::kAgeLowerBoundKey)) {
     result.age_lower_bound = *v;
   }
-  if (std::optional<bool> v = dict.FindBool(keys::kSessionCookieKey)) {
+  if (std::optional<bool> v = dict.FindBool(keys_wa::kSessionCookieKey)) {
     result.session_cookie = *v;
   }
   return result;
@@ -126,7 +126,7 @@ scoped_refptr<const WebRequestAction> CreateRedirectRequestAction(
     std::string* error,
     bool* bad_message) {
   const std::string* redirect_url_string =
-      value.FindString(keys::kRedirectUrlKey);
+      value.FindString(keys_wa::kRedirectUrlKey);
   INPUT_FORMAT_VALIDATE(redirect_url_string);
   GURL redirect_url(*redirect_url_string);
   return base::MakeRefCounted<WebRequestRedirectAction>(redirect_url);
@@ -137,8 +137,8 @@ scoped_refptr<const WebRequestAction> CreateRedirectRequestByRegExAction(
     const base::Value::Dict& value,
     std::string* error,
     bool* bad_message) {
-  const std::string* from = value.FindString(keys::kFromKey);
-  const std::string* to = value.FindString(keys::kToKey);
+  const std::string* from = value.FindString(keys_wa::kFromKey);
+  const std::string* to = value.FindString(keys_wa::kToKey);
   INPUT_FORMAT_VALIDATE(from);
   INPUT_FORMAT_VALIDATE(to);
 
@@ -162,8 +162,8 @@ scoped_refptr<const WebRequestAction> CreateSetRequestHeaderAction(
     const base::Value::Dict& dict,
     std::string* error,
     bool* bad_message) {
-  const std::string* name = dict.FindString(keys::kNameKey);
-  const std::string* value = dict.FindString(keys::kValueKey);
+  const std::string* name = dict.FindString(keys_wa::kNameKey);
+  const std::string* value = dict.FindString(keys_wa::kValueKey);
   INPUT_FORMAT_VALIDATE(name);
   INPUT_FORMAT_VALIDATE(value);
   if (!net::HttpUtil::IsValidHeaderName(*name)) {
@@ -183,7 +183,7 @@ scoped_refptr<const WebRequestAction> CreateRemoveRequestHeaderAction(
     const base::Value::Dict& value,
     std::string* error,
     bool* bad_message) {
-  const std::string* name = value.FindString(keys::kNameKey);
+  const std::string* name = value.FindString(keys_wa::kNameKey);
   INPUT_FORMAT_VALIDATE(name);
   if (!net::HttpUtil::IsValidHeaderName(*name)) {
     *error = extension_web_request_api_constants::kInvalidHeaderName;
@@ -197,8 +197,8 @@ scoped_refptr<const WebRequestAction> CreateAddResponseHeaderAction(
     const base::Value::Dict& dict,
     std::string* error,
     bool* bad_message) {
-  const std::string* name = dict.FindString(keys::kNameKey);
-  const std::string* value = dict.FindString(keys::kValueKey);
+  const std::string* name = dict.FindString(keys_wa::kNameKey);
+  const std::string* value = dict.FindString(keys_wa::kValueKey);
   INPUT_FORMAT_VALIDATE(name);
   INPUT_FORMAT_VALIDATE(value);
   if (!net::HttpUtil::IsValidHeaderName(*name)) {
@@ -218,9 +218,9 @@ scoped_refptr<const WebRequestAction> CreateRemoveResponseHeaderAction(
     const base::Value::Dict& dict,
     std::string* error,
     bool* bad_message) {
-  const std::string* name = dict.FindString(keys::kNameKey);
+  const std::string* name = dict.FindString(keys_wa::kNameKey);
   INPUT_FORMAT_VALIDATE(name);
-  const std::string* value = dict.FindString(keys::kValueKey);
+  const std::string* value = dict.FindString(keys_wa::kValueKey);
   if (!net::HttpUtil::IsValidHeaderName(*name)) {
     *error = extension_web_request_api_constants::kInvalidHeaderName;
     return scoped_refptr<const WebRequestAction>(nullptr);
@@ -244,15 +244,15 @@ scoped_refptr<const WebRequestAction> CreateIgnoreRulesAction(
   bool has_parameter = false;
   int minimum_priority = std::numeric_limits<int>::min();
   std::string ignore_tag;
-  if (value.Find(keys::kLowerPriorityThanKey)) {
+  if (value.Find(keys_wa::kLowerPriorityThanKey)) {
     std::optional<int> minimum_priority_value =
-        value.FindInt(keys::kLowerPriorityThanKey);
+        value.FindInt(keys_wa::kLowerPriorityThanKey);
     INPUT_FORMAT_VALIDATE(minimum_priority_value);
     minimum_priority = *minimum_priority_value;
     has_parameter = true;
   }
-  if (value.Find(keys::kHasTagKey)) {
-    const std::string* tag = value.FindString(keys::kHasTagKey);
+  if (value.Find(keys_wa::kHasTagKey)) {
+    const std::string* tag = value.FindString(keys_wa::kHasTagKey);
     INPUT_FORMAT_VALIDATE(tag);
     ignore_tag = *tag;
     has_parameter = true;
@@ -275,11 +275,11 @@ scoped_refptr<const WebRequestAction> CreateRequestCookieAction(
   RequestCookieModification modification;
 
   // Get modification type.
-  if (instance_type == keys::kAddRequestCookieType)
+  if (instance_type == keys_wa::kAddRequestCookieType)
     modification.type = helpers::ADD;
-  else if (instance_type == keys::kEditRequestCookieType)
+  else if (instance_type == keys_wa::kEditRequestCookieType)
     modification.type = helpers::EDIT;
-  else if (instance_type == keys::kRemoveRequestCookieType)
+  else if (instance_type == keys_wa::kRemoveRequestCookieType)
     modification.type = helpers::REMOVE;
   else
     INPUT_FORMAT_VALIDATE(false);
@@ -287,19 +287,19 @@ scoped_refptr<const WebRequestAction> CreateRequestCookieAction(
   // Get filter.
   if (modification.type == helpers::EDIT ||
       modification.type == helpers::REMOVE) {
-    const base::Value::Dict* filter = value.FindDict(keys::kFilterKey);
+    const base::Value::Dict* filter = value.FindDict(keys_wa::kFilterKey);
     INPUT_FORMAT_VALIDATE(filter);
     modification.filter = ParseRequestCookie(*filter);
   }
 
   // Get new value.
   if (modification.type == helpers::ADD) {
-    const base::Value::Dict* cookie_dict = value.FindDict(keys::kCookieKey);
+    const base::Value::Dict* cookie_dict = value.FindDict(keys_wa::kCookieKey);
     INPUT_FORMAT_VALIDATE(cookie_dict);
     modification.modification = ParseRequestCookie(*cookie_dict);
   } else if (modification.type == helpers::EDIT) {
     const base::Value::Dict* modification_dict =
-        value.FindDict(keys::kModificationKey);
+        value.FindDict(keys_wa::kModificationKey);
     INPUT_FORMAT_VALIDATE(modification_dict);
     modification.modification = ParseRequestCookie(*modification_dict);
   }
@@ -318,11 +318,11 @@ scoped_refptr<const WebRequestAction> CreateResponseCookieAction(
   ResponseCookieModification modification;
 
   // Get modification type.
-  if (instance_type == keys::kAddResponseCookieType)
+  if (instance_type == keys_wa::kAddResponseCookieType)
     modification.type = helpers::ADD;
-  else if (instance_type == keys::kEditResponseCookieType)
+  else if (instance_type == keys_wa::kEditResponseCookieType)
     modification.type = helpers::EDIT;
-  else if (instance_type == keys::kRemoveResponseCookieType)
+  else if (instance_type == keys_wa::kRemoveResponseCookieType)
     modification.type = helpers::REMOVE;
   else
     INPUT_FORMAT_VALIDATE(false);
@@ -330,19 +330,19 @@ scoped_refptr<const WebRequestAction> CreateResponseCookieAction(
   // Get filter.
   if (modification.type == helpers::EDIT ||
       modification.type == helpers::REMOVE) {
-    const base::Value::Dict* filter = value.FindDict(keys::kFilterKey);
+    const base::Value::Dict* filter = value.FindDict(keys_wa::kFilterKey);
     INPUT_FORMAT_VALIDATE(filter);
     modification.filter = ParseFilterResponseCookie(*filter);
   }
 
   // Get new value.
   if (modification.type == helpers::ADD) {
-    const base::Value::Dict* dict_value = value.FindDict(keys::kCookieKey);
+    const base::Value::Dict* dict_value = value.FindDict(keys_wa::kCookieKey);
     INPUT_FORMAT_VALIDATE(dict_value);
     modification.modification = ParseResponseCookie(*dict_value);
   } else if (modification.type == helpers::EDIT) {
     const base::Value::Dict* dict_value =
-        value.FindDict(keys::kModificationKey);
+        value.FindDict(keys_wa::kModificationKey);
     INPUT_FORMAT_VALIDATE(dict_value);
     modification.modification = ParseResponseCookie(*dict_value);
   }
@@ -356,7 +356,7 @@ scoped_refptr<const WebRequestAction> CreateSendMessageToExtensionAction(
     const base::Value::Dict& value,
     std::string* error,
     bool* bad_message) {
-  const std::string* message = value.FindString(keys::kMessageKey);
+  const std::string* message = value.FindString(keys_wa::kMessageKey);
   INPUT_FORMAT_VALIDATE(message);
   return base::MakeRefCounted<WebRequestSendMessageToExtensionAction>(*message);
 }
@@ -366,56 +366,56 @@ struct WebRequestActionFactory {
   FactoryT factory;
 
   WebRequestActionFactory() : factory(5) {
-    factory.RegisterFactoryMethod(keys::kAddRequestCookieType,
+    factory.RegisterFactoryMethod(keys_wa::kAddRequestCookieType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateRequestCookieAction);
-    factory.RegisterFactoryMethod(keys::kAddResponseCookieType,
+    factory.RegisterFactoryMethod(keys_wa::kAddResponseCookieType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateResponseCookieAction);
-    factory.RegisterFactoryMethod(keys::kAddResponseHeaderType,
+    factory.RegisterFactoryMethod(keys_wa::kAddResponseHeaderType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateAddResponseHeaderAction);
     factory.RegisterFactoryMethod(
-        keys::kCancelRequestType, FactoryT::IS_NOT_PARAMETERIZED,
+        keys_wa::kCancelRequestType, FactoryT::IS_NOT_PARAMETERIZED,
         &CallConstructorFactoryMethod<WebRequestCancelAction>);
-    factory.RegisterFactoryMethod(keys::kEditRequestCookieType,
+    factory.RegisterFactoryMethod(keys_wa::kEditRequestCookieType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateRequestCookieAction);
-    factory.RegisterFactoryMethod(keys::kEditResponseCookieType,
+    factory.RegisterFactoryMethod(keys_wa::kEditResponseCookieType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateResponseCookieAction);
-    factory.RegisterFactoryMethod(keys::kRedirectByRegExType,
+    factory.RegisterFactoryMethod(keys_wa::kRedirectByRegExType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateRedirectRequestByRegExAction);
-    factory.RegisterFactoryMethod(keys::kRedirectRequestType,
+    factory.RegisterFactoryMethod(keys_wa::kRedirectRequestType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateRedirectRequestAction);
     factory.RegisterFactoryMethod(
-        keys::kRedirectToTransparentImageType, FactoryT::IS_NOT_PARAMETERIZED,
+        keys_wa::kRedirectToTransparentImageType, FactoryT::IS_NOT_PARAMETERIZED,
         &CallConstructorFactoryMethod<
             WebRequestRedirectToTransparentImageAction>);
     factory.RegisterFactoryMethod(
-        keys::kRedirectToEmptyDocumentType, FactoryT::IS_NOT_PARAMETERIZED,
+        keys_wa::kRedirectToEmptyDocumentType, FactoryT::IS_NOT_PARAMETERIZED,
         &CallConstructorFactoryMethod<WebRequestRedirectToEmptyDocumentAction>);
-    factory.RegisterFactoryMethod(keys::kRemoveRequestCookieType,
+    factory.RegisterFactoryMethod(keys_wa::kRemoveRequestCookieType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateRequestCookieAction);
-    factory.RegisterFactoryMethod(keys::kRemoveResponseCookieType,
+    factory.RegisterFactoryMethod(keys_wa::kRemoveResponseCookieType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateResponseCookieAction);
-    factory.RegisterFactoryMethod(keys::kSetRequestHeaderType,
+    factory.RegisterFactoryMethod(keys_wa::kSetRequestHeaderType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateSetRequestHeaderAction);
-    factory.RegisterFactoryMethod(keys::kRemoveRequestHeaderType,
+    factory.RegisterFactoryMethod(keys_wa::kRemoveRequestHeaderType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateRemoveRequestHeaderAction);
-    factory.RegisterFactoryMethod(keys::kRemoveResponseHeaderType,
+    factory.RegisterFactoryMethod(keys_wa::kRemoveResponseHeaderType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateRemoveResponseHeaderAction);
-    factory.RegisterFactoryMethod(keys::kIgnoreRulesType,
+    factory.RegisterFactoryMethod(keys_wa::kIgnoreRulesType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateIgnoreRulesAction);
-    factory.RegisterFactoryMethod(keys::kSendMessageToExtensionType,
+    factory.RegisterFactoryMethod(keys_wa::kSendMessageToExtensionType,
                                   FactoryT::IS_PARAMETERIZED,
                                   &CreateSendMessageToExtensionAction);
   }
@@ -484,7 +484,7 @@ scoped_refptr<const WebRequestAction> WebRequestAction::Create(
   *bad_message = false;
 
   const std::string* instance_type =
-      json_action.FindString(keys::kInstanceTypeKey);
+      json_action.FindString(keys_wa::kInstanceTypeKey);
   INPUT_FORMAT_VALIDATE(instance_type);
 
   WebRequestActionFactory& factory = g_web_request_action_factory.Get();
@@ -534,7 +534,7 @@ WebRequestCancelAction::WebRequestCancelAction()
 WebRequestCancelAction::~WebRequestCancelAction() = default;
 
 std::string WebRequestCancelAction::GetName() const {
-  return keys::kCancelRequestType;
+  return keys_wa::kCancelRequestType;
 }
 
 std::optional<EventResponseDelta> WebRequestCancelAction::CreateDelta(
@@ -567,7 +567,7 @@ bool WebRequestRedirectAction::Equals(const WebRequestAction* other) const {
 }
 
 std::string WebRequestRedirectAction::GetName() const {
-  return keys::kRedirectRequestType;
+  return keys_wa::kRedirectRequestType;
 }
 
 std::optional<EventResponseDelta> WebRequestRedirectAction::CreateDelta(
@@ -597,7 +597,7 @@ WebRequestRedirectToTransparentImageAction::
 ~WebRequestRedirectToTransparentImageAction() {}
 
 std::string WebRequestRedirectToTransparentImageAction::GetName() const {
-  return keys::kRedirectToTransparentImageType;
+  return keys_wa::kRedirectToTransparentImageType;
 }
 
 std::optional<EventResponseDelta>
@@ -626,7 +626,7 @@ WebRequestRedirectToEmptyDocumentAction::
 ~WebRequestRedirectToEmptyDocumentAction() {}
 
 std::string WebRequestRedirectToEmptyDocumentAction::GetName() const {
-  return keys::kRedirectToEmptyDocumentType;
+  return keys_wa::kRedirectToEmptyDocumentType;
 }
 
 std::optional<EventResponseDelta>
@@ -720,7 +720,7 @@ bool WebRequestRedirectByRegExAction::Equals(
 }
 
 std::string WebRequestRedirectByRegExAction::GetName() const {
-  return keys::kRedirectByRegExType;
+  return keys_wa::kRedirectByRegExType;
 }
 
 std::optional<EventResponseDelta> WebRequestRedirectByRegExAction::CreateDelta(
@@ -768,7 +768,7 @@ bool WebRequestSetRequestHeaderAction::Equals(
 }
 
 std::string WebRequestSetRequestHeaderAction::GetName() const {
-  return keys::kSetRequestHeaderType;
+  return keys_wa::kSetRequestHeaderType;
 }
 
 std::optional<EventResponseDelta> WebRequestSetRequestHeaderAction::CreateDelta(
@@ -806,7 +806,7 @@ bool WebRequestRemoveRequestHeaderAction::Equals(
 }
 
 std::string WebRequestRemoveRequestHeaderAction::GetName() const {
-  return keys::kRemoveRequestHeaderType;
+  return keys_wa::kRemoveRequestHeaderType;
 }
 
 std::optional<EventResponseDelta>
@@ -847,7 +847,7 @@ bool WebRequestAddResponseHeaderAction::Equals(
 }
 
 std::string WebRequestAddResponseHeaderAction::GetName() const {
-  return keys::kAddResponseHeaderType;
+  return keys_wa::kAddResponseHeaderType;
 }
 
 std::optional<EventResponseDelta>
@@ -900,7 +900,7 @@ bool WebRequestRemoveResponseHeaderAction::Equals(
 }
 
 std::string WebRequestRemoveResponseHeaderAction::GetName() const {
-  return keys::kRemoveResponseHeaderType;
+  return keys_wa::kRemoveResponseHeaderType;
 }
 
 std::optional<EventResponseDelta>
@@ -951,7 +951,7 @@ bool WebRequestIgnoreRulesAction::Equals(const WebRequestAction* other) const {
 }
 
 std::string WebRequestIgnoreRulesAction::GetName() const {
-  return keys::kIgnoreRulesType;
+  return keys_wa::kIgnoreRulesType;
 }
 
 std::optional<EventResponseDelta> WebRequestIgnoreRulesAction::CreateDelta(
@@ -989,11 +989,11 @@ bool WebRequestRequestCookieAction::Equals(
 std::string WebRequestRequestCookieAction::GetName() const {
   switch (request_cookie_modification_.type) {
     case helpers::ADD:
-      return keys::kAddRequestCookieType;
+      return keys_wa::kAddRequestCookieType;
     case helpers::EDIT:
-      return keys::kEditRequestCookieType;
+      return keys_wa::kEditRequestCookieType;
     case helpers::REMOVE:
-      return keys::kRemoveRequestCookieType;
+      return keys_wa::kRemoveRequestCookieType;
   }
   NOTREACHED();
   return "";
@@ -1037,11 +1037,11 @@ bool WebRequestResponseCookieAction::Equals(
 std::string WebRequestResponseCookieAction::GetName() const {
   switch (response_cookie_modification_.type) {
     case helpers::ADD:
-      return keys::kAddResponseCookieType;
+      return keys_wa::kAddResponseCookieType;
     case helpers::EDIT:
-      return keys::kEditResponseCookieType;
+      return keys_wa::kEditResponseCookieType;
     case helpers::REMOVE:
-      return keys::kRemoveResponseCookieType;
+      return keys_wa::kRemoveResponseCookieType;
   }
   NOTREACHED();
   return "";
@@ -1084,7 +1084,7 @@ bool WebRequestSendMessageToExtensionAction::Equals(
 }
 
 std::string WebRequestSendMessageToExtensionAction::GetName() const {
-  return keys::kSendMessageToExtensionType;
+  return keys_wa::kSendMessageToExtensionType;
 }
 
 std::optional<EventResponseDelta>
diff --git a/extensions/browser/api/declarative_webrequest/webrequest_condition.cc b/extensions/browser/api/declarative_webrequest/webrequest_condition.cc
index a3d3cc69ed..7d2a80d8ed 100644
--- a/extensions/browser/api/declarative_webrequest/webrequest_condition.cc
+++ b/extensions/browser/api/declarative_webrequest/webrequest_condition.cc
@@ -18,8 +18,6 @@ using url_matcher::URLMatcherConditionFactory;
 using url_matcher::URLMatcherConditionSet;
 using url_matcher::URLMatcherFactory;
 
-namespace keys = extensions::declarative_webrequest_constants;
-
 namespace {
 static base::MatcherStringPattern::ID g_next_id = 0;
 
@@ -38,7 +36,7 @@ const char kConditionCannotBeFulfilled[] = "A condition can never be "
 
 namespace extensions {
 
-namespace keys = declarative_webrequest_constants;
+namespace keys_wrc = declarative_webrequest_constants;
 
 //
 // WebRequestData
@@ -128,12 +126,12 @@ std::unique_ptr<WebRequestCondition> WebRequestCondition::Create(
 
   // Verify that we are dealing with a Condition whose type we understand.
   const std::string* instance_type =
-      condition_dict->FindString(keys::kInstanceTypeKey);
+      condition_dict->FindString(keys_wrc::kInstanceTypeKey);
   if (!instance_type) {
     *error = kConditionWithoutInstanceType;
     return nullptr;
   }
-  if (*instance_type != keys::kRequestMatcherType) {
+  if (*instance_type != keys_wrc::kRequestMatcherType) {
     *error = kExpectedOtherConditionType;
     return nullptr;
   }
@@ -144,12 +142,12 @@ std::unique_ptr<WebRequestCondition> WebRequestCondition::Create(
   for (const auto entry : *condition_dict) {
     const std::string& condition_attribute_name = entry.first;
     const base::Value& condition_attribute_value = entry.second;
-    if (condition_attribute_name == keys::kInstanceTypeKey ||
+    if (condition_attribute_name == keys_wrc::kInstanceTypeKey ||
         condition_attribute_name ==
-            keys::kDeprecatedFirstPartyForCookiesUrlKey ||
-        condition_attribute_name == keys::kDeprecatedThirdPartyKey) {
+            keys_wrc::kDeprecatedFirstPartyForCookiesUrlKey ||
+        condition_attribute_name == keys_wrc::kDeprecatedThirdPartyKey) {
       // Skip this.
-    } else if (condition_attribute_name == keys::kUrlKey) {
+    } else if (condition_attribute_name == keys_wrc::kUrlKey) {
       const base::Value::Dict* dict = condition_attribute_value.GetIfDict();
       if (!dict) {
         *error = base::StringPrintf(kInvalidTypeOfParamter,
diff --git a/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc b/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc
index e92cb36031..48dfdd6f36 100644
--- a/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc
+++ b/extensions/browser/api/declarative_webrequest/webrequest_condition_attribute.cc
@@ -35,7 +35,7 @@ using base::CaseInsensitiveCompareASCII;
 using base::Value;
 
 namespace helpers = extension_web_request_api_helpers;
-namespace keys = extensions::declarative_webrequest_constants;
+namespace keys_wrca = extensions::declarative_webrequest_constants;
 
 namespace extensions {
 
@@ -50,31 +50,31 @@ struct WebRequestConditionAttributeFactory {
 
   WebRequestConditionAttributeFactory() : factory(5) {
     factory.RegisterFactoryMethod(
-        keys::kResourceTypeKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kResourceTypeKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeResourceType::Create);
 
     factory.RegisterFactoryMethod(
-        keys::kContentTypeKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kContentTypeKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeContentType::Create);
     factory.RegisterFactoryMethod(
-        keys::kExcludeContentTypeKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kExcludeContentTypeKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeContentType::Create);
 
     factory.RegisterFactoryMethod(
-        keys::kRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeRequestHeaders::Create);
     factory.RegisterFactoryMethod(
-        keys::kExcludeRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kExcludeRequestHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeRequestHeaders::Create);
 
     factory.RegisterFactoryMethod(
-        keys::kResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeResponseHeaders::Create);
     factory.RegisterFactoryMethod(
-        keys::kExcludeResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
+        keys_wrca::kExcludeResponseHeadersKey, FactoryT::IS_PARAMETERIZED,
         &WebRequestConditionAttributeResponseHeaders::Create);
 
-    factory.RegisterFactoryMethod(keys::kStagesKey, FactoryT::IS_PARAMETERIZED,
+    factory.RegisterFactoryMethod(keys_wrca::kStagesKey, FactoryT::IS_PARAMETERIZED,
                                   &WebRequestConditionAttributeStages::Create);
   }
 };
@@ -128,10 +128,10 @@ WebRequestConditionAttributeResourceType::Create(
     const base::Value* value,
     std::string* error,
     bool* bad_message) {
-  DCHECK(instance_type == keys::kResourceTypeKey);
+  DCHECK(instance_type == keys_wrca::kResourceTypeKey);
   if (!value->is_list()) {
     *error = ErrorUtils::FormatErrorMessage(kInvalidValue,
-                                            keys::kResourceTypeKey);
+                                            keys_wrca::kResourceTypeKey);
     return nullptr;
   }
   const base::Value::List& list = value->GetList();
@@ -147,7 +147,7 @@ WebRequestConditionAttributeResourceType::Create(
         !ParseWebRequestResourceType(resource_type_string,
                                      &passed_types.back())) {
       *error = ErrorUtils::FormatErrorMessage(kInvalidValue,
-                                              keys::kResourceTypeKey);
+                                              keys_wrca::kResourceTypeKey);
       return nullptr;
     }
   }
@@ -175,7 +175,7 @@ WebRequestConditionAttributeResourceType::GetType() const {
 }
 
 std::string WebRequestConditionAttributeResourceType::GetName() const {
-  return keys::kResourceTypeKey;
+  return keys_wrca::kResourceTypeKey;
 }
 
 bool WebRequestConditionAttributeResourceType::Equals(
@@ -208,7 +208,7 @@ WebRequestConditionAttributeContentType::Create(
       const base::Value* value,
       std::string* error,
       bool* bad_message) {
-  DCHECK(name == keys::kContentTypeKey || name == keys::kExcludeContentTypeKey);
+  DCHECK(name == keys_wrca::kContentTypeKey || name == keys_wrca::kExcludeContentTypeKey);
 
   if (!value->is_list()) {
     *error = ErrorUtils::FormatErrorMessage(kInvalidValue, name);
@@ -225,7 +225,7 @@ WebRequestConditionAttributeContentType::Create(
 
   return scoped_refptr<const WebRequestConditionAttribute>(
       new WebRequestConditionAttributeContentType(
-          content_types, name == keys::kContentTypeKey));
+          content_types, name == keys_wrca::kContentTypeKey));
 }
 
 int WebRequestConditionAttributeContentType::GetStages() const {
@@ -259,7 +259,7 @@ WebRequestConditionAttributeContentType::GetType() const {
 }
 
 std::string WebRequestConditionAttributeContentType::GetName() const {
-  return (inclusive_ ? keys::kContentTypeKey : keys::kExcludeContentTypeKey);
+  return (inclusive_ ? keys_wrca::kContentTypeKey : keys_wrca::kExcludeContentTypeKey);
 }
 
 bool WebRequestConditionAttributeContentType::Equals(
@@ -458,25 +458,25 @@ HeaderMatcher::HeaderMatchTest::Create(const base::Value::Dict& tests) {
   for (const auto entry : tests) {
     bool is_name = false;  // Is this test for header name?
     StringMatchTest::MatchType match_type;
-    if (entry.first == keys::kNamePrefixKey) {
+    if (entry.first == keys_wrca::kNamePrefixKey) {
       is_name = true;
       match_type = StringMatchTest::kPrefix;
-    } else if (entry.first == keys::kNameSuffixKey) {
+    } else if (entry.first == keys_wrca::kNameSuffixKey) {
       is_name = true;
       match_type = StringMatchTest::kSuffix;
-    } else if (entry.first == keys::kNameContainsKey) {
+    } else if (entry.first == keys_wrca::kNameContainsKey) {
       is_name = true;
       match_type = StringMatchTest::kContains;
-    } else if (entry.first == keys::kNameEqualsKey) {
+    } else if (entry.first == keys_wrca::kNameEqualsKey) {
       is_name = true;
       match_type = StringMatchTest::kEquals;
-    } else if (entry.first == keys::kValuePrefixKey) {
+    } else if (entry.first == keys_wrca::kValuePrefixKey) {
       match_type = StringMatchTest::kPrefix;
-    } else if (entry.first == keys::kValueSuffixKey) {
+    } else if (entry.first == keys_wrca::kValueSuffixKey) {
       match_type = StringMatchTest::kSuffix;
-    } else if (entry.first == keys::kValueContainsKey) {
+    } else if (entry.first == keys_wrca::kValueContainsKey) {
       match_type = StringMatchTest::kContains;
-    } else if (entry.first == keys::kValueEqualsKey) {
+    } else if (entry.first == keys_wrca::kValueEqualsKey) {
       match_type = StringMatchTest::kEquals;
     } else {
       NOTREACHED();  // JSON schema type checking should prevent this.
@@ -566,8 +566,8 @@ WebRequestConditionAttributeRequestHeaders::Create(
     const base::Value* value,
     std::string* error,
     bool* bad_message) {
-  DCHECK(name == keys::kRequestHeadersKey ||
-         name == keys::kExcludeRequestHeadersKey);
+  DCHECK(name == keys_wrca::kRequestHeadersKey ||
+         name == keys_wrca::kExcludeRequestHeadersKey);
 
   std::unique_ptr<const HeaderMatcher> header_matcher(
       PrepareHeaderMatcher(name, value, error));
@@ -576,7 +576,7 @@ WebRequestConditionAttributeRequestHeaders::Create(
 
   return scoped_refptr<const WebRequestConditionAttribute>(
       new WebRequestConditionAttributeRequestHeaders(
-          std::move(header_matcher), name == keys::kRequestHeadersKey));
+          std::move(header_matcher), name == keys_wrca::kRequestHeadersKey));
 }
 
 int WebRequestConditionAttributeRequestHeaders::GetStages() const {
@@ -609,8 +609,8 @@ WebRequestConditionAttributeRequestHeaders::GetType() const {
 }
 
 std::string WebRequestConditionAttributeRequestHeaders::GetName() const {
-  return (positive_ ? keys::kRequestHeadersKey
-                    : keys::kExcludeRequestHeadersKey);
+  return (positive_ ? keys_wrca::kRequestHeadersKey
+                    : keys_wrca::kExcludeRequestHeadersKey);
 }
 
 bool WebRequestConditionAttributeRequestHeaders::Equals(
@@ -639,8 +639,8 @@ WebRequestConditionAttributeResponseHeaders::Create(
     const base::Value* value,
     std::string* error,
     bool* bad_message) {
-  DCHECK(name == keys::kResponseHeadersKey ||
-         name == keys::kExcludeResponseHeadersKey);
+  DCHECK(name == keys_wrca::kResponseHeadersKey ||
+         name == keys_wrca::kExcludeResponseHeadersKey);
 
   std::unique_ptr<const HeaderMatcher> header_matcher(
       PrepareHeaderMatcher(name, value, error));
@@ -649,7 +649,7 @@ WebRequestConditionAttributeResponseHeaders::Create(
 
   return scoped_refptr<const WebRequestConditionAttribute>(
       new WebRequestConditionAttributeResponseHeaders(
-          std::move(header_matcher), name == keys::kResponseHeadersKey));
+          std::move(header_matcher), name == keys_wrca::kResponseHeadersKey));
 }
 
 int WebRequestConditionAttributeResponseHeaders::GetStages() const {
@@ -689,8 +689,8 @@ WebRequestConditionAttributeResponseHeaders::GetType() const {
 }
 
 std::string WebRequestConditionAttributeResponseHeaders::GetName() const {
-  return (positive_ ? keys::kResponseHeadersKey
-                    : keys::kExcludeResponseHeadersKey);
+  return (positive_ ? keys_wrca::kResponseHeadersKey
+                    : keys_wrca::kExcludeResponseHeadersKey);
 }
 
 bool WebRequestConditionAttributeResponseHeaders::Equals(
@@ -723,13 +723,13 @@ bool ParseListOfStages(const base::Value& value, int* out_stages) {
     if (!entry.is_string())
       return false;
     const std::string& stage_name = entry.GetString();
-    if (stage_name == keys::kOnBeforeRequestEnum) {
+    if (stage_name == keys_wrca::kOnBeforeRequestEnum) {
       stages |= ON_BEFORE_REQUEST;
-    } else if (stage_name == keys::kOnBeforeSendHeadersEnum) {
+    } else if (stage_name == keys_wrca::kOnBeforeSendHeadersEnum) {
       stages |= ON_BEFORE_SEND_HEADERS;
-    } else if (stage_name == keys::kOnHeadersReceivedEnum) {
+    } else if (stage_name == keys_wrca::kOnHeadersReceivedEnum) {
       stages |= ON_HEADERS_RECEIVED;
-    } else if (stage_name == keys::kOnAuthRequiredEnum) {
+    } else if (stage_name == keys_wrca::kOnAuthRequiredEnum) {
       stages |= ON_AUTH_REQUIRED;
     } else {
       NOTREACHED();  // JSON schema checks prevent getting here.
@@ -749,12 +749,12 @@ WebRequestConditionAttributeStages::Create(const std::string& name,
                                            const base::Value* value,
                                            std::string* error,
                                            bool* bad_message) {
-  DCHECK(name == keys::kStagesKey);
+  DCHECK(name == keys_wrca::kStagesKey);
 
   int allowed_stages = 0;
   if (!ParseListOfStages(*value, &allowed_stages)) {
     *error = ErrorUtils::FormatErrorMessage(kInvalidValue,
-                                                     keys::kStagesKey);
+                                                     keys_wrca::kStagesKey);
     return nullptr;
   }
 
@@ -778,7 +778,7 @@ WebRequestConditionAttributeStages::GetType() const {
 }
 
 std::string WebRequestConditionAttributeStages::GetName() const {
-  return keys::kStagesKey;
+  return keys_wrca::kStagesKey;
 }
 
 bool WebRequestConditionAttributeStages::Equals(
diff --git a/extensions/browser/api/hid/hid_connection_resource.cc b/extensions/browser/api/hid/hid_connection_resource.cc
index 3105a0d20c..337747d595 100644
--- a/extensions/browser/api/hid/hid_connection_resource.cc
+++ b/extensions/browser/api/hid/hid_connection_resource.cc
@@ -13,14 +13,14 @@
 namespace extensions {
 
 static base::LazyInstance<BrowserContextKeyedAPIFactory<
-    ApiResourceManager<HidConnectionResource>>>::DestructorAtExit g_factory =
+    ApiResourceManager<HidConnectionResource>>>::DestructorAtExit g_factoryHCR =
     LAZY_INSTANCE_INITIALIZER;
 
 // static
 template <>
 BrowserContextKeyedAPIFactory<ApiResourceManager<HidConnectionResource> >*
 ApiResourceManager<HidConnectionResource>::GetFactoryInstance() {
-  return &g_factory.Get();
+  return &g_factoryHCR.Get();
 }
 
 HidConnectionResource::HidConnectionResource(
diff --git a/extensions/browser/api/hid/hid_device_manager.cc b/extensions/browser/api/hid/hid_device_manager.cc
index 7d1ae14c70..e0c2f11b9a 100644
--- a/extensions/browser/api/hid/hid_device_manager.cc
+++ b/extensions/browser/api/hid/hid_device_manager.cc
@@ -135,7 +135,7 @@ bool WillDispatchDeviceEvent(
   return false;
 }
 
-HidDeviceManager::HidManagerBinder& GetHidManagerBinderOverride() {
+HidDeviceManager::HidManagerBinder& GetHidDeviceManagerBinderOverride() {
   static base::NoDestructor<HidDeviceManager::HidManagerBinder> binder;
   return *binder;
 }
@@ -339,7 +339,7 @@ void HidDeviceManager::LazyInitialize() {
 
     DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
     auto receiver = hid_manager_.BindNewPipeAndPassReceiver();
-    const auto& binder = GetHidManagerBinderOverride();
+    const auto& binder = GetHidDeviceManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
     else
@@ -360,7 +360,7 @@ void HidDeviceManager::LazyInitialize() {
 // static
 void HidDeviceManager::OverrideHidManagerBinderForTesting(
     HidManagerBinder binder) {
-  GetHidManagerBinderOverride() = std::move(binder);
+  GetHidDeviceManagerBinderOverride() = std::move(binder);
 }
 
 base::Value::List HidDeviceManager::CreateApiDeviceList(
diff --git a/extensions/browser/api/usb/usb_device_manager.cc b/extensions/browser/api/usb/usb_device_manager.cc
index 2d4e7105ce..ca758f3911 100644
--- a/extensions/browser/api/usb/usb_device_manager.cc
+++ b/extensions/browser/api/usb/usb_device_manager.cc
@@ -67,7 +67,7 @@ bool ShouldExposeDevice(const device::mojom::UsbDeviceInfo& device_info) {
 
 // Returns true if the given extension has permission to receive events
 // regarding this device.
-bool WillDispatchDeviceEvent(
+bool MyWillDispatchDeviceEvent(
     const device::mojom::UsbDeviceInfo& device_info,
     content::BrowserContext* browser_context,
     mojom::ContextType target_context,
@@ -389,7 +389,7 @@ void UsbDeviceManager::DispatchEvent(
     }
 
     event->will_dispatch_callback =
-        base::BindRepeating(&WillDispatchDeviceEvent, std::cref(device_info));
+        base::BindRepeating(&MyWillDispatchDeviceEvent, std::cref(device_info));
     event_router->BroadcastEvent(std::move(event));
   }
 }
diff --git a/extensions/browser/api/usb/usb_device_resource.cc b/extensions/browser/api/usb/usb_device_resource.cc
index 22b273b1a1..4f50b899a8 100644
--- a/extensions/browser/api/usb/usb_device_resource.cc
+++ b/extensions/browser/api/usb/usb_device_resource.cc
@@ -18,14 +18,14 @@ using content::BrowserThread;
 namespace extensions {
 
 static base::LazyInstance<BrowserContextKeyedAPIFactory<
-    ApiResourceManager<UsbDeviceResource>>>::DestructorAtExit g_factory =
+    ApiResourceManager<UsbDeviceResource>>>::DestructorAtExit g_factory2 =
     LAZY_INSTANCE_INITIALIZER;
 
 // static
 template <>
 BrowserContextKeyedAPIFactory<ApiResourceManager<UsbDeviceResource> >*
 ApiResourceManager<UsbDeviceResource>::GetFactoryInstance() {
-  return g_factory.Pointer();
+  return g_factory2.Pointer();
 }
 
 UsbDeviceResource::UsbDeviceResource(
diff --git a/extensions/browser/api/web_request/upload_data_presenter.cc b/extensions/browser/api/web_request/upload_data_presenter.cc
index 10c38c7b13..bf64fb4464 100644
--- a/extensions/browser/api/web_request/upload_data_presenter.cc
+++ b/extensions/browser/api/web_request/upload_data_presenter.cc
@@ -16,7 +16,7 @@
 #include "extensions/browser/api/web_request/web_request_api_constants.h"
 #include "net/base/upload_file_element_reader.h"
 
-namespace keys = extension_web_request_api_constants;
+namespace keys_udp = extension_web_request_api_constants;
 
 namespace {
 
@@ -70,13 +70,13 @@ std::optional<base::Value> RawDataPresenter::TakeResult() {
 
 void RawDataPresenter::FeedNextBytes(const char* bytes, size_t size) {
   subtle::AppendKeyValuePair(
-      keys::kRequestBodyRawBytesKey,
+      keys_udp::kRequestBodyRawBytesKey,
       base::Value(base::as_bytes(base::make_span(bytes, size))), list_);
 }
 
 void RawDataPresenter::FeedNextFile(const std::string& filename) {
   // Insert the file path instead of the contents, which may be too large.
-  subtle::AppendKeyValuePair(keys::kRequestBodyRawFileKey,
+  subtle::AppendKeyValuePair(keys_udp::kRequestBodyRawFileKey,
                              base::Value(filename), list_);
 }
 
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index 1428bb77b1..aa6feea0ee 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -71,7 +71,7 @@ using extension_web_request_api_helpers::ExtraInfoSpec;
 using extensions::mojom::APIPermissionID;
 
 namespace helpers = extension_web_request_api_helpers;
-namespace keys = extension_web_request_api_constants;
+namespace keys_wra = extension_web_request_api_constants;
 using URLLoaderFactoryType =
     content::ContentBrowserClient::URLLoaderFactoryType;
 
@@ -86,15 +86,15 @@ namespace {
 bool FromHeaderDictionary(const base::Value::Dict& header_value,
                           std::string* name,
                           std::string* out_value) {
-  const std::string* name_ptr = header_value.FindString(keys::kHeaderNameKey);
+  const std::string* name_ptr = header_value.FindString(keys_wra::kHeaderNameKey);
   if (!name) {
     return false;
   }
   *name = *name_ptr;
 
-  const base::Value* value = header_value.Find(keys::kHeaderValueKey);
+  const base::Value* value = header_value.Find(keys_wra::kHeaderValueKey);
   const base::Value* binary_value =
-      header_value.Find(keys::kHeaderBinaryValueKey);
+      header_value.Find(keys_wra::kHeaderBinaryValueKey);
   // We require either a "value" or a "binaryValue" entry, but not both.
   if ((value == nullptr && binary_value == nullptr) ||
       (value != nullptr && binary_value != nullptr)) {
@@ -136,7 +136,7 @@ bool HasAnyWebRequestPermissions(const Extension* extension) {
 
 // Mirrors the histogram enum of the same name. DO NOT REORDER THESE VALUES OR
 // CHANGE THEIR MEANING.
-enum class WebRequestEventListenerFlag {
+enum class WebRequestEventListenerFlagWRA {
   kTotal,
   kNone,
   kRequestHeaders,
@@ -298,13 +298,13 @@ void WebRequestAPI::Shutdown() {
 }
 
 static base::LazyInstance<
-    BrowserContextKeyedAPIFactory<WebRequestAPI>>::DestructorAtExit g_factory =
+    BrowserContextKeyedAPIFactory<WebRequestAPI>>::DestructorAtExit g_factory_wra =
     LAZY_INSTANCE_INITIALIZER;
 
 // static
 BrowserContextKeyedAPIFactory<WebRequestAPI>*
 WebRequestAPI::GetFactoryInstance() {
-  return g_factory.Pointer();
+  return g_factory_wra.Pointer();
 }
 
 void WebRequestAPI::OnListenerRemoved(const EventListenerInfo& details) {
@@ -786,7 +786,7 @@ WebRequestInternalAddEventListenerFunction::Run() {
         return true;
       }
 
-      return event_name == keys::kOnAuthRequiredEvent &&
+      return event_name == keys_wra::kOnAuthRequiredEvent &&
              extension->permissions_data()->HasAPIPermission(
                  APIPermissionID::kWebRequestAuthProvider);
     };
@@ -797,7 +797,7 @@ WebRequestInternalAddEventListenerFunction::Run() {
     bool is_blocking = extra_info_spec & (ExtraInfoSpec::BLOCKING |
                                           ExtraInfoSpec::ASYNC_BLOCKING);
     if (is_blocking && !has_blocking_permission()) {
-      return RespondNow(Error(keys::kBlockingPermissionRequired));
+      return RespondNow(Error(keys_wra::kBlockingPermissionRequired));
     }
 
     // We allow to subscribe to patterns that are broader than the host
@@ -813,7 +813,7 @@ WebRequestInternalAddEventListenerFunction::Run() {
             ->withheld_permissions()
             .explicit_hosts()
             .is_empty()) {
-      return RespondNow(Error(keys::kHostPermissionsRequired));
+      return RespondNow(Error(keys_wra::kHostPermissionsRequired));
     }
   }
 
@@ -881,7 +881,7 @@ WebRequestInternalEventHandledFunction::Run() {
 
     const base::Value* redirect_url_value = dict_value.Find("redirectUrl");
     const base::Value* auth_credentials_value =
-        dict_value.Find(keys::kAuthCredentialsKey);
+        dict_value.Find(keys_wra::kAuthCredentialsKey);
     const base::Value* request_headers_value =
         dict_value.Find("requestHeaders");
     const base::Value* response_headers_value =
@@ -893,7 +893,7 @@ WebRequestInternalEventHandledFunction::Run() {
       if (dict_value.size() != 1) {
         OnError(event_name, sub_event_name, request_id, render_process_id,
                 web_view_instance_id, std::move(response));
-        return RespondNow(Error(keys::kInvalidBlockingResponse));
+        return RespondNow(Error(keys_wra::kInvalidBlockingResponse));
       }
 
       EXTENSION_FUNCTION_VALIDATE(cancel_value->is_bool());
@@ -907,7 +907,7 @@ WebRequestInternalEventHandledFunction::Run() {
       if (!response->new_url.is_valid()) {
         OnError(event_name, sub_event_name, request_id, render_process_id,
                 web_view_instance_id, std::move(response));
-        return RespondNow(Error(keys::kInvalidRedirectUrl, new_url_str));
+        return RespondNow(Error(keys_wra::kInvalidRedirectUrl, new_url_str));
       }
     }
 
@@ -918,7 +918,7 @@ WebRequestInternalEventHandledFunction::Run() {
         // Allow only one of the keys, not both.
         OnError(event_name, sub_event_name, request_id, render_process_id,
                 web_view_instance_id, std::move(response));
-        return RespondNow(Error(keys::kInvalidHeaderKeyCombination));
+        return RespondNow(Error(keys_wra::kInvalidHeaderKeyCombination));
       }
 
       const base::Value::List* headers_value = nullptr;
@@ -926,10 +926,10 @@ WebRequestInternalEventHandledFunction::Run() {
       std::unique_ptr<helpers::ResponseHeaders> response_headers;
       if (has_request_headers) {
         request_headers = std::make_unique<net::HttpRequestHeaders>();
-        headers_value = dict_value.FindList(keys::kRequestHeadersKey);
+        headers_value = dict_value.FindList(keys_wra::kRequestHeadersKey);
       } else {
         response_headers = std::make_unique<helpers::ResponseHeaders>();
-        headers_value = dict_value.FindList(keys::kResponseHeadersKey);
+        headers_value = dict_value.FindList(keys_wra::kResponseHeadersKey);
       }
       EXTENSION_FUNCTION_VALIDATE(headers_value);
 
@@ -943,17 +943,17 @@ WebRequestInternalEventHandledFunction::Run() {
           base::JSONWriter::Write(header_value, &serialized_header);
           OnError(event_name, sub_event_name, request_id, render_process_id,
                   web_view_instance_id, std::move(response));
-          return RespondNow(Error(keys::kInvalidHeader, serialized_header));
+          return RespondNow(Error(keys_wra::kInvalidHeader, serialized_header));
         }
         if (!net::HttpUtil::IsValidHeaderName(name)) {
           OnError(event_name, sub_event_name, request_id, render_process_id,
                   web_view_instance_id, std::move(response));
-          return RespondNow(Error(keys::kInvalidHeaderName));
+          return RespondNow(Error(keys_wra::kInvalidHeaderName));
         }
         if (!net::HttpUtil::IsValidHeaderValue(value)) {
           OnError(event_name, sub_event_name, request_id, render_process_id,
                   web_view_instance_id, std::move(response));
-          return RespondNow(Error(keys::kInvalidHeaderValue, name));
+          return RespondNow(Error(keys_wra::kInvalidHeaderValue, name));
         }
         if (has_request_headers) {
           request_headers->SetHeader(name, value);
@@ -973,9 +973,9 @@ WebRequestInternalEventHandledFunction::Run() {
           auth_credentials_value->GetIfDict();
       EXTENSION_FUNCTION_VALIDATE(credentials_value);
       const std::string* username =
-          credentials_value->FindString(keys::kUsernameKey);
+          credentials_value->FindString(keys_wra::kUsernameKey);
       const std::string* password =
-          credentials_value->FindString(keys::kPasswordKey);
+          credentials_value->FindString(keys_wra::kPasswordKey);
       EXTENSION_FUNCTION_VALIDATE(username);
       EXTENSION_FUNCTION_VALIDATE(password);
       response->auth_credentials = net::AuthCredentials(
diff --git a/extensions/browser/api/web_request/web_request_info.cc b/extensions/browser/api/web_request/web_request_info.cc
index 3c4ba5fe4a..f7d5f3769f 100644
--- a/extensions/browser/api/web_request/web_request_info.cc
+++ b/extensions/browser/api/web_request/web_request_info.cc
@@ -29,7 +29,7 @@
 #include "services/network/public/mojom/url_response_head.mojom.h"
 #include "services/network/url_loader.h"
 
-namespace keys = extension_web_request_api_constants;
+namespace keys_wri = extension_web_request_api_constants;
 
 namespace extensions {
 
@@ -129,8 +129,8 @@ std::optional<base::Value::Dict> CreateRequestBodyData(
       &raw_data_presenter      // 2: any data at all? (Non-specific.)
   };
   // Keys for the results of the corresponding presenters.
-  static const char* const kKeys[] = {keys::kRequestBodyFormDataKey,
-                                      keys::kRequestBodyRawKey};
+  static const char* const kKeys[] = {keys_wri::kRequestBodyFormDataKey,
+                                      keys_wri::kRequestBodyRawKey};
   bool some_succeeded = false;
   if (!data_sources.empty()) {
     for (size_t i = 0; i < std::size(presenters); ++i) {
@@ -145,7 +145,7 @@ std::optional<base::Value::Dict> CreateRequestBodyData(
   }
 
   if (!some_succeeded) {
-    request_body_data.Set(keys::kRequestBodyErrorKey, "Unknown error.");
+    request_body_data.Set(keys_wri::kRequestBodyErrorKey, "Unknown error.");
   }
 
   return request_body_data;
diff --git a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc
index 2d870df9cc..e2703df591 100644
--- a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc
+++ b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.cc
@@ -79,26 +79,26 @@ constexpr char kWebRequestProxyingURLLoaderFactoryScope[] =
 // This shutdown notifier makes sure the proxy is destroyed if an incognito
 // browser context is destroyed. This is needed because WebRequestAPI only
 // clears the proxies when the original browser context is destroyed.
-class ShutdownNotifierFactory
+class ShutdownNotifierFactory2
     : public BrowserContextKeyedServiceShutdownNotifierFactory {
  public:
-  ShutdownNotifierFactory(const ShutdownNotifierFactory&) = delete;
-  ShutdownNotifierFactory& operator=(const ShutdownNotifierFactory&) = delete;
+  ShutdownNotifierFactory2(const ShutdownNotifierFactory2&) = delete;
+  ShutdownNotifierFactory2& operator=(const ShutdownNotifierFactory2&) = delete;
 
-  static ShutdownNotifierFactory* GetInstance() {
-    static base::NoDestructor<ShutdownNotifierFactory> factory;
+  static ShutdownNotifierFactory2* GetInstance() {
+    static base::NoDestructor<ShutdownNotifierFactory2> factory;
     return factory.get();
   }
 
  private:
-  friend class base::NoDestructor<ShutdownNotifierFactory>;
+  friend class base::NoDestructor<ShutdownNotifierFactory2>;
 
-  ShutdownNotifierFactory()
+  ShutdownNotifierFactory2()
       : BrowserContextKeyedServiceShutdownNotifierFactory(
             "WebRequestProxyingURLLoaderFactory") {
     DependsOn(PermissionHelper::GetFactoryInstance());
   }
-  ~ShutdownNotifierFactory() override {}
+  ~ShutdownNotifierFactory2() override {}
 
   content::BrowserContext* GetBrowserContextToUse(
       content::BrowserContext* context) const override {
@@ -1463,7 +1463,7 @@ WebRequestProxyingURLLoaderFactory::WebRequestProxyingURLLoaderFactory(
   // canceled when |shutdown_notifier_subscription_| is destroyed, and
   // |proxies_| owns this.
   shutdown_notifier_subscription_ =
-      ShutdownNotifierFactory::GetInstance()
+      ShutdownNotifierFactory2::GetInstance()
           ->Get(browser_context)
           ->Subscribe(base::BindRepeating(&WebRequestAPI::ProxySet::RemoveProxy,
                                           base::Unretained(proxies_), this));
@@ -1659,7 +1659,7 @@ void WebRequestProxyingURLLoaderFactory::MaybeRemoveProxy() {
 
 // static
 void WebRequestProxyingURLLoaderFactory::EnsureAssociatedFactoryBuilt() {
-  ShutdownNotifierFactory::GetInstance();
+  ShutdownNotifierFactory2::GetInstance();
 }
 
 }  // namespace extensions
diff --git a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h
index 318a63073f..12aff0ff2e 100644
--- a/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h
+++ b/extensions/browser/api/web_request/web_request_proxying_url_loader_factory.h
@@ -39,7 +39,7 @@
 #include "url/gurl.h"
 #include "url/origin.h"
 
-namespace {
+namespace content {
 class BrowserContext;
 }
 
diff --git a/extensions/browser/app_window/app_window.cc b/extensions/browser/app_window/app_window.cc
index 224e2acfb7..c813a524e2 100644
--- a/extensions/browser/app_window/app_window.cc
+++ b/extensions/browser/app_window/app_window.cc
@@ -233,7 +233,7 @@ gfx::Size AppWindow::CreateParams::GetWindowMaximumSize(
 
 // AppWindow
 
-AppWindow::AppWindow(BrowserContext* context,
+AppWindow::AppWindow(content::BrowserContext* context,
                      std::unique_ptr<AppDelegate> app_delegate,
                      const Extension* extension)
     : browser_context_(context),
@@ -946,7 +946,7 @@ content::WebContents* AppWindow::GetAssociatedWebContents() const {
   return web_contents();
 }
 
-void AppWindow::OnExtensionUnloaded(BrowserContext* browser_context,
+void AppWindow::OnExtensionUnloaded(content::BrowserContext* browser_context,
                                     const Extension* extension,
                                     UnloadedExtensionReason reason) {
   if (extension_id_ == extension->id())
@@ -976,7 +976,7 @@ void AppWindow::SaveWindowPosition() {
 
   gfx::Rect bounds = native_app_window_->GetRestoredBounds();
   gfx::Rect screen_bounds =
-      display::Screen::GetScreen()->GetDisplayMatching(bounds).work_area();
+      ::display::Screen::GetScreen()->GetDisplayMatching(bounds).work_area();
   ui::WindowShowState window_state = native_app_window_->GetRestoredState();
   cache->SaveGeometry(extension_id(), window_key_, bounds, screen_bounds,
                       window_state);
@@ -1037,8 +1037,8 @@ AppWindow::CreateParams AppWindow::LoadDefaults(CreateParams params) const {
                            &cached_screen_bounds, &cached_state)) {
       // App window has cached screen bounds, make sure it fits on screen in
       // case the screen resolution changed.
-      display::Screen* screen = display::Screen::GetScreen();
-      display::Display display = screen->GetDisplayMatching(cached_bounds);
+      ::display::Screen* screen = ::display::Screen::GetScreen();
+      ::display::Display display = screen->GetDisplayMatching(cached_bounds);
       gfx::Rect current_screen_bounds = display.work_area();
       SizeConstraints constraints(params.GetWindowMinimumSize(gfx::Insets()),
                                   params.GetWindowMaximumSize(gfx::Insets()));
diff --git a/extensions/browser/extension_message_filter.cc b/extensions/browser/extension_message_filter.cc
index 3c2fc6ddef..c08c4b885b 100644
--- a/extensions/browser/extension_message_filter.cc
+++ b/extensions/browser/extension_message_filter.cc
@@ -20,25 +20,25 @@ namespace extensions {
 
 namespace {
 
-class ShutdownNotifierFactory
+class ShutdownNotifierFactoryForExtensionMessageFilter
     : public BrowserContextKeyedServiceShutdownNotifierFactory {
  public:
-  ShutdownNotifierFactory(const ShutdownNotifierFactory&) = delete;
-  ShutdownNotifierFactory& operator=(const ShutdownNotifierFactory&) = delete;
+  ShutdownNotifierFactoryForExtensionMessageFilter(const ShutdownNotifierFactoryForExtensionMessageFilter&) = delete;
+  ShutdownNotifierFactoryForExtensionMessageFilter& operator=(const ShutdownNotifierFactoryForExtensionMessageFilter&) = delete;
 
-  static ShutdownNotifierFactory* GetInstance() {
-    return base::Singleton<ShutdownNotifierFactory>::get();
+  static ShutdownNotifierFactoryForExtensionMessageFilter* GetInstance() {
+    return base::Singleton<ShutdownNotifierFactoryForExtensionMessageFilter>::get();
   }
 
  private:
-  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactory>;
+  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactoryForExtensionMessageFilter>;
 
-  ShutdownNotifierFactory()
+  ShutdownNotifierFactoryForExtensionMessageFilter()
       : BrowserContextKeyedServiceShutdownNotifierFactory(
             "ExtensionMessageFilter") {
     DependsOn(ProcessManagerFactory::GetInstance());
   }
-  ~ShutdownNotifierFactory() override {}
+  ~ShutdownNotifierFactoryForExtensionMessageFilter() override {}
 
   content::BrowserContext* GetBrowserContextToUse(
       content::BrowserContext* context) const override {
@@ -56,13 +56,13 @@ ExtensionMessageFilter::ExtensionMessageFilter(int render_process_id,
       browser_context_(context) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   shutdown_notifier_subscription_ =
-      ShutdownNotifierFactory::GetInstance()->Get(context)->Subscribe(
+      ShutdownNotifierFactoryForExtensionMessageFilter::GetInstance()->Get(context)->Subscribe(
           base::BindRepeating(&ExtensionMessageFilter::ShutdownOnUIThread,
                               base::Unretained(this)));
 }
 
 void ExtensionMessageFilter::EnsureShutdownNotifierFactoryBuilt() {
-  ShutdownNotifierFactory::GetInstance();
+  ShutdownNotifierFactoryForExtensionMessageFilter::GetInstance();
 }
 
 ExtensionMessageFilter::~ExtensionMessageFilter() {
diff --git a/extensions/browser/extension_service_worker_message_filter.cc b/extensions/browser/extension_service_worker_message_filter.cc
index cfe76daffb..66c2ce53b8 100644
--- a/extensions/browser/extension_service_worker_message_filter.cc
+++ b/extensions/browser/extension_service_worker_message_filter.cc
@@ -26,27 +26,27 @@ namespace extensions {
 
 namespace {
 
-class ShutdownNotifierFactory
+class ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter
     : public BrowserContextKeyedServiceShutdownNotifierFactory {
  public:
-  ShutdownNotifierFactory(const ShutdownNotifierFactory&) = delete;
-  ShutdownNotifierFactory& operator=(const ShutdownNotifierFactory&) = delete;
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter(const ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter&) = delete;
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter& operator=(const ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter&) = delete;
 
-  static ShutdownNotifierFactory* GetInstance() {
-    return base::Singleton<ShutdownNotifierFactory>::get();
+  static ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter* GetInstance() {
+    return base::Singleton<ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter>::get();
   }
 
  private:
-  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactory>;
+  friend struct base::DefaultSingletonTraits<ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter>;
 
-  ShutdownNotifierFactory()
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter()
       : BrowserContextKeyedServiceShutdownNotifierFactory(
             "ExtensionServiceWorkerMessageFilter") {
     DependsOn(ExtensionRegistryFactory::GetInstance());
     DependsOn(EventRouterFactory::GetInstance());
     DependsOn(ProcessManagerFactory::GetInstance());
   }
-  ~ShutdownNotifierFactory() override = default;
+  ~ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter() override = default;
 
   content::BrowserContext* GetBrowserContextToUse(
       content::BrowserContext* context) const override {
@@ -67,7 +67,7 @@ ExtensionServiceWorkerMessageFilter::ExtensionServiceWorkerMessageFilter(
       service_worker_context_(service_worker_context) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   shutdown_notifier_subscription_ =
-      ShutdownNotifierFactory::GetInstance()->Get(context)->Subscribe(
+      ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter::GetInstance()->Get(context)->Subscribe(
           base::BindRepeating(
               &ExtensionServiceWorkerMessageFilter::ShutdownOnUIThread,
               base::Unretained(this)));
@@ -83,7 +83,7 @@ void ExtensionServiceWorkerMessageFilter::OnDestruct() const {
 }
 
 void ExtensionServiceWorkerMessageFilter::EnsureShutdownNotifierFactoryBuilt() {
-  ShutdownNotifierFactory::GetInstance();
+  ShutdownNotifierFactoryForExtensionServiceWorkerMessageFilter::GetInstance();
 }
 
 ExtensionServiceWorkerMessageFilter::~ExtensionServiceWorkerMessageFilter() =
diff --git a/extensions/browser/guest_view/web_view/web_view_guest.cc b/extensions/browser/guest_view/web_view/web_view_guest.cc
index c50c7822d6..9fe5b9c9ce 100644
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -810,7 +810,7 @@ WebViewGuest::WebViewGuest(content::RenderFrameHost* owner_rfh)
           ExtensionsAPIClient::Get()->CreateWebViewGuestDelegate(this))),
       is_spatial_navigation_enabled_(
           base::CommandLine::ForCurrentProcess()->HasSwitch(
-              switches::kEnableSpatialNavigation)) {}
+              ::switches::kEnableSpatialNavigation)) {}
 
 WebViewGuest::~WebViewGuest() {
   if (!attached() && GetOpener())
diff --git a/extensions/common/BUILD.gn b/extensions/common/BUILD.gn
index f25d861b3c..e4257b3e85 100644
--- a/extensions/common/BUILD.gn
+++ b/extensions/common/BUILD.gn
@@ -489,6 +489,11 @@ jumbo_static_library("common") {
   # from mojom/permission_set_mojom_traits.cc.
   allow_circular_includes_from = [ ":mojom" ]
 
+  jumbo_excluded_sources = [
+    "manifest_handlers/file_handler_info.cc",
+    "manifest_handlers/permissions_parser.cc",
+  ]
+
   deps = [
     "//base",
     "//build:branding_buildflags",
diff --git a/extensions/common/manifest_handlers/shared_module_info.cc b/extensions/common/manifest_handlers/shared_module_info.cc
index d7687e5982..92d665fd30 100644
--- a/extensions/common/manifest_handlers/shared_module_info.cc
+++ b/extensions/common/manifest_handlers/shared_module_info.cc
@@ -37,7 +37,7 @@ namespace {
 const char kSharedModule[] = "shared_module";
 const char kAllowlist[] = "allowlist";
 
-using ManifestKeys = api::shared_module::ManifestKeys;
+using ManifestKeys2 = api::shared_module::ManifestKeys;
 
 static base::LazyInstance<SharedModuleInfo>::DestructorAtExit
     g_empty_shared_module_info = LAZY_INSTANCE_INITIALIZER;
@@ -132,8 +132,8 @@ SharedModuleHandler::~SharedModuleHandler() = default;
 bool SharedModuleHandler::Parse(Extension* extension, std::u16string* error) {
   CHECK(extension);
   CHECK(error);
-  ManifestKeys manifest_keys;
-  if (!ManifestKeys::ParseFromDictionary(
+  ManifestKeys2 manifest_keys;
+  if (!ManifestKeys2::ParseFromDictionary(
           extension->manifest()->available_values(), manifest_keys, *error)) {
     return false;
   }
@@ -241,8 +241,8 @@ bool SharedModuleHandler::Validate(
 }
 
 base::span<const char* const> SharedModuleHandler::Keys() const {
-  static constexpr const char* kKeys[] = {ManifestKeys::kImport,
-                                          ManifestKeys::kExport};
+  static constexpr const char* kKeys[] = {ManifestKeys2::kImport,
+                                          ManifestKeys2::kExport};
   return kKeys;
 }
 
diff --git a/extensions/renderer/extension_url_loader_throttle.cc b/extensions/renderer/extension_url_loader_throttle.cc
index 1f61f2b45a..d8151c3c40 100644
--- a/extensions/renderer/extension_url_loader_throttle.cc
+++ b/extensions/renderer/extension_url_loader_throttle.cc
@@ -12,7 +12,7 @@ namespace extensions {
 
 namespace {
 
-const char kCancelReason[] = "ExtensionURLLoaderThrottle";
+const char kCancelReasonEULT[] = "ExtensionURLLoaderThrottle";
 
 }  // anonymous namespace
 
@@ -29,7 +29,7 @@ void ExtensionURLLoaderThrottle::WillStartRequest(
     bool* defer) {
   start_request_url_ = request->url;
   if (manager_->ShouldRejectRequest(start_request_url_))
-    delegate_->CancelWithError(net::ERR_TEMPORARILY_THROTTLED, kCancelReason);
+    delegate_->CancelWithError(net::ERR_TEMPORARILY_THROTTLED, kCancelReasonEULT);
 }
 
 void ExtensionURLLoaderThrottle::WillRedirectRequest(
@@ -40,7 +40,7 @@ void ExtensionURLLoaderThrottle::WillRedirectRequest(
     net::HttpRequestHeaders* /* modified_request_headers */,
     net::HttpRequestHeaders* /* modified_cors_exempt_request_headers */) {
   if (manager_->ShouldRejectRedirect(start_request_url_, *redirect_info)) {
-    delegate_->CancelWithError(net::ERR_TEMPORARILY_THROTTLED, kCancelReason);
+    delegate_->CancelWithError(net::ERR_TEMPORARILY_THROTTLED, kCancelReasonEULT);
   }
 }
 
diff --git a/gpu/command_buffer/service/BUILD.gn b/gpu/command_buffer/service/BUILD.gn
index 084a2f6fc5..72eab27b6d 100644
--- a/gpu/command_buffer/service/BUILD.gn
+++ b/gpu/command_buffer/service/BUILD.gn
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//skia/features.gni")
@@ -27,9 +26,9 @@ group("gles2") {
 }
 
 if (is_component_build) {
-  link_target_type = "jumbo_source_set"
+  link_target_type = "source_set"
 } else {
-  link_target_type = "jumbo_static_library"
+  link_target_type = "static_library"
 }
 target(link_target_type, "service_sources") {
   # External code should depend on this via //gpu/command_buffer/service above
@@ -650,7 +649,7 @@ proto_library("disk_cache_proto") {
 }
 
 if (is_android) {
-  jumbo_static_library("android_texture_owner_test_support") {
+  static_library("android_texture_owner_test_support") {
     testonly = true
     sources = [
       "mock_texture_owner.cc",
diff --git a/gpu/config/BUILD.gn b/gpu/config/BUILD.gn
index 277227449f..4ff377cd8e 100644
--- a/gpu/config/BUILD.gn
+++ b/gpu/config/BUILD.gn
@@ -5,7 +5,6 @@
 import("//build/config/cast.gni")
 import("//build/config/chrome_build.gni")
 import("//build/config/chromeos/ui_mode.gni")
-import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//skia/features.gni")
@@ -125,7 +124,7 @@ source_set("webgpu_blocklist_impl") {
   public_deps = [ "//third_party/dawn/include/dawn:headers" ]
 }
 
-jumbo_source_set("config_sources") {
+source_set("config_sources") {
   # External code should depend on this via //gpu/config above rather than
   # depending on this directly or the component build will break.
   visibility = [ "//gpu/*" ]
diff --git a/gpu/ipc/service/BUILD.gn b/gpu/ipc/service/BUILD.gn
index f3b0ecccad..e321b406a8 100644
--- a/gpu/ipc/service/BUILD.gn
+++ b/gpu/ipc/service/BUILD.gn
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//testing/test.gni")
@@ -15,7 +14,7 @@ declare_args() {
   subpixel_font_rendering_disabled = false
 }
 
-jumbo_component("service") {
+component("service") {
   output_name = "gpu_ipc_service"
   sources = [
     "command_buffer_stub.cc",
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index b3c80d0943..9dfd58e5d7 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -3,6 +3,7 @@
 # found in the LICENSE file.
 
 import("//build/config/chromeos/ui_mode.gni")
+import("//build/config/jumbo.gni")
 import("//build/config/linux/pkg_config.gni")
 import("//media/media_options.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
@@ -26,7 +27,7 @@ config("platform_config") {
   }
 }
 
-source_set("audio") {
+jumbo_source_set("audio") {
   # Do not expand the visibility here without double-checking with OWNERS, this
   # is a roll-up target which is part of the //media component. Most other DEPs
   # should be using //media and not directly DEP this roll-up target.
diff --git a/media/audio/alsa/alsa_input.cc b/media/audio/alsa/alsa_input.cc
index 5694b8aefa..8d06635dbe 100644
--- a/media/audio/alsa/alsa_input.cc
+++ b/media/audio/alsa/alsa_input.cc
@@ -18,8 +18,8 @@
 
 namespace media {
 
-static const SampleFormat kSampleFormat = kSampleFormatS16;
-static const snd_pcm_format_t kAlsaSampleFormat = SND_PCM_FORMAT_S16;
+static const SampleFormat kSampleFormatAI = kSampleFormatS16;
+static const snd_pcm_format_t kAlsaSampleFormatAI = SND_PCM_FORMAT_S16;
 
 static const int kNumPacketsInRingBuffer = 3;
 
@@ -35,7 +35,7 @@ AlsaPcmInputStream::AlsaPcmInputStream(AudioManagerBase* audio_manager,
     : audio_manager_(audio_manager),
       device_name_(device_name),
       params_(params),
-      bytes_per_buffer_(params.GetBytesPerBuffer(kSampleFormat)),
+      bytes_per_buffer_(params.GetBytesPerBuffer(kSampleFormatAI)),
       wrapper_(wrapper),
       buffer_duration_(base::Microseconds(
           params.frames_per_buffer() * base::Time::kMicrosecondsPerSecond /
@@ -66,7 +66,7 @@ AudioInputStream::OpenOutcome AlsaPcmInputStream::Open() {
     for (size_t i = 0; i < std::size(device_names); ++i) {
       device_handle_ = alsa_util::OpenCaptureDevice(
           wrapper_, device_names[i], params_.channels(), params_.sample_rate(),
-          kAlsaSampleFormat, buffer_us, packet_us);
+          kAlsaSampleFormatAI, buffer_us, packet_us);
 
       if (device_handle_) {
         device_name_ = device_names[i];
@@ -76,7 +76,7 @@ AudioInputStream::OpenOutcome AlsaPcmInputStream::Open() {
   } else {
     device_handle_ = alsa_util::OpenCaptureDevice(
         wrapper_, device_name_.c_str(), params_.channels(),
-        params_.sample_rate(), kAlsaSampleFormat, buffer_us, packet_us);
+        params_.sample_rate(), kAlsaSampleFormatAI, buffer_us, packet_us);
   }
 
   if (device_handle_) {
diff --git a/media/audio/alsa/alsa_output.cc b/media/audio/alsa/alsa_output.cc
index 3eaef18ab6..ba6693559e 100644
--- a/media/audio/alsa/alsa_output.cc
+++ b/media/audio/alsa/alsa_output.cc
@@ -133,8 +133,8 @@ std::ostream& operator<<(std::ostream& os,
   return os;
 }
 
-static const SampleFormat kSampleFormat = kSampleFormatS16;
-static const snd_pcm_format_t kAlsaSampleFormat = SND_PCM_FORMAT_S16;
+static const SampleFormat kSampleFormatAO = kSampleFormatS16;
+static const snd_pcm_format_t kAlsaSampleFormatAO = SND_PCM_FORMAT_S16;
 
 const char AlsaPcmOutputStream::kDefaultDevice[] = "default";
 const char AlsaPcmOutputStream::kAutoSelectDevice[] = "";
@@ -149,13 +149,13 @@ AlsaPcmOutputStream::AlsaPcmOutputStream(const std::string& device_name,
                                          AlsaWrapper* wrapper,
                                          AudioManagerBase* manager)
     : requested_device_name_(device_name),
-      pcm_format_(kAlsaSampleFormat),
+      pcm_format_(kAlsaSampleFormatAO),
       channels_(params.channels()),
       channel_layout_(params.channel_layout()),
       sample_rate_(params.sample_rate()),
-      bytes_per_sample_(SampleFormatToBytesPerChannel(kSampleFormat)),
-      bytes_per_frame_(params.GetBytesPerFrame(kSampleFormat)),
-      packet_size_(params.GetBytesPerBuffer(kSampleFormat)),
+      bytes_per_sample_(SampleFormatToBytesPerChannel(kSampleFormatAO)),
+      bytes_per_frame_(params.GetBytesPerFrame(kSampleFormatAO)),
+      packet_size_(params.GetBytesPerBuffer(kSampleFormatAO)),
       latency_(std::max(
           base::Microseconds(kMinLatencyMicros),
           AudioTimestampHelper::FramesToTime(params.frames_per_buffer() * 2,
diff --git a/media/audio/alsa/audio_manager_alsa.cc b/media/audio/alsa/audio_manager_alsa.cc
index af69ccd4c8..f2f0222fef 100644
--- a/media/audio/alsa/audio_manager_alsa.cc
+++ b/media/audio/alsa/audio_manager_alsa.cc
@@ -29,7 +29,7 @@ namespace media {
 static const int kMaxOutputStreams = 50;
 
 // Default sample rate for input and output streams.
-static const int kDefaultSampleRate = 48000;
+static const int kDefaultSampleRateAMA = 48000;
 
 // Since "default", "pulse" and "dmix" devices are virtual devices mapped to
 // real devices, we remove them from the list to avoiding duplicate counting.
@@ -73,7 +73,7 @@ AudioParameters AudioManagerAlsa::GetInputStreamParameters(
   static const int kDefaultInputBufferSize = 1024;
 
   return AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
-                         ChannelLayoutConfig::Stereo(), kDefaultSampleRate,
+                         ChannelLayoutConfig::Stereo(), kDefaultSampleRateAMA,
                          kDefaultInputBufferSize);
 }
 
@@ -273,7 +273,7 @@ AudioParameters AudioManagerAlsa::GetPreferredOutputStreamParameters(
   DLOG_IF(ERROR, !output_device_id.empty()) << "Not implemented!";
   static const int kDefaultOutputBufferSize = 2048;
   ChannelLayoutConfig channel_layout_config = ChannelLayoutConfig::Stereo();
-  int sample_rate = kDefaultSampleRate;
+  int sample_rate = kDefaultSampleRateAMA;
   int buffer_size = kDefaultOutputBufferSize;
   if (input_params.IsValid()) {
     // Some clients, such as WebRTC, have a more limited use case and work
diff --git a/media/audio/pulse/audio_manager_pulse.cc b/media/audio/pulse/audio_manager_pulse.cc
index 743e374c56..3992b2c571 100644
--- a/media/audio/pulse/audio_manager_pulse.cc
+++ b/media/audio/pulse/audio_manager_pulse.cc
@@ -26,13 +26,13 @@ using pulse::AutoPulseLock;
 using pulse::WaitForOperationCompletion;
 
 // Maximum number of output streams that can be open simultaneously.
-constexpr int kMaxOutputStreams = 50;
+constexpr int kMaxOutputStreamsAMP = 50;
 
 constexpr int kMinimumOutputBufferSize = 512;
 constexpr int kMaximumOutputBufferSize = 8192;
-constexpr int kDefaultInputBufferSize = 1024;
-constexpr int kDefaultSampleRate = 48000;
-constexpr int kDefaultChannelCount = 2;
+constexpr int kDefaultInputBufferSizeAMP = 1024;
+constexpr int kDefaultSampleRateAMP = 48000;
+constexpr int kDefaultChannelCountAMP = 2;
 
 AudioManagerPulse::AudioManagerPulse(std::unique_ptr<AudioThread> audio_thread,
                                      AudioLogFactory* audio_log_factory,
@@ -42,12 +42,12 @@ AudioManagerPulse::AudioManagerPulse(std::unique_ptr<AudioThread> audio_thread,
       input_mainloop_(pa_mainloop),
       input_context_(pa_context),
       devices_(nullptr),
-      native_input_sample_rate_(kDefaultSampleRate),
-      native_channel_count_(kDefaultChannelCount),
+      native_input_sample_rate_(kDefaultSampleRateAMP),
+      native_channel_count_(kDefaultChannelCountAMP),
       default_source_is_monitor_(false) {
   DCHECK(input_mainloop_);
   DCHECK(input_context_);
-  SetMaxOutputStreamsAllowed(kMaxOutputStreams);
+  SetMaxOutputStreamsAllowed(kMaxOutputStreamsAMP);
 }
 
 AudioManagerPulse::~AudioManagerPulse() = default;
@@ -126,11 +126,11 @@ AudioParameters AudioManagerPulse::GetInputStreamParameters(
 
   const int user_buffer_size = GetUserBufferSize();
   const int buffer_size =
-      user_buffer_size ? user_buffer_size : kDefaultInputBufferSize;
+      user_buffer_size ? user_buffer_size : kDefaultInputBufferSizeAMP;
   return AudioParameters(AudioParameters::AUDIO_PCM_LOW_LATENCY,
                          ChannelLayoutConfig::Stereo(),
                          native_input_sample_rate_ ? native_input_sample_rate_
-                                                   : kDefaultSampleRate,
+                                                   : kDefaultSampleRateAMP,
                          buffer_size);
 }
 
@@ -221,7 +221,7 @@ AudioParameters AudioManagerPulse::GetPreferredOutputStreamParameters(
   // be respected though, so prefer the input parameters for channel count.
   UpdateNativeAudioHardwareInfo();
   int sample_rate = native_input_sample_rate_ ? native_input_sample_rate_
-                                              : kDefaultSampleRate;
+                                              : kDefaultSampleRateAMP;
   ChannelLayoutConfig channel_layout_config = ChannelLayoutConfig::Guess(
       native_channel_count_ ? native_channel_count_ : 2);
 
diff --git a/media/audio/win/audio_device_listener_win.cc b/media/audio/win/audio_device_listener_win.cc
index c83f212896..4f95ad467b 100644
--- a/media/audio/win/audio_device_listener_win.cc
+++ b/media/audio/win/audio_device_listener_win.cc
@@ -22,7 +22,7 @@ static std::string FlowToString(EDataFlow flow) {
   return flow == eRender ? "eRender" : "eCapture";
 }
 
-static std::string RoleToString(ERole role) {
+static std::string RoleToStringADLW(ERole role) {
   switch (role) {
     case eConsole:
       return "eConsole";
@@ -151,7 +151,7 @@ HRESULT AudioDeviceListenerWin::OnDefaultDeviceChanged(
                    ? CoreAudioUtil::GetFriendlyName(new_device_id, flow, role)
                    : "no device")
            << ", flow: " << FlowToString(flow)
-           << ", role: " << RoleToString(role)
+           << ", role: " << RoleToStringADLW(role)
            << ", notified manager: " << (did_run_listener_cb ? "Yes" : "No");
 
   return S_OK;
diff --git a/media/audio/win/audio_low_latency_output_win.cc b/media/audio/win/audio_low_latency_output_win.cc
index 1435a43834..e77696815e 100644
--- a/media/audio/win/audio_low_latency_output_win.cc
+++ b/media/audio/win/audio_low_latency_output_win.cc
@@ -54,7 +54,7 @@ void RecordAudioFailure(const char* histogram, HRESULT hr) {
 }
 
 // Converts a COM error into a human-readable string.
-std::string ErrorToString(HRESULT hresult) {
+std::string ErrorToStringALLOW(HRESULT hresult) {
   return CoreAudioUtil::ErrorToString(hresult);
 }
 
@@ -241,7 +241,7 @@ bool WASAPIAudioOutputStream::Open() {
     if (FAILED(hr)) {
       RecordAudioFailure(kOpenFailureHistogram, hr);
       SendLogMessage("%s => (ERROR: IAudioClient::SharedModeInitialize=[%s])",
-                     __func__, ErrorToString(hr).c_str());
+                     __func__, ErrorToStringALLOW(hr).c_str());
       return false;
     }
 
@@ -324,7 +324,7 @@ bool WASAPIAudioOutputStream::Open() {
   if (FAILED(hr)) {
     RecordAudioFailure(kOpenFailureHistogram, hr);
     SendLogMessage("%s => (ERROR: IAudioClient::GetService(IAudioClock)=[%s])",
-                   __func__, ErrorToString(hr).c_str());
+                   __func__, ErrorToStringALLOW(hr).c_str());
     return false;
   }
 
@@ -415,7 +415,7 @@ void WASAPIAudioOutputStream::Start(AudioSourceCallback* callback) {
   if (FAILED(hr)) {
     RecordAudioFailure(kStartFailureHistogram, hr);
     SendLogMessage("%s => (ERROR: IAudioClient::Start=[%s])", __func__,
-                   ErrorToString(hr).c_str());
+                   ErrorToStringALLOW(hr).c_str());
     StopThread();
     callback->OnError(AudioSourceCallback::ErrorType::kUnknown);
   }
@@ -435,7 +435,7 @@ void WASAPIAudioOutputStream::Stop() {
   if (FAILED(hr)) {
     RecordAudioFailure(kStopFailureHistogram, hr);
     SendLogMessage("%s => (ERROR: IAudioClient::Stop=[%s])", __func__,
-                   ErrorToString(hr).c_str());
+                   ErrorToStringALLOW(hr).c_str());
     source_->OnError(AudioSourceCallback::ErrorType::kUnknown);
   }
 
@@ -448,7 +448,7 @@ void WASAPIAudioOutputStream::Stop() {
   if (FAILED(hr)) {
     RecordAudioFailure(kStopFailureHistogram, hr);
     SendLogMessage("%s => (ERROR: IAudioClient::Reset=[%s])", __func__,
-                   ErrorToString(hr).c_str());
+                   ErrorToStringALLOW(hr).c_str());
     callback->OnError(AudioSourceCallback::ErrorType::kUnknown);
   }
 
@@ -552,7 +552,7 @@ void WASAPIAudioOutputStream::Run() {
     RecordAudioFailure(kRunFailureHistogram, hr);
     LOG(ERROR) << "WAOS::" << __func__
                << " => (ERROR: IAudioClock::GetFrequency=["
-               << ErrorToString(hr).c_str() << "])";
+               << ErrorToStringALLOW(hr).c_str() << "])";
   }
 
   // Keep rendering audio until the stop event or the stream-switch event
@@ -628,7 +628,7 @@ bool WASAPIAudioOutputStream::RenderAudioFromSource(UINT64 device_frequency) {
       RecordAudioFailure(kRenderFailureHistogram, hr);
       LOG(ERROR) << "WAOS::" << __func__
                  << " => (ERROR: IAudioClient::GetCurrentPadding=["
-                 << ErrorToString(hr).c_str() << "])";
+                 << ErrorToStringALLOW(hr).c_str() << "])";
       return false;
     }
     TRACE_COUNTER_ID1(TRACE_DISABLED_BY_DEFAULT("audio"),
@@ -651,13 +651,13 @@ bool WASAPIAudioOutputStream::RenderAudioFromSource(UINT64 device_frequency) {
     num_available_frames = endpoint_buffer_size_frames_;
   }
 
-  TRACE_EVENT(
-      TRACE_DISABLED_BY_DEFAULT("audio"), "IAudioClient frames",
-      [&](perfetto::EventContext ctx) {
-        auto* event = ctx.event<perfetto::protos::pbzero::ChromeTrackEvent>();
-        auto* data = event->set_win_render_audio_from_source();
-        data->set_iaudioclient_buffer_unfilled_frames(num_available_frames);
-      });
+//  TRACE_EVENT(
+//      TRACE_DISABLED_BY_DEFAULT("audio"), "IAudioClient frames",
+//      [&](perfetto::EventContext ctx) {
+//        auto* event = ctx.event<perfetto::protos::pbzero::ChromeTrackEvent>();
+//        auto* data = event->set_win_render_audio_from_source();
+//        data->set_iaudioclient_buffer_unfilled_frames(num_available_frames);
+//      });
 
   // Check if there is enough available space to fit the packet size
   // specified by the client.  If not, wait until a future callback.
@@ -695,7 +695,7 @@ bool WASAPIAudioOutputStream::RenderAudioFromSource(UINT64 device_frequency) {
       RecordAudioFailure(kRenderFailureHistogram, hr);
       LOG(ERROR) << "WAOS::" << __func__
                  << " => (ERROR: IAudioRenderClient::GetBuffer=["
-                 << ErrorToString(hr).c_str() << "])";
+                 << ErrorToStringALLOW(hr).c_str() << "])";
       return false;
     }
 
@@ -839,7 +839,7 @@ bool WASAPIAudioOutputStream::RenderAudioFromSource(UINT64 device_frequency) {
       RecordAudioFailure(kRenderFailureHistogram, hr);
       LOG(ERROR) << "WAOS::" << __func__
                  << " => (ERROR: IAudioClock::GetPosition=["
-                 << ErrorToString(hr).c_str() << "])";
+                 << ErrorToStringALLOW(hr).c_str() << "])";
       // Use a delay of zero.
       delay_timestamp = base::TimeTicks::Now();
     }
diff --git a/media/audio/win/core_audio_util_win.cc b/media/audio/win/core_audio_util_win.cc
index d4c94d3c06..21179478eb 100644
--- a/media/audio/win/core_audio_util_win.cc
+++ b/media/audio/win/core_audio_util_win.cc
@@ -42,10 +42,10 @@ const GUID kCommunicationsSessionId = {
 
 namespace {
 
-constexpr uint32_t KSAUDIO_SPEAKER_UNSUPPORTED = 0xFFFFFFFF;
+constexpr uint32_t KSAUDIO_SPEAKER_UNSUPPORTED_COUW = 0xFFFFFFFF;
 
 // TODO(henrika): add mapping for all types in the ChannelLayout enumerator.
-ChannelConfig ChannelLayoutToChannelConfig(ChannelLayout layout) {
+ChannelConfig ChannelLayoutToChannelConfigCOUW(ChannelLayout layout) {
   switch (layout) {
     case CHANNEL_LAYOUT_DISCRETE:
       DVLOG(2) << "CHANNEL_LAYOUT_DISCRETE=>KSAUDIO_SPEAKER_DIRECTOUT";
@@ -76,7 +76,7 @@ ChannelConfig ChannelLayoutToChannelConfig(ChannelLayout layout) {
       return KSAUDIO_SPEAKER_7POINT1_SURROUND;
     default:
       DVLOG(2) << "Unsupported channel layout: " << layout;
-      return KSAUDIO_SPEAKER_UNSUPPORTED;
+      return KSAUDIO_SPEAKER_UNSUPPORTED_COUW;
   }
 }
 
@@ -910,8 +910,8 @@ bool CoreAudioUtil::IsChannelLayoutSupported(const std::string& device_id,
   // but only if the wave format is extended (can contain a channel mask).
   WaveFormatWrapper format(&mix_format);
   if (format.IsExtensible()) {
-    ChannelConfig new_config = ChannelLayoutToChannelConfig(channel_layout);
-    if (new_config == KSAUDIO_SPEAKER_UNSUPPORTED) {
+    ChannelConfig new_config = ChannelLayoutToChannelConfigCOUW(channel_layout);
+    if (new_config == KSAUDIO_SPEAKER_UNSUPPORTED_COUW) {
       return false;
     }
     format.GetExtensible()->dwChannelMask = new_config;
diff --git a/media/base/BUILD.gn b/media/base/BUILD.gn
index b5e5cefea6..4b531c1ce2 100644
--- a/media/base/BUILD.gn
+++ b/media/base/BUILD.gn
@@ -438,6 +438,8 @@ jumbo_source_set("base") {
       "libaom_thread_wrapper.cc",
       "libaom_thread_wrapper.h",
     ]
+    jumbo_excluded_sources = [ "libaom_thread_wrapper.cc"]
+
     deps += [ "//third_party/libaom" ]
   }
 
diff --git a/media/filters/h265_to_annex_b_bitstream_converter.cc b/media/filters/h265_to_annex_b_bitstream_converter.cc
index 60af198f91..4bc2033a1e 100644
--- a/media/filters/h265_to_annex_b_bitstream_converter.cc
+++ b/media/filters/h265_to_annex_b_bitstream_converter.cc
@@ -14,12 +14,12 @@
 namespace media {
 namespace {
 
-static const uint8_t kStartCodePrefix[3] = {0, 0, 1};
-static const uint32_t kParamSetStartCodeSize = 1 + sizeof(kStartCodePrefix);
+static const uint8_t kStartCodePrefix2[3] = {0, 0, 1};
+static const uint32_t kParamSetStartCodeSize2 = 1 + sizeof(kStartCodePrefix2);
 
 // Helper function which determines whether NAL unit of given type marks
 // access unit boundary.
-static bool IsAccessUnitBoundaryNal(int nal_unit_type) {
+static bool IsAccessUnitBoundaryNal2(int nal_unit_type) {
   // Spec 7.4.2.4.4
   // Check if this packet marks access unit boundary by checking the
   // packet type.
@@ -64,7 +64,7 @@ uint32_t H265ToAnnexBBitstreamConverter::GetConfigSize(
 
   for (auto& nalu_array : hevc_config.arrays) {
     for (auto& nalu : nalu_array.units) {
-      config_size += kParamSetStartCodeSize + nalu.size();
+      config_size += kParamSetStartCodeSize2 + nalu.size();
     }
   }
   return config_size;
@@ -118,12 +118,12 @@ uint32_t H265ToAnnexBBitstreamConverter::CalculateNeededOutputBufferSize(
     // nal_unit_type.
     int nal_unit_type = (*input >> 1) & 0x3F;
     if (first_nal_in_this_access_unit ||
-        IsAccessUnitBoundaryNal(nal_unit_type)) {
+        IsAccessUnitBoundaryNal2(nal_unit_type)) {
       output_size += 1;  // Extra zero_byte for these nal units
       first_nal_in_this_access_unit = false;
     }
     // Start code prefix
-    output_size += sizeof(kStartCodePrefix);
+    output_size += sizeof(kStartCodePrefix2);
     // Actual NAL unit size
     output_size += nal_unit_length;
     input += nal_unit_length;
@@ -218,8 +218,8 @@ bool H265ToAnnexBBitstreamConverter::ConvertNalUnitStreamToByteStream(
     }
     uint32_t start_code_len;
     first_nal_unit_in_access_unit_
-        ? start_code_len = sizeof(kStartCodePrefix) + 1
-        : start_code_len = sizeof(kStartCodePrefix);
+        ? start_code_len = sizeof(kStartCodePrefix2) + 1
+        : start_code_len = sizeof(kStartCodePrefix2);
     if (static_cast<uint32_t>(outscan - output) + start_code_len +
             nal_unit_length >
         *output_size) {
@@ -229,7 +229,7 @@ bool H265ToAnnexBBitstreamConverter::ConvertNalUnitStreamToByteStream(
 
     // Check if this packet marks access unit boundary by checking the
     // packet type.
-    if (IsAccessUnitBoundaryNal(nal_unit_type)) {
+    if (IsAccessUnitBoundaryNal2(nal_unit_type)) {
       first_nal_unit_in_access_unit_ = true;
     }
 
@@ -243,8 +243,8 @@ bool H265ToAnnexBBitstreamConverter::ConvertNalUnitStreamToByteStream(
 
     // No need to write leading zero bits.
     // Write start-code prefix.
-    memcpy(outscan, kStartCodePrefix, sizeof(kStartCodePrefix));
-    outscan += sizeof(kStartCodePrefix);
+    memcpy(outscan, kStartCodePrefix2, sizeof(kStartCodePrefix2));
+    outscan += sizeof(kStartCodePrefix2);
     // Then write the actual NAL unit from the input buffer.
     memcpy(outscan, inscan, nal_unit_length);
     inscan += nal_unit_length;
@@ -270,8 +270,8 @@ bool H265ToAnnexBBitstreamConverter::WriteParamSet(
 
   // Verify space.
   uint32_t bytes_left = *out_size;
-  if (bytes_left < kParamSetStartCodeSize ||
-      bytes_left - kParamSetStartCodeSize < size) {
+  if (bytes_left < kParamSetStartCodeSize2 ||
+      bytes_left - kParamSetStartCodeSize2 < size) {
     return false;
   }
 
@@ -280,8 +280,8 @@ bool H265ToAnnexBBitstreamConverter::WriteParamSet(
 
   // Write the 4 byte Annex B start code.
   *buf++ = 0;  // zero byte
-  memcpy(buf, kStartCodePrefix, sizeof(kStartCodePrefix));
-  buf += sizeof(kStartCodePrefix);
+  memcpy(buf, kStartCodePrefix2, sizeof(kStartCodePrefix2));
+  buf += sizeof(kStartCodePrefix2);
 
   // Copy the data.
   memcpy(buf, &param_set[0], size);
diff --git a/media/filters/mac/audio_toolbox_audio_encoder.cc b/media/filters/mac/audio_toolbox_audio_encoder.cc
index 0cb7636f92..d6f7968b88 100644
--- a/media/filters/mac/audio_toolbox_audio_encoder.cc
+++ b/media/filters/mac/audio_toolbox_audio_encoder.cc
@@ -21,7 +21,7 @@ namespace media {
 
 namespace {
 
-struct InputData {
+struct InputData2 {
   raw_ptr<const AudioBus> bus = nullptr;
   bool flushing = false;
 };
@@ -29,12 +29,12 @@ struct InputData {
 constexpr int kAacFramesPerBuffer = 1024;
 
 // Callback used to provide input data to the AudioConverter.
-OSStatus ProvideInputCallback(AudioConverterRef decoder,
+OSStatus ProvideInputCallback2(AudioConverterRef decoder,
                               UInt32* num_packets,
                               AudioBufferList* buffer_list,
                               AudioStreamPacketDescription** packets,
                               void* user_data) {
-  auto* input_data = reinterpret_cast<InputData*>(user_data);
+  auto* input_data = reinterpret_cast<InputData2*>(user_data);
   if (input_data->flushing) {
     *num_packets = 0;
     return noErr;
@@ -318,7 +318,7 @@ void AudioToolboxAudioEncoder::DrainFifoOutput() {
 void AudioToolboxAudioEncoder::DoEncode(const AudioBus* input_bus) {
   bool is_flushing = !input_bus;
 
-  InputData input_data;
+  InputData2 input_data;
   input_data.bus = input_bus;
   input_data.flushing = is_flushing;
 
@@ -337,7 +337,7 @@ void AudioToolboxAudioEncoder::DoEncode(const AudioBus* input_bus) {
     UInt32 num_packets = 1;
     AudioStreamPacketDescription packet_description = {};
     auto result = AudioConverterFillComplexBuffer(
-        encoder_, ProvideInputCallback, &input_data, &num_packets,
+        encoder_, ProvideInputCallback2, &input_data, &num_packets,
         &output_buffer_list, &packet_description);
 
     // We expect "1 in, 1 out" when feeding packets into the encoder, except
diff --git a/media/filters/media_file_checker.cc b/media/filters/media_file_checker.cc
index dca328bc69..a2d4757587 100644
--- a/media/filters/media_file_checker.cc
+++ b/media/filters/media_file_checker.cc
@@ -29,7 +29,7 @@ void OnMediaFileCheckerError(bool* called) {
   *called = false;
 }
 
-struct Decoder {
+struct DecoderStruct {
   std::unique_ptr<AVCodecContext, ScopedPtrAVFreeContext> context;
   std::unique_ptr<FFmpegDecodingLoop> loop;
 };
@@ -59,7 +59,7 @@ bool MediaFileChecker::Start(base::TimeDelta check_time) {
 
   // Remember the codec context for any decodable audio or video streams.
   bool found_streams = false;
-  std::vector<Decoder> stream_contexts(format_context->nb_streams);
+  std::vector<DecoderStruct> stream_contexts(format_context->nb_streams);
   for (size_t i = 0; i < format_context->nb_streams; ++i) {
     AVCodecParameters* cp = format_context->streams[i]->codecpar;
 
diff --git a/media/mojo/services/gpu_mojo_media_client_cros.cc b/media/mojo/services/gpu_mojo_media_client_cros.cc
index 1b540be8c9..574dbd7603 100644
--- a/media/mojo/services/gpu_mojo_media_client_cros.cc
+++ b/media/mojo/services/gpu_mojo_media_client_cros.cc
@@ -9,6 +9,7 @@
 #include "chromeos/components/cdm_factory_daemon/chromeos_cdm_factory.h"
 #include "media/base/audio_decoder.h"
 #include "media/base/audio_encoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/media_switches.h"
 #include "media/gpu/chromeos/mailbox_video_frame_converter.h"
 #include "media/gpu/chromeos/platform_video_frame_pool.h"
diff --git a/media/mojo/services/gpu_mojo_media_client_linux.cc b/media/mojo/services/gpu_mojo_media_client_linux.cc
index e383fbeb24..6b50726398 100644
--- a/media/mojo/services/gpu_mojo_media_client_linux.cc
+++ b/media/mojo/services/gpu_mojo_media_client_linux.cc
@@ -8,6 +8,7 @@
 #include "base/task/sequenced_task_runner.h"
 #include "media/base/audio_decoder.h"
 #include "media/base/audio_encoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/media_log.h"
 #include "media/base/media_switches.h"
 #include "media/gpu/chromeos/mailbox_video_frame_converter.h"
@@ -220,7 +221,7 @@ std::unique_ptr<AudioEncoder> CreatePlatformAudioEncoder(
   return nullptr;
 }
 
-class CdmFactory {};
+// class CdmFactory {};
 
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
diff --git a/media/mojo/services/gpu_mojo_media_client_mac.cc b/media/mojo/services/gpu_mojo_media_client_mac.cc
index 18d0b20cfc..5aa105c893 100644
--- a/media/mojo/services/gpu_mojo_media_client_mac.cc
+++ b/media/mojo/services/gpu_mojo_media_client_mac.cc
@@ -8,6 +8,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "base/task/thread_pool.h"
 #include "media/base/audio_decoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/media_switches.h"
 #include "media/base/offloading_audio_encoder.h"
 #include "media/filters/mac/audio_toolbox_audio_decoder.h"
@@ -71,7 +72,7 @@ std::unique_ptr<AudioEncoder> CreatePlatformAudioEncoder(
 }
 
 // This class doesn't exist on mac, so we need a stub for unique_ptr.
-class CdmFactory {};
+//class CdmFactory {};
 
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
diff --git a/media/mojo/services/gpu_mojo_media_client_stubs.cc b/media/mojo/services/gpu_mojo_media_client_stubs.cc
index d829b6bc63..aec02643a8 100644
--- a/media/mojo/services/gpu_mojo_media_client_stubs.cc
+++ b/media/mojo/services/gpu_mojo_media_client_stubs.cc
@@ -6,6 +6,7 @@
 #include "base/task/single_thread_task_runner.h"
 #include "media/base/audio_decoder.h"
 #include "media/base/audio_encoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/media_log.h"
 #include "media/base/video_decoder.h"
 #include "media/mojo/services/gpu_mojo_media_client.h"
@@ -38,9 +39,6 @@ std::unique_ptr<AudioEncoder> CreatePlatformAudioEncoder(
   return nullptr;
 }
 
-// This class doesn't exist on any of the platforms that use the stubs.
-class CdmFactory {};
-
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
   return nullptr;
diff --git a/media/mojo/services/gpu_mojo_media_client_win.cc b/media/mojo/services/gpu_mojo_media_client_win.cc
index e50e62add8..ea7c9cb66a 100644
--- a/media/mojo/services/gpu_mojo_media_client_win.cc
+++ b/media/mojo/services/gpu_mojo_media_client_win.cc
@@ -11,6 +11,7 @@
 #include "gpu/ipc/service/gpu_channel.h"
 #include "gpu/ipc/service/gpu_channel_manager.h"
 #include "media/base/audio_decoder.h"
+#include "media/base/cdm_factory.h"
 #include "media/base/media_switches.h"
 #include "media/base/offloading_audio_encoder.h"
 #include "media/filters/win/media_foundation_audio_decoder.h"
@@ -106,7 +107,7 @@ VideoDecoderType GetPlatformDecoderImplementationType(
 }
 
 // There is no CdmFactory on windows, so just stub it out.
-class CdmFactory {};
+//class CdmFactory {};
 std::unique_ptr<CdmFactory> CreatePlatformCdmFactory(
     mojom::FrameInterfaceFactory* frame_interfaces) {
   return nullptr;
diff --git a/mojo/public/tools/bindings/mojom.gni b/mojo/public/tools/bindings/mojom.gni
index ff06adb348..fd58e51f25 100644
--- a/mojo/public/tools/bindings/mojom.gni
+++ b/mojo/public/tools/bindings/mojom.gni
@@ -1202,6 +1202,13 @@ template("mojom") {
   } else {
     enabled_configurations = [ default_variant ]
   }
+
+  if (defined(invoker.disable_jumbo) && invoker.disable_jumbo) {
+    disable_jumbo = true
+  } else {
+    disable_jumbo = false
+  }
+
   foreach(bindings_configuration, enabled_configurations) {
     cpp_only = false
     if (defined(invoker.cpp_only)) {
@@ -1564,6 +1571,10 @@ template("mojom") {
       sources_target_type = "source_set"
     }
 
+    if (!disable_jumbo) {
+      sources_target_type = "jumbo_" + sources_target_type
+    }
+
     output_target_name = "${target_name}${variant_suffix}"
     if (proxy_target != "") {
       group(output_target_name) {
@@ -1578,8 +1589,9 @@ template("mojom") {
       sources_target_name = output_target_name
     }
 
-    target("jumbo_" + sources_target_type, sources_target_name) {
+    target(sources_target_type, sources_target_name) {
       if (defined(output_name_override)) {
+
         output_name = output_name_override
       }
       visibility = output_visibility + [
@@ -1686,7 +1698,7 @@ template("mojom") {
 
       mojolpm_target_name = "${target_name}_mojolpm"
       mojolpm_generator_target_name = "${target_name}__generator"
-      source_set(mojolpm_target_name) {
+      jumbo_source_set(mojolpm_target_name) {
         # There are still a few missing header dependencies between mojo targets
         # with typemaps and the dependencies of their typemap headers. It would
         # be good to enable include checking for these in the future though.
diff --git a/services/network/public/cpp/BUILD.gn b/services/network/public/cpp/BUILD.gn
index 7fb4c40124..08bffc5d4e 100644
--- a/services/network/public/cpp/BUILD.gn
+++ b/services/network/public/cpp/BUILD.gn
@@ -442,6 +442,10 @@ jumbo_component("cpp_base") {
     "web_transport_error_mojom_traits.cc",
     "web_transport_error_mojom_traits.h",
   ]
+  jumbo_excluded_sources = [
+    "network_ipc_param_traits.cc",
+    "url_request_mojom_traits.cc"
+  ]
 
   configs += [ "//build/config/compiler:wexit_time_destructors" ]
 
@@ -481,6 +485,7 @@ jumbo_component("cpp_base") {
       "p2p_param_traits.h",
       "p2p_socket_type.h",
     ]
+    jumbo_excluded_sources += [ "p2p_param_traits.cc" ]
 
     public_deps += [ "//third_party/webrtc_overrides:webrtc_component" ]
   }
diff --git a/services/network/web_bundle/web_bundle_url_loader_factory.cc b/services/network/web_bundle/web_bundle_url_loader_factory.cc
index 70bdf18613..48bde4e182 100644
--- a/services/network/web_bundle/web_bundle_url_loader_factory.cc
+++ b/services/network/web_bundle/web_bundle_url_loader_factory.cc
@@ -35,7 +35,7 @@ namespace network {
 
 namespace {
 
-constexpr size_t kBlockedBodyAllocationSize = 1;
+constexpr size_t kBlockedBodyAllocationSize2 = 1;
 
 void DeleteProducerAndRunCallback(
     std::unique_ptr<mojo::DataPipeProducer> producer,
@@ -87,7 +87,7 @@ class WebBundleURLLoaderClient : public network::mojom::URLLoaderClient {
     options.struct_size = sizeof(MojoCreateDataPipeOptions);
     options.flags = MOJO_CREATE_DATA_PIPE_FLAG_NONE;
     options.element_num_bytes = 1;
-    options.capacity_num_bytes = kBlockedBodyAllocationSize;
+    options.capacity_num_bytes = kBlockedBodyAllocationSize2;
     mojo::ScopedDataPipeProducerHandle producer;
     mojo::ScopedDataPipeConsumerHandle consumer;
     MojoResult result = mojo::CreateDataPipe(&options, producer, consumer);
diff --git a/storage/browser/BUILD.gn b/storage/browser/BUILD.gn
index a4a350ed4f..088fb5cbe0 100644
--- a/storage/browser/BUILD.gn
+++ b/storage/browser/BUILD.gn
@@ -224,6 +224,10 @@ jumbo_component("browser") {
     "quota/usage_tracker.h",
   ]
 
+  jumbo_excluded_sources = [
+    "file_system/local_file_stream_reader.cc",
+  ]
+
   defines = [ "IS_STORAGE_BROWSER_IMPL" ]
   configs += [
     "//build/config:precompiled_headers",
diff --git a/storage/browser/blob/blob_url_registry.cc b/storage/browser/blob/blob_url_registry.cc
index 6b8fee3fbd..7cd518e3e0 100644
--- a/storage/browser/blob/blob_url_registry.cc
+++ b/storage/browser/blob/blob_url_registry.cc
@@ -16,7 +16,7 @@ namespace storage {
 
 namespace {
 
-BlobUrlRegistry::URLStoreCreationHook* g_url_store_creation_hook = nullptr;
+BlobUrlRegistry::URLStoreCreationHook* g_url_store_creation_hook2 = nullptr;
 
 }
 
@@ -36,8 +36,8 @@ void BlobUrlRegistry::AddReceiver(
       std::make_unique<storage::BlobURLStoreImpl>(storage_key, AsWeakPtr()),
       std::move(receiver));
 
-  if (g_url_store_creation_hook) {
-    g_url_store_creation_hook->Run(this, receiver_id);
+  if (g_url_store_creation_hook2) {
+    g_url_store_creation_hook2->Run(this, receiver_id);
   }
 }
 
@@ -183,7 +183,7 @@ void BlobUrlRegistry::SetURLStoreCreationHookForTesting(
     URLStoreCreationHook* hook) {
   DCHECK(
       base::FeatureList::IsEnabled(net::features::kSupportPartitionedBlobUrl));
-  g_url_store_creation_hook = hook;
+  g_url_store_creation_hook2 = hook;
 }
 
 }  // namespace storage
diff --git a/storage/browser/quota/quota_settings.cc b/storage/browser/quota/quota_settings.cc
index e53053151f..3042d96083 100644
--- a/storage/browser/quota/quota_settings.cc
+++ b/storage/browser/quota/quota_settings.cc
@@ -24,14 +24,14 @@ namespace storage {
 
 namespace {
 
-const int64_t kMBytes = 1024 * 1024;
+const int64_t _kMBytes = 1024 * 1024;
 const int kRandomizedPercentage = 10;
 const double kDefaultPerStorageKeyRatio = 0.75;
 const double kIncognitoQuotaRatioLowerBound = 0.15;
 const double kIncognitoQuotaRatioUpperBound = 0.2;
 
 // Skews |value| by +/- |percent|.
-int64_t RandomizeByPercent(int64_t value, int percent) {
+int64_t MyRandomizeByPercent(int64_t value, int percent) {
   double random_percent = (base::RandDouble() - 0.5) * percent * 2;
   return value + (value * (random_percent / 100.0));
 }
@@ -117,7 +117,7 @@ std::optional<QuotaSettings> CalculateNominalDynamicSettings(
   // SessionOnly (or ephemeral) origins are allotted a fraction of what
   // normal origins are provided, and the amount is capped to a hard limit.
   const double kSessionOnlyStorageKeyQuotaRatio = 0.1;  // 10%
-  const int64_t kMaxSessionOnlyStorageKeyQuota = 300 * kMBytes;
+  const int64_t kMaxSessionOnlyStorageKeyQuota = 300 * _kMBytes;
 
   QuotaSettings settings;
 
@@ -144,10 +144,9 @@ std::optional<QuotaSettings> CalculateNominalDynamicSettings(
                static_cast<int64_t>(total * kMustRemainAvailableRatio));
   settings.per_storage_key_quota = pool_size * kPerStorageKeyTemporaryRatio;
   settings.session_only_per_storage_key_quota = std::min(
-      RandomizeByPercent(kMaxSessionOnlyStorageKeyQuota, kRandomizedPercentage),
+      MyRandomizeByPercent(kMaxSessionOnlyStorageKeyQuota, kRandomizedPercentage),
       static_cast<int64_t>(settings.per_storage_key_quota *
                            kSessionOnlyStorageKeyQuotaRatio));
-  settings.refresh_interval = base::Seconds(60);
   return settings;
 }
 
diff --git a/third_party/blink/common/user_agent/user_agent_metadata.cc b/third_party/blink/common/user_agent/user_agent_metadata.cc
index d327adda3d..baf405fe99 100644
--- a/third_party/blink/common/user_agent/user_agent_metadata.cc
+++ b/third_party/blink/common/user_agent/user_agent_metadata.cc
@@ -14,7 +14,7 @@
 namespace blink {
 
 namespace {
-constexpr uint32_t kVersion = 3u;
+constexpr uint32_t kVersionUA = 3u;
 }  // namespace
 
 UserAgentBrandVersion::UserAgentBrandVersion(const std::string& ua_brand,
@@ -69,7 +69,7 @@ absl::optional<std::string> UserAgentMetadata::Marshal(
     return absl::nullopt;
   }
   base::Pickle out;
-  out.WriteUInt32(kVersion);
+  out.WriteUInt32(kVersionUA);
 
   out.WriteUInt32(base::checked_cast<uint32_t>(in->brand_version_list.size()));
   for (const auto& brand_version : in->brand_version_list) {
@@ -111,7 +111,7 @@ absl::optional<UserAgentMetadata> UserAgentMetadata::Demarshal(
 
   uint32_t version;
   UserAgentMetadata out;
-  if (!in.ReadUInt32(&version) || version != kVersion)
+  if (!in.ReadUInt32(&version) || version != kVersionUA)
     return absl::nullopt;
 
   uint32_t brand_version_size;
diff --git a/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py b/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py
index 6703feeb0c..7478af1ef4 100644
--- a/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py
+++ b/third_party/blink/renderer/bindings/scripts/bind_gen/callback_interface.py
@@ -185,6 +185,7 @@ def generate_callback_interface(callback_interface_identifier):
          cg_context,
          FN_INSTALL_INTERFACE_TEMPLATE,
          class_name=class_name,
+         api_class_name=class_name,
          trampoline_var_name=None,
          constructor_entries=[],
          supplemental_install_node=SequenceNode(),
diff --git a/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py b/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
index cc5687a3b6..19c1d5b468 100644
--- a/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
+++ b/third_party/blink/renderer/bindings/scripts/bind_gen/interface.py
@@ -5247,7 +5247,7 @@ ${prototype_object}->Delete(
     return SequenceNode(nodes) if nodes else None
 
 
-def make_install_interface_template(cg_context, function_name, class_name,
+def make_install_interface_template(cg_context, function_name, class_name, api_class_name,
                                     trampoline_var_name, constructor_entries,
                                     supplemental_install_node,
                                     install_unconditional_func_name,
@@ -5380,7 +5380,7 @@ def make_install_interface_template(cg_context, function_name, class_name,
     for entry in constructor_entries:
         nodes = [
             FormatNode("${interface_function_template}->SetCallHandler({});",
-                       entry.ctor_callback_name),
+                       api_class_name + "Callbacks::" + entry.ctor_callback_name),
             FormatNode("${interface_function_template}->SetLength({});",
                        entry.ctor_func_length),
         ]
@@ -5428,7 +5428,7 @@ def make_install_interface_template(cg_context, function_name, class_name,
             T("""\
 // HTMLAllCollection-specific settings
 // https://html.spec.whatwg.org/C/#the-htmlallcollection-interface
-${instance_object_template}->SetCallAsFunctionHandler(ItemOperationCallback);
+${instance_object_template}->SetCallAsFunctionHandler(${class_name}Callbacks::ItemOperationCallback);
 ${instance_object_template}->MarkAsUndetectable();
 """))
 
@@ -5715,6 +5715,7 @@ ${instance_object} = ${v8_context}->Global()->GetPrototype().As<v8::Object>();\
         if unconditional_entries:
             body.append(
                 CxxBlockNode([
+                    TextNode("using namespace ${class_name}Callbacks;"),
                     make_table_func(table_name, unconditional_entries),
                     TextNode(installer_call_text),
                 ]))
@@ -5724,6 +5725,7 @@ ${instance_object} = ${v8_context}->Global()->GetPrototype().As<v8::Object>();\
                 CxxUnlikelyIfNode(
                     cond=conditional,
                     body=[
+                        TextNode("using namespace ${class_name}Callbacks;"),
                         make_table_func(table_name, entries),
                         TextNode(installer_call_text),
                     ]))
@@ -5901,6 +5903,8 @@ def make_indexed_and_named_property_callbacks_and_install_node(cg_context):
                 map(lambda flag: "int32_t({})".format(flag), flags))))
         pattern = """\
 // Named interceptors
+{{
+using namespace ${class_name}Callbacks;
 {interceptor_template}->SetHandler(
     v8::NamedPropertyHandlerConfiguration(
         {impl_bridge}::NamedPropertyGetterCallback,
@@ -5921,7 +5925,9 @@ interface.indexed_and_named_properties.named_getter.extended_attributes:
         {impl_bridge}::NamedPropertyDefinerCallback,
         {impl_bridge}::NamedPropertyDescriptorCallback,
         v8::Local<v8::Value>(),
-        {property_handler_flags}));"""
+        {property_handler_flags}));
+}}
+"""
         install_node.append(
             F(pattern,
               interceptor_template=interceptor_template,
@@ -5968,6 +5974,8 @@ interface.indexed_and_named_properties.named_getter.extended_attributes:
         property_handler_flags = flags[0]
         pattern = """\
 // Indexed interceptors
+{{
+using namespace ${class_name}Callbacks;
 {interceptor_template}->SetHandler(
     v8::IndexedPropertyHandlerConfiguration(
         {impl_bridge}::IndexedPropertyGetterCallback,
@@ -5982,7 +5990,8 @@ interface.indexed_and_named_properties.named_getter.extended_attributes:
         {impl_bridge}::IndexedPropertyDefinerCallback,
         {impl_bridge}::IndexedPropertyDescriptorCallback,
         v8::Local<v8::Value>(),
-        {property_handler_flags}));"""
+        {property_handler_flags}));
+}}"""
         install_node.append(
             F(pattern,
               interceptor_template=interceptor_template,
@@ -6138,6 +6147,8 @@ def make_cross_origin_property_callbacks_and_install_node(
 
     text = """\
 // Cross origin properties
+{{
+using namespace ${class_name}Callbacks;
 ${instance_object_template}->SetAccessCheckCallbackAndHandler(
     CrossOriginAccessCheckCallback,
     v8::NamedPropertyHandlerConfiguration(
@@ -6163,6 +6174,7 @@ ${instance_object_template}->SetAccessCheckCallbackAndHandler(
     v8::External::New(
         ${isolate},
         const_cast<WrapperTypeInfo*>(${class_name}::GetWrapperTypeInfo())));
+}}
 """
     install_node.append(TextNode(text))
     install_node.accumulate(
@@ -6337,6 +6349,7 @@ def make_wrapper_type_info(cg_context, function_name,
         ]))
 
     pattern = """\
+namespace ${class_name}Callbacks {{ }}
 // Construction of WrapperTypeInfo may require non-trivial initialization due
 // to cross-component address resolution in order to load the pointer to the
 // parent interface's WrapperTypeInfo.  We ignore this issue because the issue
@@ -6544,6 +6557,7 @@ def _make_v8_context_snapshot_get_reference_table_function(
                                                                            )),
             filter(None, callback_names)))
     table_node = ListNode([
+        TextNode("using namespace ${class_name}Callbacks;"),
         TextNode("static const intptr_t kReferenceTable[] = {"),
         ListNode(entry_nodes),
         TextNode("};"),
@@ -6919,6 +6933,7 @@ def generate_class_like(class_like,
          cg_context,
          FN_INSTALL_INTERFACE_TEMPLATE,
          class_name=impl_class_name,
+         api_class_name=api_class_name,
          trampoline_var_name=tp_install_interface_template,
          constructor_entries=constructor_entries,
          supplemental_install_node=supplemental_install_node,
@@ -7166,7 +7181,7 @@ def generate_class_like(class_like,
                                                     class_like.identifier)
     impl_source_blink_ns.body.extend([
         CxxNamespaceNode(
-            name="",
+            name=api_class_name + "Callbacks",
             body=[
                 # Enclose the implementations with a namespace just in order to
                 # include the class_like name in a stacktrace, such as
diff --git a/third_party/blink/renderer/core/BUILD.gn b/third_party/blink/renderer/core/BUILD.gn
index 3fc03437c0..c1f26ba885 100644
--- a/third_party/blink/renderer/core/BUILD.gn
+++ b/third_party/blink/renderer/core/BUILD.gn
@@ -6,6 +6,7 @@ import("//build/config/cast.gni")
 import("//build/config/compiler/compiler.gni")
 import("//build/config/dcheck_always_on.gni")
 import("//build/config/python.gni")
+import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//build/nocompile.gni")
 import("//build/toolchain/toolchain.gni")
@@ -153,7 +154,7 @@ source_set("core_common") {
   sources = [ "core_export.h" ]
 }
 
-source_set("prerequisites") {
+jumbo_source_set("prerequisites") {
   public_deps = [
     "//services/network/public/cpp:cpp",
     "//services/network/public/mojom",
@@ -213,7 +214,7 @@ blink_python_runner("make_deprecation_info") {
   ]
 }
 
-component("core") {
+jumbo_component("core") {
   output_name = "blink_core"
 
   visibility = []  # Allow re-assignment of list.
@@ -397,6 +398,13 @@ component("core") {
     "//third_party/blink/renderer/core/url_pattern",
     "//third_party/blink/renderer/core/xml:xpath_generated",
   ]
+  jumbo_excluded_sources = [ ]
+  jumbo_excluded_sources += rebase_path([ "attribution_reporting_to_mojom.cc" ], "", "fetch")
+  jumbo_excluded_sources += rebase_path([ "frame_fetch_context.cc" ], "", "loader")
+  jumbo_excluded_sources += rebase_path([ "image_loader.cc" ], "", "loader")
+  jumbo_excluded_sources += rebase_path([ "create_window.cc" ], "", "page")
+  jumbo_excluded_sources += rebase_path([ "link_highlight_impl.cc" ], "", "paint")
+  jumbo_excluded_sources += rebase_path([ "scroll_animator.cc" ], "", "scroll")
 
   public_configs = [ ":core_include_dirs" ]
 
diff --git a/third_party/blink/renderer/core/animation/BUILD.gn b/third_party/blink/renderer/core/animation/BUILD.gn
index 50c635aff2..1f00596f83 100644
--- a/third_party/blink/renderer/core/animation/BUILD.gn
+++ b/third_party/blink/renderer/core/animation/BUILD.gn
@@ -331,6 +331,9 @@ blink_core_sources("animation") {
     "worklet_animation_controller.cc",
     "worklet_animation_controller.h",
   ]
+  jumbo_excluded_sources = [
+    "css_transform_interpolation_type.cc",
+  ]
 
   deps = [
     ":buildflags",
diff --git a/third_party/blink/renderer/core/animation/compositor_animations.cc b/third_party/blink/renderer/core/animation/compositor_animations.cc
index 794a31810f..e627aaeffa 100644
--- a/third_party/blink/renderer/core/animation/compositor_animations.cc
+++ b/third_party/blink/renderer/core/animation/compositor_animations.cc
@@ -789,7 +789,7 @@ bool CompositorAnimations::ConvertTimingForCompositor(
   // after finishing until it is removed by a subsequent main thread commit.
   // This allows developers to apply a post animation style or start a
   // subsequent animation without flicker.
-  if ((base::FeatureList::IsEnabled(features::kNoPreserveLastMutation) &&
+  if ((base::FeatureList::IsEnabled(::features::kNoPreserveLastMutation) &&
        is_monotonic_timeline) ||
       is_boundary_aligned) {
     if (animation_playback_rate >= 0) {
diff --git a/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc b/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc
index b1ddb85a77..caaa5f4b86 100644
--- a/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc
+++ b/third_party/blink/renderer/core/animation/css_shadow_list_interpolation_type.cc
@@ -207,7 +207,7 @@ CSSShadowListInterpolationType::PreInterpolationCompositeIfNeeded(
   // to disable that caching in this case.
   // TODO(crbug.com/1009230): Remove this once our interpolation code isn't
   // caching composited values.
-  conversion_checkers.push_back(std::make_unique<AlwaysInvalidateChecker>());
+  conversion_checkers.push_back(std::make_unique<blink::AlwaysInvalidateChecker>());
   auto* interpolable_list =
       To<InterpolableList>(value.interpolable_value.Release());
   if (composite == EffectModel::CompositeOperation::kCompositeAdd) {
diff --git a/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc b/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc
index 8554ef0667..50ad55bc81 100644
--- a/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc
+++ b/third_party/blink/renderer/core/css/box_shadow_paint_image_generator.cc
@@ -11,22 +11,22 @@ namespace blink {
 namespace {
 
 BoxShadowPaintImageGenerator::BoxShadowPaintImageGeneratorCreateFunction*
-    g_create_function = nullptr;
+    g_create_function_bspig = nullptr;
 
 }  // namespace
 
 // static
 void BoxShadowPaintImageGenerator::Init(
     BoxShadowPaintImageGeneratorCreateFunction* create_function) {
-  DCHECK(!g_create_function);
-  g_create_function = create_function;
+  DCHECK(!g_create_function_bspig);
+  g_create_function_bspig = create_function;
 }
 
 BoxShadowPaintImageGenerator* BoxShadowPaintImageGenerator::Create(
     LocalFrame& local_root) {
-  DCHECK(g_create_function);
+  DCHECK(g_create_function_bspig);
   DCHECK(local_root.IsLocalRoot());
-  return g_create_function(local_root);
+  return g_create_function_bspig(local_root);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc b/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc
index 84cae256f6..f365766ddd 100644
--- a/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc
+++ b/third_party/blink/renderer/core/css/clip_path_paint_image_generator.cc
@@ -11,22 +11,22 @@ namespace blink {
 namespace {
 
 ClipPathPaintImageGenerator::ClipPathPaintImageGeneratorCreateFunction*
-    g_create_function = nullptr;
+    g_create_function2 = nullptr;
 
 }  // namespace
 
 // static
 void ClipPathPaintImageGenerator::Init(
     ClipPathPaintImageGeneratorCreateFunction* create_function) {
-  DCHECK(!g_create_function);
-  g_create_function = create_function;
+  DCHECK(!g_create_function2);
+  g_create_function2 = create_function;
 }
 
 ClipPathPaintImageGenerator* ClipPathPaintImageGenerator::Create(
     LocalFrame& local_root) {
-  DCHECK(g_create_function);
+  DCHECK(g_create_function2);
   DCHECK(local_root.IsLocalRoot());
-  return g_create_function(local_root);
+  return g_create_function2(local_root);
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/css/resolver/style_builder_converter.cc b/third_party/blink/renderer/core/css/resolver/style_builder_converter.cc
index 52a729a6a0..321da3248e 100644
--- a/third_party/blink/renderer/core/css/resolver/style_builder_converter.cc
+++ b/third_party/blink/renderer/core/css/resolver/style_builder_converter.cc
@@ -94,8 +94,8 @@
 
 namespace blink {
 
-const double kFinalStatePercentage = 100.0;
-const double kMiddleStatePercentage = 50.0;
+const double kFinalStatePercentage2 = 100.0;
+const double kMiddleStatePercentage2 = 50.0;
 
 namespace {
 
@@ -584,18 +584,18 @@ scoped_refptr<FontPalette> StyleBuilderConverterBase::ConvertPaletteMix(
     if (cssvalue::CSSColorMixValue::NormalizePercentages(
             palette_mix_value->Percentage1(), palette_mix_value->Percentage2(),
             normalized_percentage, alpha_multiplier)) {
-      double percentage1 = kMiddleStatePercentage;
-      double percentage2 = kMiddleStatePercentage;
+      double percentage1 = kMiddleStatePercentage2;
+      double percentage2 = kMiddleStatePercentage2;
       if (palette_mix_value->Percentage1() &&
           palette_mix_value->Percentage2()) {
         percentage1 = palette_mix_value->Percentage1()->GetDoubleValue();
         percentage2 = palette_mix_value->Percentage2()->GetDoubleValue();
       } else if (palette_mix_value->Percentage1()) {
         percentage1 = palette_mix_value->Percentage1()->GetDoubleValue();
-        percentage2 = kFinalStatePercentage - percentage1;
+        percentage2 = kFinalStatePercentage2 - percentage1;
       } else if (palette_mix_value->Percentage2()) {
         percentage2 = palette_mix_value->Percentage2()->GetDoubleValue();
-        percentage1 = kFinalStatePercentage - percentage2;
+        percentage1 = kFinalStatePercentage2 - percentage2;
       }
       return FontPalette::Mix(palette1, palette2, percentage1, percentage2,
                               normalized_percentage, alpha_multiplier,
diff --git a/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc b/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc
index b7c195a1ff..363b096af1 100644
--- a/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc
+++ b/third_party/blink/renderer/core/frame/local_frame_mojo_handler.cc
@@ -95,7 +95,7 @@ size_t GetCurrentCursorPositionInFrame(LocalFrame* local_frame) {
 }
 #endif
 
-RemoteFrame* SourceFrameForOptionalToken(
+RemoteFrame* SourceFrameForOptionalToken2(
     const absl::optional<RemoteFrameToken>& source_frame_token) {
   if (!source_frame_token)
     return nullptr;
@@ -729,7 +729,7 @@ void LocalFrameMojoHandler::AdvanceFocusInFrame(
     mojom::blink::FocusType focus_type,
     const absl::optional<RemoteFrameToken>& source_frame_token) {
   RemoteFrame* source_frame =
-      source_frame_token ? SourceFrameForOptionalToken(*source_frame_token)
+      source_frame_token ? SourceFrameForOptionalToken2(*source_frame_token)
                          : nullptr;
   if (!source_frame) {
     SetInitialFocus(focus_type == mojom::blink::FocusType::kBackward);
diff --git a/third_party/blink/renderer/core/frame/sticky_ad_detector.cc b/third_party/blink/renderer/core/frame/sticky_ad_detector.cc
index 8fd250065c..2e96e6a773 100644
--- a/third_party/blink/renderer/core/frame/sticky_ad_detector.cc
+++ b/third_party/blink/renderer/core/frame/sticky_ad_detector.cc
@@ -22,8 +22,8 @@ namespace blink {
 
 namespace {
 
-constexpr base::TimeDelta kFireInterval = base::Seconds(1);
-constexpr double kLargeAdSizeToViewportSizeThreshold = 0.3;
+constexpr base::TimeDelta kFireInterval2 = base::Seconds(1);
+constexpr double kLargeAdSizeToViewportSizeThreshold2 = 0.3;
 
 // An sticky element should have a non-default position w.r.t. the viewport. The
 // main page should also be scrollable.
@@ -71,7 +71,7 @@ void StickyAdDetector::MaybeFireDetection(LocalFrame* outermost_main_frame) {
   if (last_detection_time_.has_value() &&
       base::FeatureList::IsEnabled(
           features::kFrequencyCappingForLargeStickyAdDetection) &&
-      current_time < last_detection_time_.value() + kFireInterval) {
+      current_time < last_detection_time_.value() + kFireInterval2) {
     return;
   }
 
@@ -127,7 +127,7 @@ void StickyAdDetector::MaybeFireDetection(LocalFrame* outermost_main_frame) {
 
   bool is_large =
       (overlay_rect.size().Area64() > outermost_main_frame_size.Area64() *
-                                          kLargeAdSizeToViewportSizeThreshold);
+                                          kLargeAdSizeToViewportSizeThreshold2);
 
   bool is_main_page_scrollable =
       element->GetDocument().GetLayoutView()->HasScrollableOverflowY();
diff --git a/third_party/blink/renderer/core/html/forms/html_input_element.cc b/third_party/blink/renderer/core/html/forms/html_input_element.cc
index 59b54b4c45..8dc3cb42d4 100644
--- a/third_party/blink/renderer/core/html/forms/html_input_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_input_element.cc
@@ -110,7 +110,7 @@ const unsigned kMaxEmailFieldLength = 254;
 
 const unsigned kMinStrongPasswordLabelWidth = 220;
 
-static bool is_default_font_prewarmed_ = false;
+static bool is_default_font_prewarmed_hie = false;
 
 }  // namespace
 
@@ -413,10 +413,10 @@ void HTMLInputElement::InitializeTypeInParsing() {
   // Prewarm the default font family. Do this while parsing because the style
   // recalc calls |TextControlInnerEditorElement::CreateInnerEditorStyle| which
   // needs the primary font.
-  if (!is_default_font_prewarmed_ && new_type_name == input_type_names::kText) {
+  if (!is_default_font_prewarmed_hie && new_type_name == input_type_names::kText) {
     FontCache::PrewarmFamily(LayoutThemeFontProvider::SystemFontFamily(
         CSSValueID::kWebkitSmallControl));
-    is_default_font_prewarmed_ = true;
+    is_default_font_prewarmed_hie = true;
   }
 }
 
diff --git a/third_party/blink/renderer/core/html/forms/html_text_area_element.cc b/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
index eaa960ad7e..426fded75a 100644
--- a/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_text_area_element.cc
@@ -70,7 +70,7 @@ using mojom::blink::FormControlType;
 static const unsigned kDefaultRows = 2;
 static const unsigned kDefaultCols = 20;
 
-static bool is_default_font_prewarmed_ = false;
+static bool is_default_font_prewarmed_htae = false;
 
 static inline unsigned ComputeLengthForAPIValue(const String& text) {
   unsigned length = text.length();
@@ -96,14 +96,14 @@ HTMLTextAreaElement::HTMLTextAreaElement(Document& document)
       is_placeholder_visible_(false) {
   EnsureUserAgentShadowRoot();
 
-  if (!is_default_font_prewarmed_) {
+  if (!is_default_font_prewarmed_htae) {
     if (Settings* settings = document.GetSettings()) {
       // Prewarm 'monospace', the default font family for `<textarea>`. The
       // default language should be fine for this purpose because most users set
       // the same family for all languages.
       FontCache::PrewarmFamily(settings->GetGenericFontFamilySettings().Fixed(
           LayoutLocale::GetDefault().GetScript()));
-      is_default_font_prewarmed_ = true;
+      is_default_font_prewarmed_htae = true;
     }
   }
 }
diff --git a/third_party/blink/renderer/core/html/parser/html_tree_builder.cc b/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
index bc78469169..c770f9e098 100644
--- a/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
+++ b/third_party/blink/renderer/core/html/parser/html_tree_builder.cc
@@ -78,7 +78,7 @@ static TextPosition UninitializedPositionValue1() {
                       OrdinalNumber::First());
 }
 
-static inline bool IsAllWhitespace(const StringView& string_view) {
+static inline bool IsAllWhitespaceHTB(const StringView& string_view) {
   return string_view.IsAllSpecialCharacters<IsHTMLSpace<UChar>>();
 }
 
@@ -2857,7 +2857,7 @@ void HTMLTreeBuilder::DefaultForAfterHead() {
 void HTMLTreeBuilder::DefaultForInTableText() {
   String characters = pending_table_characters_.ToString();
   pending_table_characters_.Clear();
-  if (!IsAllWhitespace(characters)) {
+  if (!IsAllWhitespaceHTB(characters)) {
     // FIXME: parse error
     HTMLConstructionSite::RedirectToFosterParentGuard redirecter(tree_);
     tree_.ReconstructTheActiveFormattingElements();
diff --git a/third_party/blink/renderer/core/html/track/cue_timeline.cc b/third_party/blink/renderer/core/html/track/cue_timeline.cc
index a0acee2829..ccad139a8e 100644
--- a/third_party/blink/renderer/core/html/track/cue_timeline.cc
+++ b/third_party/blink/renderer/core/html/track/cue_timeline.cc
@@ -358,7 +358,7 @@ void CueTimeline::TimeMarchesOn() {
           is_enter_event ? event_type_names::kEnter : event_type_names::kExit;
       media_element.ScheduleEvent(
           CreateEventWithTarget(event_name, task.second.Get()));
-      if (features::IsTextBasedAudioDescriptionEnabled()) {
+      if (::features::IsTextBasedAudioDescriptionEnabled()) {
         if (is_enter_event) {
           cue->OnEnter(MediaElement());
         } else {
diff --git a/third_party/blink/renderer/core/html/track/text_track.cc b/third_party/blink/renderer/core/html/track/text_track.cc
index 2601457209..431814481c 100644
--- a/third_party/blink/renderer/core/html/track/text_track.cc
+++ b/third_party/blink/renderer/core/html/track/text_track.cc
@@ -321,7 +321,7 @@ void TextTrack::InvalidateTrackIndex() {
 }
 
 bool TextTrack::IsRendered() const {
-  if (features::IsTextBasedAudioDescriptionEnabled()) {
+  if (::features::IsTextBasedAudioDescriptionEnabled()) {
     return mode_ == TextTrackMode::kShowing &&
            (IsVisualKind() || IsSpokenKind());
   }
@@ -331,7 +331,7 @@ bool TextTrack::IsRendered() const {
 bool TextTrack::CanBeRendered() const {
   // A track can be displayed when it's of kind captions, subtitles, or
   // descriptions and hasn't failed to load.
-  if (features::IsTextBasedAudioDescriptionEnabled()) {
+  if (::features::IsTextBasedAudioDescriptionEnabled()) {
     return GetReadinessState() != kFailedToLoad &&
            (IsVisualKind() || IsSpokenKind());
   }
diff --git a/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc b/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc
index b20b575ac9..b1da14f995 100644
--- a/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc
+++ b/third_party/blink/renderer/core/imagebitmap/image_bitmap_source.cc
@@ -14,7 +14,7 @@
 
 namespace blink {
 
-constexpr const char* kImageBitmapOptionNone = "none";
+constexpr const char* kImageBitmapOptionNone2 = "none";
 
 ScriptPromise ImageBitmapSource::FulfillImageBitmap(
     ScriptState* script_state,
@@ -31,7 +31,7 @@ ScriptPromise ImageBitmapSource::FulfillImageBitmap(
   // imageOrientation: 'from-image' will be used to replace imageOrientation:
   // 'none'. Adding a deprecation warning when 'none' is called in
   // createImageBitmap.
-  if (options->imageOrientation() == kImageBitmapOptionNone) {
+  if (options->imageOrientation() == kImageBitmapOptionNone2) {
     auto* execution_context =
         ExecutionContext::From(script_state->GetContext());
     Deprecation::CountDeprecation(
diff --git a/third_party/blink/renderer/core/layout/baseline_utils.h b/third_party/blink/renderer/core/layout/baseline_utils.h
index 6ce0886f79..5750abba19 100644
--- a/third_party/blink/renderer/core/layout/baseline_utils.h
+++ b/third_party/blink/renderer/core/layout/baseline_utils.h
@@ -9,7 +9,7 @@
 
 namespace blink {
 
-enum class BaselineGroup { kMajor, kMinor };
+enum class BaselineGroupType { kMajor, kMinor };
 
 // Determines the writing-mode to read a baseline from a fragment.
 inline WritingMode DetermineBaselineWritingMode(
@@ -48,7 +48,7 @@ inline WritingMode DetermineBaselineWritingMode(
 //
 // We label these "major"/"minor" to separate them. The "major" group should be
 // aligned to the appropriate "start" axis.
-inline BaselineGroup DetermineBaselineGroup(
+inline BaselineGroupType DetermineBaselineGroup(
     const WritingDirectionMode container_writing_direction,
     const WritingMode baseline_writing_mode,
     bool is_parallel_context,
@@ -57,8 +57,8 @@ inline BaselineGroup DetermineBaselineGroup(
   const auto container_writing_mode =
       container_writing_direction.GetWritingMode();
 
-  auto start_group = BaselineGroup::kMajor;
-  auto end_group = BaselineGroup::kMinor;
+  auto start_group = BaselineGroupType::kMajor;
+  auto end_group = BaselineGroupType::kMinor;
   if (is_last_baseline)
     std::swap(start_group, end_group);
   if (is_flipped)
@@ -86,7 +86,7 @@ inline BaselineGroup DetermineBaselineGroup(
   }
 
   NOTREACHED();
-  return BaselineGroup::kMinor;
+  return BaselineGroupType::kMinor;
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/layout/flex/flex_layout_algorithm.cc b/third_party/blink/renderer/core/layout/flex/flex_layout_algorithm.cc
index d4d62e10f5..9ec9c6be0d 100644
--- a/third_party/blink/renderer/core/layout/flex/flex_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/flex/flex_layout_algorithm.cc
@@ -44,11 +44,11 @@ namespace blink {
 
 namespace {
 
-class BaselineAccumulator {
+class BaselineAccumulatorFlex {
   STACK_ALLOCATED();
 
  public:
-  explicit BaselineAccumulator(const ComputedStyle& style)
+  explicit BaselineAccumulatorFlex(const ComputedStyle& style)
       : font_baseline_(style.GetFontBaseline()) {}
 
   void AccumulateItem(const LogicalBoxFragment& fragment,
@@ -185,10 +185,10 @@ LayoutUnit FlexLayoutAlgorithm::MainAxisContentExtent(
 
 namespace {
 
-enum AxisEdge { kStart, kCenter, kEnd };
+enum class LocalAxisEdge { kStart, kCenter, kEnd };
 
 // Maps the resolved justify-content value to a static-position edge.
-AxisEdge MainAxisStaticPositionEdge(const ComputedStyle& style,
+LocalAxisEdge MainAxisStaticPositionEdge(const ComputedStyle& style,
                                     bool is_column) {
   const StyleContentAlignmentData justify =
       FlexibleBoxAlgorithm::ResolvedJustifyContent(style);
@@ -200,23 +200,23 @@ AxisEdge MainAxisStaticPositionEdge(const ComputedStyle& style,
   DCHECK_NE(content_position, ContentPosition::kLeft);
   DCHECK_NE(content_position, ContentPosition::kRight);
   if (content_position == ContentPosition::kFlexEnd)
-    return is_reverse_flex ? AxisEdge::kStart : AxisEdge::kEnd;
+    return is_reverse_flex ? LocalAxisEdge::kStart : LocalAxisEdge::kEnd;
 
   if (content_position == ContentPosition::kCenter ||
       justify.Distribution() == ContentDistributionType::kSpaceAround ||
       justify.Distribution() == ContentDistributionType::kSpaceEvenly)
-    return AxisEdge::kCenter;
+    return LocalAxisEdge::kCenter;
 
   if (content_position == ContentPosition::kStart)
-    return AxisEdge::kStart;
+    return LocalAxisEdge::kStart;
   if (content_position == ContentPosition::kEnd)
-    return AxisEdge::kEnd;
+    return LocalAxisEdge::kEnd;
 
-  return is_reverse_flex ? AxisEdge::kEnd : AxisEdge::kStart;
+  return is_reverse_flex ? LocalAxisEdge::kEnd : LocalAxisEdge::kStart;
 }
 
 // Maps the resolved alignment value to a static-position edge.
-AxisEdge CrossAxisStaticPositionEdge(const ComputedStyle& style,
+LocalAxisEdge CrossAxisStaticPositionEdge(const ComputedStyle& style,
                                      const ComputedStyle& child_style) {
   ItemPosition alignment =
       FlexibleBoxAlgorithm::AlignmentForChild(style, child_style);
@@ -224,17 +224,17 @@ AxisEdge CrossAxisStaticPositionEdge(const ComputedStyle& style,
   // kFlexEnd, but not kStretch. kStretch is supposed to act like kFlexStart.
   if (style.FlexWrap() == EFlexWrap::kWrapReverse &&
       alignment == ItemPosition::kStretch) {
-    return AxisEdge::kEnd;
+    return LocalAxisEdge::kEnd;
   }
 
   if (alignment == ItemPosition::kFlexEnd ||
       alignment == ItemPosition::kLastBaseline)
-    return AxisEdge::kEnd;
+    return LocalAxisEdge::kEnd;
 
   if (alignment == ItemPosition::kCenter)
-    return AxisEdge::kCenter;
+    return LocalAxisEdge::kCenter;
 
-  return AxisEdge::kStart;
+  return LocalAxisEdge::kStart;
 }
 
 }  // namespace
@@ -287,8 +287,8 @@ void FlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
   for (LayoutBox* oof_child : oofs) {
     BlockNode child(oof_child);
 
-    AxisEdge main_axis_edge = MainAxisStaticPositionEdge(Style(), is_column_);
-    AxisEdge cross_axis_edge =
+    LocalAxisEdge main_axis_edge = MainAxisStaticPositionEdge(Style(), is_column_);
+    LocalAxisEdge cross_axis_edge =
         CrossAxisStaticPositionEdge(Style(), child.Style());
 
     // This code block just collects UMA stats.
@@ -320,7 +320,7 @@ void FlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
                             WebFeature::kFlexboxNewAbsPos);
         }
       }
-      if (main_axis_edge != AxisEdge::kStart) {
+      if (main_axis_edge != LocalAxisEdge::kStart) {
         const bool are_main_axis_insets_auto =
             is_column_
                 ? insets_in_flexbox_writing_mode.BlockStart().IsAuto() &&
@@ -334,18 +334,18 @@ void FlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
       }
     }
 
-    AxisEdge inline_axis_edge = is_column_ ? cross_axis_edge : main_axis_edge;
-    AxisEdge block_axis_edge = is_column_ ? main_axis_edge : cross_axis_edge;
+    LocalAxisEdge inline_axis_edge = is_column_ ? cross_axis_edge : main_axis_edge;
+    LocalAxisEdge block_axis_edge = is_column_ ? main_axis_edge : cross_axis_edge;
 
     InlineEdge inline_edge;
     BlockEdge block_edge;
     LogicalOffset offset = border_scrollbar_padding.StartOffset();
 
     // Determine the static-position based off the axis-edge.
-    if (block_axis_edge == AxisEdge::kStart) {
+    if (block_axis_edge == LocalAxisEdge::kStart) {
       DCHECK(!IsBreakInside(GetBreakToken()));
       block_edge = BlockEdge::kBlockStart;
-    } else if (block_axis_edge == AxisEdge::kCenter) {
+    } else if (block_axis_edge == LocalAxisEdge::kCenter) {
       if (!should_process_block_center) {
         oof_children.emplace_back(oof_child);
         continue;
@@ -361,9 +361,9 @@ void FlexLayoutAlgorithm::HandleOutOfFlowPositionedItems(
       offset.block_offset += total_fragment_size.block_size;
     }
 
-    if (inline_axis_edge == AxisEdge::kStart) {
+    if (inline_axis_edge == LocalAxisEdge::kStart) {
       inline_edge = InlineEdge::kInlineStart;
-    } else if (inline_axis_edge == AxisEdge::kCenter) {
+    } else if (inline_axis_edge == LocalAxisEdge::kCenter) {
       inline_edge = InlineEdge::kInlineCenter;
       offset.inline_offset += total_fragment_size.inline_size / 2;
     } else {
@@ -1443,7 +1443,7 @@ LayoutResult::EStatus FlexLayoutAlgorithm::GiveItemsFinalPositionAndSize(
     }
   }
 
-  BaselineAccumulator baseline_accumulator(Style());
+  BaselineAccumulatorFlex baseline_accumulator(Style());
   LayoutResult::EStatus status = LayoutResult::kSuccess;
 
   for (wtf_size_t flex_line_idx = 0; flex_line_idx < flex_line_outputs->size();
@@ -1591,7 +1591,7 @@ FlexLayoutAlgorithm::GiveItemsFinalPositionAndSizeForFragmentation(
     previously_consumed_block_size = GetBreakToken()->ConsumedBlockSize();
   }
 
-  BaselineAccumulator baseline_accumulator(Style());
+  BaselineAccumulatorFlex baseline_accumulator(Style());
   bool broke_before_row =
       *break_before_row != FlexBreakTokenData::kNotBreakBeforeRow;
   for (auto entry = item_iterator.NextItem(broke_before_row);
diff --git a/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.cc b/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.cc
index ab093d5ddb..b2e4ddecf0 100644
--- a/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.cc
@@ -85,7 +85,7 @@ FlexItem::FlexItem(const FlexibleBoxAlgorithm* algorithm,
                    PhysicalBoxStrut physical_margins,
                    BoxStrut scrollbars,
                    WritingMode baseline_writing_mode,
-                   BaselineGroup baseline_group,
+                   BaselineGroupType baseline_group,
                    bool depends_on_min_max_sizes)
     : algorithm_(algorithm),
       line_number_(0),
@@ -191,7 +191,7 @@ LayoutUnit FlexItem::MarginBoxAscent(bool is_last_baseline,
   if (is_wrap_reverse != is_last_baseline)
     baseline = baseline_fragment.BlockSize() - baseline;
 
-  return baseline_group_ == BaselineGroup::kMajor
+  return baseline_group_ == BaselineGroupType::kMajor
              ? FlowAwareMarginBefore() + baseline
              : FlowAwareMarginAfter() + baseline;
 }
@@ -558,7 +558,7 @@ void FlexLine::ComputeLineItemsPosition(LayoutUnit main_axis_start_offset,
       LayoutUnit descent =
           (flex_item.CrossAxisMarginExtent() + flex_item.cross_axis_size_) -
           ascent;
-      if (flex_item.baseline_group_ == BaselineGroup::kMajor) {
+      if (flex_item.baseline_group_ == BaselineGroupType::kMajor) {
         max_major_ascent_ = std::max(max_major_ascent_, ascent);
         max_major_descent = std::max(max_major_descent, descent);
         child_cross_axis_margin_box_extent =
@@ -882,7 +882,7 @@ void FlexibleBoxAlgorithm::AlignChildren() {
       LayoutUnit baseline_offset;
       if (position == ItemPosition::kBaseline ||
           position == ItemPosition::kLastBaseline) {
-        bool is_major = flex_item.baseline_group_ == BaselineGroup::kMajor;
+        bool is_major = flex_item.baseline_group_ == BaselineGroupType::kMajor;
         LayoutUnit ascent = flex_item.MarginBoxAscent(
             position == ItemPosition::kLastBaseline, is_wrap_reverse);
         LayoutUnit max_ascent = is_major ? line_context.max_major_ascent_
diff --git a/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.h b/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.h
index 14bd056cee..1b491c4ee8 100644
--- a/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.h
+++ b/third_party/blink/renderer/core/layout/flex/flexible_box_algorithm.h
@@ -87,7 +87,7 @@ class FlexItem {
            PhysicalBoxStrut physical_margins,
            BoxStrut scrollbars,
            WritingMode baseline_writing_mode,
-           BaselineGroup baseline_group = BaselineGroup::kMajor,
+           BaselineGroupType baseline_group = BaselineGroupType::kMajor,
            bool depends_on_min_max_sizes = false);
 
   LayoutUnit HypotheticalMainAxisMarginBoxSize() const {
@@ -161,7 +161,7 @@ class FlexItem {
   PhysicalBoxStrut physical_margins_;
   const BoxStrut scrollbars_;
   const WritingDirectionMode baseline_writing_direction_;
-  const BaselineGroup baseline_group_;
+  const BaselineGroupType baseline_group_;
 
   LayoutUnit flexed_content_size_;
 
diff --git a/third_party/blink/renderer/core/layout/grid/grid_item.cc b/third_party/blink/renderer/core/layout/grid/grid_item.cc
index 46daf3ecef..2e263fa7e6 100644
--- a/third_party/blink/renderer/core/layout/grid/grid_item.cc
+++ b/third_party/blink/renderer/core/layout/grid/grid_item.cc
@@ -290,7 +290,7 @@ void GridItemData::SetAlignmentFallback(
     // Set fallback alignment to start edges if an item requests baseline
     // alignment but does not meet the requirements for it.
     fallback_alignment =
-        (BaselineGroup(track_direction) == BaselineGroup::kMajor)
+        (BaselineGroup(track_direction) == BaselineGroupType::kMajor)
             ? AxisEdge::kStart
             : AxisEdge::kEnd;
   }
diff --git a/third_party/blink/renderer/core/layout/grid/grid_item.h b/third_party/blink/renderer/core/layout/grid/grid_item.h
index dfb2ff10b5..2b7bfcbbcc 100644
--- a/third_party/blink/renderer/core/layout/grid/grid_item.h
+++ b/third_party/blink/renderer/core/layout/grid/grid_item.h
@@ -88,7 +88,7 @@ struct CORE_EXPORT GridItemData {
       const GridPlacementData& placement_data,
       const ComputedStyle& grid_style);
 
-  enum BaselineGroup BaselineGroup(
+  enum BaselineGroupType BaselineGroup(
       GridTrackSizingDirection track_direction) const {
     return (track_direction == kForColumns) ? column_baseline_group
                                             : row_baseline_group;
@@ -233,8 +233,8 @@ struct CORE_EXPORT GridItemData {
   AutoSizeBehavior column_auto_behavior;
   AutoSizeBehavior row_auto_behavior;
 
-  enum BaselineGroup column_baseline_group;
-  enum BaselineGroup row_baseline_group;
+  enum BaselineGroupType column_baseline_group;
+  enum BaselineGroupType row_baseline_group;
 
   WritingMode column_baseline_writing_mode;
   WritingMode row_baseline_writing_mode;
diff --git a/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc b/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc
index 095aff824a..201b118219 100644
--- a/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc
@@ -744,7 +744,7 @@ LayoutUnit GridLayoutAlgorithm::Baseline(
   const auto& [begin_set_index, end_set_index] =
       grid_item.SetIndices(track_direction);
 
-  return (grid_item.BaselineGroup(track_direction) == BaselineGroup::kMajor)
+  return (grid_item.BaselineGroup(track_direction) == BaselineGroupType::kMajor)
              ? track_collection.MajorBaseline(begin_set_index)
              : track_collection.MinorBaseline(end_set_index - 1);
 }
@@ -1058,7 +1058,7 @@ LayoutUnit GetExtraMarginForBaseline(const BoxStrut& margins,
       subgridded_item->SetIndices(track_collection.Direction());
 
   const LayoutUnit extra_margin =
-      (subgridded_item->BaselineGroup(track_direction) == BaselineGroup::kMajor)
+      (subgridded_item->BaselineGroup(track_direction) == BaselineGroupType::kMajor)
           ? track_collection.StartExtraMargin(begin_set_index)
           : track_collection.EndExtraMargin(end_set_index);
 
@@ -1652,7 +1652,7 @@ void GridLayoutAlgorithm::ComputeGridItemBaselines(
     // https://www.w3.org/TR/css-align-3/#baseline-sharing-group
     const auto& [begin_set_index, end_set_index] =
         grid_item.SetIndices(track_direction);
-    if (grid_item.BaselineGroup(track_direction) == BaselineGroup::kMajor) {
+    if (grid_item.BaselineGroup(track_direction) == BaselineGroupType::kMajor) {
       track_collection.SetMajorBaseline(begin_set_index, baseline);
     } else {
       track_collection.SetMinorBaseline(end_set_index - 1, baseline);
@@ -3401,11 +3401,11 @@ namespace {
 // opposed to DOM order). The baseline of the grid is determined by the first
 // grid item with baseline alignment in the first row. If no items have
 // baseline alignment, fall back to the first item in row-major order.
-class BaselineAccumulator {
+class BaselineAccumulatorGrid {
   STACK_ALLOCATED();
 
  public:
-  explicit BaselineAccumulator(FontBaseline font_baseline)
+  explicit BaselineAccumulatorGrid(FontBaseline font_baseline)
       : font_baseline_(font_baseline) {}
 
   void Accumulate(const GridItemData& grid_item,
@@ -3551,7 +3551,7 @@ void GridLayoutAlgorithm::PlaceGridItems(
         layout_data.Rows().GetSetCount() + 1, EBreakBetween::kAuto);
   }
 
-  BaselineAccumulator baseline_accumulator(Style().GetFontBaseline());
+  BaselineAccumulatorGrid baseline_accumulator(Style().GetFontBaseline());
 
   const auto layout_subtree =
       cached_layout_subtree ? *cached_layout_subtree
@@ -3594,7 +3594,7 @@ void GridLayoutAlgorithm::PlaceGridItems(
       const LayoutUnit baseline_delta =
           Baseline(layout_data, grid_item, track_direction) -
           GetLogicalBaseline(grid_item, baseline_fragment, track_direction);
-      if (grid_item.BaselineGroup(track_direction) == BaselineGroup::kMajor)
+      if (grid_item.BaselineGroup(track_direction) == BaselineGroupType::kMajor)
         return baseline_delta;
 
       // BaselineGroup::kMinor
@@ -3761,7 +3761,7 @@ void GridLayoutAlgorithm::PlaceGridItemsForFragmentation(
   };
 
   HeapVector<ResultAndOffsets> result_and_offsets;
-  BaselineAccumulator baseline_accumulator(Style().GetFontBaseline());
+  BaselineAccumulatorGrid baseline_accumulator(Style().GetFontBaseline());
   LayoutUnit max_row_expansion;
   LayoutUnit max_item_block_end;
   wtf_size_t expansion_row_set_index;
@@ -3784,7 +3784,7 @@ void GridLayoutAlgorithm::PlaceGridItemsForFragmentation(
   auto PlaceItems = [&]() {
     // Reset our state.
     result_and_offsets.clear();
-    baseline_accumulator = BaselineAccumulator(Style().GetFontBaseline());
+    baseline_accumulator = BaselineAccumulatorGrid(Style().GetFontBaseline());
     max_row_expansion = LayoutUnit();
     max_item_block_end = LayoutUnit();
     expansion_row_set_index = kNotFound;
diff --git a/third_party/blink/renderer/core/layout/mathml/math_scripts_layout_algorithm.cc b/third_party/blink/renderer/core/layout/mathml/math_scripts_layout_algorithm.cc
index bc05699f69..f87a9cbd5b 100644
--- a/third_party/blink/renderer/core/layout/mathml/math_scripts_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/mathml/math_scripts_layout_algorithm.cc
@@ -16,7 +16,7 @@ namespace {
 
 using MathConstants = OpenTypeMathSupport::MathConstants;
 
-static bool IsPrescriptDelimiter(const BlockNode& blockNode) {
+static bool MyIsPrescriptDelimiter(const BlockNode& blockNode) {
   auto* node = blockNode.GetDOMNode();
   return node && IsA<MathMLElement>(node) &&
          node->HasTagName(mathml_names::kMprescriptsTag);
@@ -148,7 +148,7 @@ void MathScriptsLayoutAlgorithm::GatherChildren(
       case MathScriptType::kMultiscripts: {
         // The structure of mmultiscripts is specified here:
         // https://w3c.github.io/mathml-core/#prescripts-and-tensor-indices-mmultiscripts
-        if (IsPrescriptDelimiter(block_child)) {
+        if (MyIsPrescriptDelimiter(block_child)) {
           if (!number_of_scripts_is_even || *prescripts) {
             NOTREACHED();
             return;
diff --git a/third_party/blink/renderer/core/layout/svg/layout_svg_rect.cc b/third_party/blink/renderer/core/layout/svg/layout_svg_rect.cc
index 06ba82fd89..49aa89a329 100644
--- a/third_party/blink/renderer/core/layout/svg/layout_svg_rect.cc
+++ b/third_party/blink/renderer/core/layout/svg/layout_svg_rect.cc
@@ -35,7 +35,7 @@ namespace blink {
 
 namespace {
 
-bool GeometryPropertiesChanged(const ComputedStyle& old_style,
+bool GeometryPropertiesChangedLSR(const ComputedStyle& old_style,
                                const ComputedStyle& new_style) {
   return old_style.X() != new_style.X() || old_style.Y() != new_style.Y() ||
          old_style.UsedWidth() != new_style.UsedWidth() ||
@@ -54,7 +54,7 @@ void LayoutSVGRect::StyleDidChange(StyleDifference diff,
   NOT_DESTROYED();
   LayoutSVGShape::StyleDidChange(diff, old_style);
 
-  if (old_style && GeometryPropertiesChanged(*old_style, StyleRef())) {
+  if (old_style && GeometryPropertiesChangedLSR(*old_style, StyleRef())) {
     SetNeedsShapeUpdate();
   }
 }
diff --git a/third_party/blink/renderer/core/page/drag_image.cc b/third_party/blink/renderer/core/page/drag_image.cc
index 6a7620eaab..30fcf9efab 100644
--- a/third_party/blink/renderer/core/page/drag_image.cc
+++ b/third_party/blink/renderer/core/page/drag_image.cc
@@ -52,6 +52,9 @@
 #include "ui/gfx/geometry/point_f.h"
 #include "ui/gfx/geometry/rect_f.h"
 
+// To avoid conflicts with the DrawText macro from the Windows SDK...
+#undef DrawText
+
 namespace blink {
 
 namespace {
diff --git a/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc b/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
index a9061134a8..a74ff3bc3e 100644
--- a/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
+++ b/third_party/blink/renderer/core/paint/pre_paint_tree_walk.cc
@@ -36,7 +36,7 @@ namespace blink {
 
 namespace {
 
-bool IsLinkHighlighted(const LayoutObject& object) {
+bool IsLinkHighlightedPPTW(const LayoutObject& object) {
   return object.GetFrame()->GetPage()->GetLinkHighlight().IsHighlighting(
       object);
 }
@@ -390,7 +390,7 @@ FragmentData* PrePaintTreeWalk::GetOrCreateFragmentData(
     }
   } else {
     if (pre_paint_info.is_inside_fragment_child) {
-      if (!object.HasInlineFragments() && !IsLinkHighlighted(object)) {
+      if (!object.HasInlineFragments() && !IsLinkHighlightedPPTW(object)) {
         // We don't need any additional fragments for culled inlines - unless
         // this is the highlighted link (in which case even culled inlines get
         // paint effects).
diff --git a/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc b/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc
index a00afff091..843c5f6c75 100644
--- a/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc
+++ b/third_party/blink/renderer/core/speculation_rules/speculation_rule_set.cc
@@ -115,7 +115,7 @@ bool IsValidBrowsingContextNameOrKeyword(const String& name_or_keyword) {
 
 // If `out_error` is provided and hasn't already had a message set, sets it to
 // `message`.
-void SetParseErrorMessage(String* out_error, String message) {
+void SetParseErrorMessage2(String* out_error, String message) {
   if (out_error && out_error->IsNull()) {
     *out_error = message;
   }
@@ -163,7 +163,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     const String& input_key = input->at(i).first;
     if (!base::Contains(kKnownKeys, input_key) &&
         !base::Contains(kConditionalKnownKeys, input_key)) {
-      SetParseErrorMessage(
+      SetParseErrorMessage2(
           out_error, "A rule contains an unknown key: \"" + input_key + "\".");
       return nullptr;
     }
@@ -183,7 +183,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
   String source;
   if (source_value) {
     if (!source_value->AsString(&source)) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "The value of the \"source\" key must be a string.");
       return nullptr;
     }
@@ -200,23 +200,23 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     } else if (!has_urls && has_where) {
       source = "document";
     } else if (has_urls && has_where) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A rule with no explicit \"source\" must specify "
                            "\"urls\" or a \"where\" condition, but not both.");
       return nullptr;
     } else {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A rule with no explicit \"source\" must specify "
                            "one of \"urls\" or \"where\".");
       return nullptr;
     }
   } else {
-    SetParseErrorMessage(out_error, "A rule must have a source.");
+    SetParseErrorMessage2(out_error, "A rule must have a source.");
     return nullptr;
   }
 
   if (!(source == "list" || (document_rules_enabled && source == "document"))) {
-    SetParseErrorMessage(out_error,
+    SetParseErrorMessage2(out_error,
                          "A rule has an unknown source: \"" + source + "\".");
     return nullptr;
   }
@@ -225,7 +225,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
   if (source == "list") {
     // If input["where"] exists, then return null.
     if (input->Get("where")) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A list rule may not have document rule matchers.");
       return nullptr;
     }
@@ -240,7 +240,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
       // "document", then return null.
       if (!relative_to_enabled || !relative_to->AsString(&value) ||
           !base::Contains(kKnownRelativeToValues, value)) {
-        SetParseErrorMessage(out_error,
+        SetParseErrorMessage2(out_error,
                              "A rule has an unknown \"relative_to\" value.");
         return nullptr;
       }
@@ -256,7 +256,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     // is not a string, then return null.
     JSONArray* input_urls = input->GetArray("urls");
     if (!input_urls) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A list rule must have a \"urls\" array.");
       return nullptr;
     }
@@ -266,7 +266,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     for (wtf_size_t i = 0; i < input_urls->size(); ++i) {
       String url_string;
       if (!input_urls->at(i)->AsString(&url_string)) {
-        SetParseErrorMessage(out_error, "URLs must be given as strings.");
+        SetParseErrorMessage2(out_error, "URLs must be given as strings.");
         return nullptr;
       }
 
@@ -285,7 +285,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     DCHECK(document_rules_enabled);
     // If input["urls"] exists, then return null.
     if (input->Get("urls")) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A document rule cannot have a \"urls\" key.");
       return nullptr;
     }
@@ -293,7 +293,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     // "relative_to" outside the "href_matches" clause is not allowed for
     // document rules.
     if (input->Get("relative_to")) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A document rule cannot have \"relative_to\" "
                            "outside the \"where\" clause.");
       return nullptr;
@@ -318,7 +318,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
   // If input["requires"] exists, but is not a list, then return null.
   JSONValue* requirements = input->Get("requires");
   if (requirements && requirements->GetType() != JSONValue::kTypeArray) {
-    SetParseErrorMessage(out_error, "\"requires\" must be an array.");
+    SetParseErrorMessage2(out_error, "\"requires\" must be an array.");
     return nullptr;
   }
 
@@ -329,7 +329,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     for (wtf_size_t i = 0; i < requirements_array->size(); ++i) {
       String requirement;
       if (!requirements_array->at(i)->AsString(&requirement)) {
-        SetParseErrorMessage(out_error, "Requirements must be strings.");
+        SetParseErrorMessage2(out_error, "Requirements must be strings.");
         return nullptr;
       }
 
@@ -337,7 +337,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
         requires_anonymous_client_ip =
             SpeculationRule::RequiresAnonymousClientIPWhenCrossOrigin(true);
       } else {
-        SetParseErrorMessage(
+        SetParseErrorMessage2(
             out_error,
             "A rule has an unknown requirement: \"" + requirement + "\".");
         return nullptr;
@@ -356,11 +356,11 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     // Set targetHint to input["target_hint"].
     String target_hint_str;
     if (!target_hint_value->AsString(&target_hint_str)) {
-      SetParseErrorMessage(out_error, "\"target_hint\" must be a string.");
+      SetParseErrorMessage2(out_error, "\"target_hint\" must be a string.");
       return nullptr;
     }
     if (!IsValidBrowsingContextNameOrKeyword(target_hint_str)) {
-      SetParseErrorMessage(out_error,
+      SetParseErrorMessage2(out_error,
                            "A rule has an invalid \"target_hint\": \"" +
                                target_hint_str + "\".");
       return nullptr;
@@ -377,7 +377,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     // If input["referrer_policy"] is not a referrer policy, then return null.
     String referrer_policy_str;
     if (!referrer_policy_value->AsString(&referrer_policy_str)) {
-      SetParseErrorMessage(out_error, "A referrer policy must be a string.");
+      SetParseErrorMessage2(out_error, "A referrer policy must be a string.");
       return nullptr;
     }
 
@@ -387,7 +387,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
       if (!SecurityPolicy::ReferrerPolicyFromString(
               referrer_policy_str, kDoNotSupportReferrerPolicyLegacyKeywords,
               &referrer_policy_out)) {
-        SetParseErrorMessage(out_error,
+        SetParseErrorMessage2(out_error,
                              "A rule has an invalid referrer policy: \"" +
                                  referrer_policy_str + "\".");
         return nullptr;
@@ -405,7 +405,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
 
     String eagerness_str;
     if (!eagerness_value->AsString(&eagerness_str)) {
-      SetParseErrorMessage(out_error, "Eagerness value must be a string.");
+      SetParseErrorMessage2(out_error, "Eagerness value must be a string.");
       return nullptr;
     }
 
@@ -416,7 +416,7 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
     } else if (eagerness_str == "conservative") {
       eagerness = mojom::blink::SpeculationEagerness::kConservative;
     } else {
-      SetParseErrorMessage(
+      SetParseErrorMessage2(
           out_error, "Eagerness value: \"" + eagerness_str + "\" is invalid.");
       return nullptr;
     }
@@ -434,8 +434,8 @@ SpeculationRule* ParseSpeculationRule(JSONObject* input,
       IsSpeculationRulesNoVarySearchHintEnabled(context)) {
     String no_vary_search_str;
     if (!no_vary_search_value->AsString(&no_vary_search_str)) {
-      SetParseErrorMessage(out_error,
-                           "expects_no_vary_search's value must be a string.");
+      SetParseErrorMessage2(out_error,
+                            "expects_no_vary_search's value must be a string.");
       return nullptr;
     }
     // Parse No-Vary-Search hint value.
diff --git a/third_party/blink/renderer/core/timing/performance_timing.cc b/third_party/blink/renderer/core/timing/performance_timing.cc
index 75810b5953..85cd46ec4f 100644
--- a/third_party/blink/renderer/core/timing/performance_timing.cc
+++ b/third_party/blink/renderer/core/timing/performance_timing.cc
@@ -25,7 +25,7 @@
 // Legacy support for NT1(https://www.w3.org/TR/navigation-timing/).
 namespace blink {
 
-static uint64_t ToIntegerMilliseconds(base::TimeDelta duration,
+static uint64_t ToIntegerMilliseconds2(base::TimeDelta duration,
                                       bool cross_origin_isolated_capability) {
   // TODO(npm): add histograms to understand when/why |duration| is sometimes
   // negative.
@@ -342,8 +342,8 @@ uint64_t PerformanceTiming::MonotonicTimeToIntegerMilliseconds(
   if (!timing)
     return 0;
 
-  return ToIntegerMilliseconds(timing->MonotonicTimeToPseudoWallTime(time),
-                               cross_origin_isolated_capability_);
+  return ToIntegerMilliseconds2(timing->MonotonicTimeToPseudoWallTime(time),
+                                cross_origin_isolated_capability_);
 }
 
 // static
diff --git a/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc b/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc
index 9db34ca8e9..e396c5f721 100644
--- a/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc
+++ b/third_party/blink/renderer/modules/accessibility/inspector_type_builder_helper.cc
@@ -18,7 +18,7 @@ std::unique_ptr<AXProperty> CreateProperty(const String& name,
   return AXProperty::create().setName(name).setValue(std::move(value)).build();
 }
 
-String IgnoredReasonName(AXIgnoredReason reason) {
+static String IgnoredReasonName_ITBH(AXIgnoredReason reason) {
   switch (reason) {
     case kAXActiveFullscreenElement:
       return "activeFullscreenElement";
@@ -62,10 +62,10 @@ String IgnoredReasonName(AXIgnoredReason reason) {
 std::unique_ptr<AXProperty> CreateProperty(IgnoredReason reason) {
   if (reason.related_object)
     return CreateProperty(
-        IgnoredReasonName(reason.reason),
+        IgnoredReasonName_ITBH(reason.reason),
         CreateRelatedNodeListValue(*(reason.related_object), nullptr,
                                    AXValueTypeEnum::Idref));
-  return CreateProperty(IgnoredReasonName(reason.reason),
+  return CreateProperty(IgnoredReasonName_ITBH(reason.reason),
                         CreateBooleanValue(true));
 }
 
diff --git a/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc b/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc
index f6f2780b37..9b9958e4d4 100644
--- a/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc
+++ b/third_party/blink/renderer/modules/bluetooth/bluetooth_device.cc
@@ -27,7 +27,7 @@
 namespace blink {
 
 const char kAbortErrorMessage[] = "The Bluetooth operation was cancelled.";
-const char kInactiveDocumentError[] = "Document not active";
+const char kInactiveDocumentError2[] = "Document not active";
 const char kInvalidStateErrorMessage[] =
     "Pending watch advertisements operation.";
 
@@ -114,7 +114,7 @@ ScriptPromise BluetoothDevice::watchAdvertisements(
     ExceptionState& exception_state) {
   ExecutionContext* context = GetExecutionContext();
   if (!context) {
-    exception_state.ThrowTypeError(kInactiveDocumentError);
+    exception_state.ThrowTypeError(kInactiveDocumentError2);
     return ScriptPromise();
   }
 
@@ -205,7 +205,7 @@ void BluetoothDevice::AbortWatchAdvertisements(AbortSignal* signal) {
 ScriptPromise BluetoothDevice::forget(ScriptState* script_state,
                                       ExceptionState& exception_state) {
   if (!GetExecutionContext()) {
-    exception_state.ThrowTypeError(kInactiveDocumentError);
+    exception_state.ThrowTypeError(kInactiveDocumentError2);
     return ScriptPromise();
   }
 
diff --git a/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc b/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc
index 24801cefb0..2a62b00a6f 100644
--- a/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc
+++ b/third_party/blink/renderer/modules/breakout_box/media_stream_video_track_underlying_sink.cc
@@ -49,9 +49,9 @@ BASE_FEATURE(kBreakoutBoxConversionWithoutSinkSignal,
              "BreakoutBoxConversionWithoutSinkSignal",
              base::FEATURE_ENABLED_BY_DEFAULT);
 
-class TransferringOptimizer : public WritableStreamTransferringOptimizer {
+class TransferringOptimizerMSVTUS : public WritableStreamTransferringOptimizer {
  public:
-  explicit TransferringOptimizer(
+  explicit TransferringOptimizerMSVTUS(
       scoped_refptr<PushableMediaStreamVideoSource::Broker> source_broker)
       : source_broker_(std::move(source_broker)) {}
   UnderlyingSinkBase* PerformInProcessOptimization(
@@ -157,7 +157,7 @@ ScriptPromise MediaStreamVideoTrackUnderlyingSink::close(
 std::unique_ptr<WritableStreamTransferringOptimizer>
 MediaStreamVideoTrackUnderlyingSink::GetTransferringOptimizer() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  return std::make_unique<TransferringOptimizer>(source_broker_);
+  return std::make_unique<TransferringOptimizerMSVTUS>(source_broker_);
 }
 
 void MediaStreamVideoTrackUnderlyingSink::Disconnect() {
diff --git a/third_party/blink/renderer/modules/canvas/BUILD.gn b/third_party/blink/renderer/modules/canvas/BUILD.gn
index 5298f281c3..d812d7e1bf 100644
--- a/third_party/blink/renderer/modules/canvas/BUILD.gn
+++ b/third_party/blink/renderer/modules/canvas/BUILD.gn
@@ -57,6 +57,10 @@ blink_modules_sources("canvas") {
     "offscreencanvas2d/offscreen_canvas_rendering_context_2d.h",
     "testing/canvas_test_utils.cc",
   ]
+  jumbo_excluded_sources = [
+    "imagebitmap/image_bitmap_rendering_context_base.cc",
+    "offscreencanvas2d/offscreen_canvas_rendering_context_2d.cc",
+  ]
 
   deps = [
     "//third_party/blink/renderer/modules/formatted_text",
diff --git a/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc b/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc
index 7effe4a807..cf28e9628b 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/credentials_container.cc
@@ -725,7 +725,7 @@ void OnGetComplete(std::unique_ptr<ScopedPromiseResolver> scoped_resolver,
   resolver->Resolve(mojo::ConvertTo<Credential*>(std::move(credential_info)));
 }
 
-DOMArrayBuffer* VectorToDOMArrayBuffer(const Vector<uint8_t> buffer) {
+static DOMArrayBuffer* VectorToDOMArrayBuffer_CC(const Vector<uint8_t> buffer) {
   return DOMArrayBuffer::Create(static_cast<const void*>(buffer.data()),
                                 buffer.size());
 }
@@ -748,10 +748,10 @@ AuthenticationExtensionsPRFValues* GetPRFExtensionResults(
     const mojom::blink::PRFValuesPtr& prf_results) {
   auto* values = AuthenticationExtensionsPRFValues::Create();
   values->setFirst(MakeGarbageCollected<V8UnionArrayBufferOrArrayBufferView>(
-      VectorToDOMArrayBuffer(std::move(prf_results->first))));
+      VectorToDOMArrayBuffer_CC(std::move(prf_results->first))));
   if (prf_results->second) {
     values->setSecond(MakeGarbageCollected<V8UnionArrayBufferOrArrayBufferView>(
-        VectorToDOMArrayBuffer(std::move(prf_results->second.value()))));
+        VectorToDOMArrayBuffer_CC(std::move(prf_results->second.value()))));
   }
   return values;
 }
@@ -791,17 +791,17 @@ void OnMakePublicKeyCredentialComplete(
                       WebFeature::kWebAuthnRkRequiredCreationSuccess);
   }
   DOMArrayBuffer* client_data_buffer =
-      VectorToDOMArrayBuffer(std::move(credential->info->client_data_json));
+      VectorToDOMArrayBuffer_CC(std::move(credential->info->client_data_json));
   DOMArrayBuffer* raw_id =
-      VectorToDOMArrayBuffer(std::move(credential->info->raw_id));
+      VectorToDOMArrayBuffer_CC(std::move(credential->info->raw_id));
   DOMArrayBuffer* attestation_buffer =
-      VectorToDOMArrayBuffer(std::move(credential->attestation_object));
+      VectorToDOMArrayBuffer_CC(std::move(credential->attestation_object));
   DOMArrayBuffer* authenticator_data =
-      VectorToDOMArrayBuffer(std::move(credential->info->authenticator_data));
+      VectorToDOMArrayBuffer_CC(std::move(credential->info->authenticator_data));
   DOMArrayBuffer* public_key_der = nullptr;
   if (credential->public_key_der) {
     public_key_der =
-        VectorToDOMArrayBuffer(std::move(credential->public_key_der.value()));
+        VectorToDOMArrayBuffer_CC(std::move(credential->public_key_der.value()));
   }
   auto* authenticator_response =
       MakeGarbageCollected<AuthenticatorAttestationResponse>(
@@ -971,7 +971,7 @@ void OnGetAssertionComplete(
 #endif
       resolver->Resolve(MakeGarbageCollected<PublicKeyCredential>(
           credential->info->id,
-          VectorToDOMArrayBuffer(std::move(credential->info->raw_id)),
+          VectorToDOMArrayBuffer_CC(std::move(credential->info->raw_id)),
           authenticator_response, credential->authenticator_attachment,
           extension_outputs));
       return;
@@ -997,7 +997,7 @@ void OnGetAssertionComplete(
           AuthenticationExtensionsLargeBlobOutputs::Create();
       if (extensions->large_blob) {
         large_blob_outputs->setBlob(
-            VectorToDOMArrayBuffer(std::move(*extensions->large_blob)));
+            VectorToDOMArrayBuffer_CC(std::move(*extensions->large_blob)));
       }
       if (extensions->echo_large_blob_written) {
         large_blob_outputs->setWritten(extensions->large_blob_written);
@@ -1006,7 +1006,7 @@ void OnGetAssertionComplete(
     }
     if (extensions->get_cred_blob) {
       extension_outputs->setGetCredBlob(
-          VectorToDOMArrayBuffer(std::move(*extensions->get_cred_blob)));
+          VectorToDOMArrayBuffer_CC(std::move(*extensions->get_cred_blob)));
     }
     if (extensions->echo_prf) {
       auto* prf_outputs = AuthenticationExtensionsPRFOutputs::Create();
@@ -1018,7 +1018,7 @@ void OnGetAssertionComplete(
     }
     resolver->Resolve(MakeGarbageCollected<PublicKeyCredential>(
         credential->info->id,
-        VectorToDOMArrayBuffer(std::move(credential->info->raw_id)),
+        VectorToDOMArrayBuffer_CC(std::move(credential->info->raw_id)),
         authenticator_response, credential->authenticator_attachment,
         extension_outputs));
     return;
diff --git a/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc b/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc
index 520b8afcaa..37871ce504 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/federated_credential.cc
@@ -20,7 +20,7 @@
 namespace blink {
 
 namespace {
-constexpr char kFederatedCredentialType[] = "federated";
+constexpr char kFederatedCredentialTypeFC[] = "federated";
 }  // namespace
 
 FederatedCredential* FederatedCredential::Create(
@@ -68,7 +68,7 @@ FederatedCredential::FederatedCredential(
     scoped_refptr<const SecurityOrigin> provider_origin,
     const String& name,
     const KURL& icon_url)
-    : Credential(id, kFederatedCredentialType),
+    : Credential(id, kFederatedCredentialTypeFC),
       provider_origin_(provider_origin),
       name_(name),
       icon_url_(icon_url) {
diff --git a/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc b/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc
index 01f0d926b0..2cad7bf883 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/identity_credential.cc
@@ -20,7 +20,7 @@ namespace {
 using mojom::blink::DisconnectStatus;
 using mojom::blink::RequestTokenStatus;
 
-constexpr char kIdentityCredentialType[] = "identity";
+constexpr char kIdentityCredentialType2[] = "identity";
 
 // These values are persisted to logs. Entries should not be renumbered and
 // numeric values should never be reused.
@@ -87,7 +87,7 @@ bool IdentityCredential::IsRejectingPromiseDueToCSP(
 
 IdentityCredential::IdentityCredential(const String& token,
                                        bool is_auto_selected)
-    : Credential(/* id = */ "", kIdentityCredentialType),
+    : Credential(/* id = */ "", kIdentityCredentialType2),
       token_(token),
       is_auto_selected_(is_auto_selected) {}
 
diff --git a/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc b/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc
index 517ef6eb15..dd11eef629 100644
--- a/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc
+++ b/third_party/blink/renderer/modules/credentialmanagement/otp_credential.cc
@@ -9,12 +9,12 @@
 
 namespace blink {
 
-namespace {
-constexpr char kOtpCredentialType[] = "otp";
+namespace i {
+constexpr static char kOtpCredentialType[] = "otp";
 }
 
 OTPCredential::OTPCredential(const String& code)
-    : Credential(String(), kOtpCredentialType), code_(code) {}
+    : Credential(String(), i::kOtpCredentialType), code_(code) {}
 
 bool OTPCredential::IsOTPCredential() const {
   return true;
diff --git a/third_party/blink/renderer/modules/hid/hid_device.cc b/third_party/blink/renderer/modules/hid/hid_device.cc
index c470419590..1880a54f5e 100644
--- a/third_party/blink/renderer/modules/hid/hid_device.cc
+++ b/third_party/blink/renderer/modules/hid/hid_device.cc
@@ -34,7 +34,7 @@ const char kReceiveFeatureReportFailed[] =
 const char kUnexpectedClose[] = "The device was closed unexpectedly.";
 const char kArrayBufferTooBig[] =
     "The provided ArrayBuffer exceeds the maximum allowed size.";
-const char kContextGone[] = "Script context has shut down.";
+const char kContextGone2[] = "Script context has shut down.";
 
 enum ReportType {
   kInput,
@@ -256,7 +256,7 @@ ScriptPromise HIDDevice::open(ScriptState* script_state,
                               ExceptionState& exception_state) {
   if (!GetExecutionContext()) {
     exception_state.ThrowDOMException(DOMExceptionCode::kNotSupportedError,
-                                      kContextGone);
+                                      kContextGone2);
     return ScriptPromise();
   }
 
@@ -306,7 +306,7 @@ ScriptPromise HIDDevice::forget(ScriptState* script_state,
                                 ExceptionState& exception_state) {
   if (!GetExecutionContext()) {
     exception_state.ThrowDOMException(DOMExceptionCode::kNotSupportedError,
-                                      kContextGone);
+                                      kContextGone2);
     return ScriptPromise();
   }
 
diff --git a/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc b/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc
index 985f071ac2..18409e48cd 100644
--- a/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/h264_encoder.cc
@@ -137,15 +137,15 @@ void H264Encoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
   picture.iColorFormat = EVideoFormatType::videoFormatI420;
   picture.uiTimeStamp =
       (capture_timestamp - first_frame_timestamp_).InMilliseconds();
-  picture.iStride[0] = frame->stride(VideoFrame::kYPlane);
-  picture.iStride[1] = frame->stride(VideoFrame::kUPlane);
-  picture.iStride[2] = frame->stride(VideoFrame::kVPlane);
+  picture.iStride[0] = frame->stride(media::VideoFrame::kYPlane);
+  picture.iStride[1] = frame->stride(media::VideoFrame::kUPlane);
+  picture.iStride[2] = frame->stride(media::VideoFrame::kVPlane);
   picture.pData[0] =
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::kYPlane));
+      const_cast<uint8_t*>(frame->visible_data(media::VideoFrame::kYPlane));
   picture.pData[1] =
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::kUPlane));
+      const_cast<uint8_t*>(frame->visible_data(media::VideoFrame::kUPlane));
   picture.pData[2] =
-      const_cast<uint8_t*>(frame->visible_data(VideoFrame::kVPlane));
+      const_cast<uint8_t*>(frame->visible_data(media::VideoFrame::kVPlane));
 
   SFrameBSInfo info = {};
 
diff --git a/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc b/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
index a49e43271b..992de80e0b 100644
--- a/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
+++ b/third_party/blink/renderer/modules/mediarecorder/vpx_encoder.cc
@@ -17,8 +17,6 @@
 #include "third_party/blink/renderer/platform/instrumentation/tracing/trace_event.h"
 #include "ui/gfx/geometry/size.h"
 
-using media::VideoFrameMetadata;
-
 namespace blink {
 
 void VpxEncoder::VpxCodecDeleter::operator()(vpx_codec_ctx_t* codec) {
@@ -92,25 +90,25 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
   switch (frame->format()) {
     case media::PIXEL_FORMAT_NV12: {
       last_frame_had_alpha_ = false;
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kYPlane),
-               frame->stride(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kUVPlane),
-               frame->stride(VideoFrame::kUVPlane),
-               frame->visible_data(VideoFrame::kUVPlane) + 1,
-               frame->stride(VideoFrame::kUVPlane), duration, force_keyframe,
+      DoEncode(encoder_.get(), frame_size, frame->data(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kYPlane),
+               frame->stride(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kUVPlane),
+               frame->stride(media::VideoFrame::kUVPlane),
+               frame->visible_data(media::VideoFrame::kUVPlane) + 1,
+               frame->stride(media::VideoFrame::kUVPlane), duration, force_keyframe,
                data, &keyframe, VPX_IMG_FMT_NV12);
       break;
     }
     case media::PIXEL_FORMAT_I420: {
       last_frame_had_alpha_ = false;
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kYPlane),
-               frame->stride(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kUPlane),
-               frame->stride(VideoFrame::kUPlane),
-               frame->visible_data(VideoFrame::kVPlane),
-               frame->stride(VideoFrame::kVPlane), duration, force_keyframe,
+      DoEncode(encoder_.get(), frame_size, frame->data(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kYPlane),
+               frame->stride(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kUPlane),
+               frame->stride(media::VideoFrame::kUPlane),
+               frame->visible_data(media::VideoFrame::kVPlane),
+               frame->stride(media::VideoFrame::kVPlane), duration, force_keyframe,
                data, &keyframe, VPX_IMG_FMT_I420);
       break;
     }
@@ -125,15 +123,15 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
           return;
         }
         u_plane_stride_ = media::VideoFrame::RowBytes(
-            VideoFrame::kUPlane, frame->format(), frame_size.width());
+            media::VideoFrame::kUPlane, frame->format(), frame_size.width());
         v_plane_stride_ = media::VideoFrame::RowBytes(
-            VideoFrame::kVPlane, frame->format(), frame_size.width());
+            media::VideoFrame::kVPlane, frame->format(), frame_size.width());
         v_plane_offset_ = media::VideoFrame::PlaneSize(
-                              frame->format(), VideoFrame::kUPlane, frame_size)
+                              frame->format(), media::VideoFrame::kUPlane, frame_size)
                               .GetArea();
         alpha_dummy_planes_.resize(base::checked_cast<wtf_size_t>(
             v_plane_offset_ + media::VideoFrame::PlaneSize(frame->format(),
-                                                           VideoFrame::kVPlane,
+                                                           media::VideoFrame::kVPlane,
                                                            frame_size)
                                   .GetArea()));
         // It is more expensive to encode 0x00, so use 0x80 instead.
@@ -143,19 +141,19 @@ void VpxEncoder::EncodeFrame(scoped_refptr<media::VideoFrame> frame,
       force_keyframe = force_keyframe || !last_frame_had_alpha_;
       last_frame_had_alpha_ = true;
 
-      DoEncode(encoder_.get(), frame_size, frame->data(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kYPlane),
-               frame->stride(VideoFrame::kYPlane),
-               frame->visible_data(VideoFrame::kUPlane),
-               frame->stride(VideoFrame::kUPlane),
-               frame->visible_data(VideoFrame::kVPlane),
-               frame->stride(VideoFrame::kVPlane), duration, force_keyframe,
+      DoEncode(encoder_.get(), frame_size, frame->data(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kYPlane),
+               frame->stride(media::VideoFrame::kYPlane),
+               frame->visible_data(media::VideoFrame::kUPlane),
+               frame->stride(media::VideoFrame::kUPlane),
+               frame->visible_data(media::VideoFrame::kVPlane),
+               frame->stride(media::VideoFrame::kVPlane), duration, force_keyframe,
                data, &keyframe, VPX_IMG_FMT_I420);
 
       DoEncode(alpha_encoder_.get(), frame_size,
-               frame->data(VideoFrame::kAPlane),
-               frame->visible_data(VideoFrame::kAPlane),
-               frame->stride(VideoFrame::kAPlane), alpha_dummy_planes_.data(),
+               frame->data(media::VideoFrame::kAPlane),
+               frame->visible_data(media::VideoFrame::kAPlane),
+               frame->stride(media::VideoFrame::kAPlane), alpha_dummy_planes_.data(),
                base::checked_cast<int>(u_plane_stride_),
                alpha_dummy_planes_.data() + v_plane_offset_,
                base::checked_cast<int>(v_plane_stride_), duration, keyframe,
diff --git a/third_party/blink/renderer/modules/mediastream/BUILD.gn b/third_party/blink/renderer/modules/mediastream/BUILD.gn
index 5c753496ba..96d767c2f2 100644
--- a/third_party/blink/renderer/modules/mediastream/BUILD.gn
+++ b/third_party/blink/renderer/modules/mediastream/BUILD.gn
@@ -120,6 +120,13 @@ blink_modules_sources("mediastream") {
     "webaudio_media_stream_audio_sink.cc",
     "webaudio_media_stream_audio_sink.h",
   ]
+
+  jumbo_excluded_sources = [
+    "input_device_info.cc",
+    "processed_local_audio_source.cc",
+    "user_media_processor.cc",
+  ]
+
   deps = [
     "//build:chromecast_buildflags",
     "//build:chromeos_buildflags",
diff --git a/third_party/blink/renderer/modules/payments/payment_instruments.cc b/third_party/blink/renderer/modules/payments/payment_instruments.cc
index 725b86e60c..33c969a574 100644
--- a/third_party/blink/renderer/modules/payments/payment_instruments.cc
+++ b/third_party/blink/renderer/modules/payments/payment_instruments.cc
@@ -78,7 +78,7 @@ bool rejectError(ScriptPromiseResolver* resolver,
   return false;
 }
 
-bool AllowedToUsePaymentFeatures(ScriptState* script_state) {
+bool AllowedToUsePaymentFeatures2(ScriptState* script_state) {
   if (!script_state->ContextIsValid())
     return false;
   return ExecutionContext::From(script_state)
@@ -107,7 +107,7 @@ ScriptPromise PaymentInstruments::deleteInstrument(
     ScriptState* script_state,
     const String& instrument_key,
     ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_->is_bound()) {
@@ -130,7 +130,7 @@ ScriptPromise PaymentInstruments::deleteInstrument(
 ScriptPromise PaymentInstruments::get(ScriptState* script_state,
                                       const String& instrument_key,
                                       ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_->is_bound()) {
@@ -152,7 +152,7 @@ ScriptPromise PaymentInstruments::get(ScriptState* script_state,
 
 ScriptPromise PaymentInstruments::keys(ScriptState* script_state,
                                        ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_->is_bound()) {
@@ -174,7 +174,7 @@ ScriptPromise PaymentInstruments::keys(ScriptState* script_state,
 ScriptPromise PaymentInstruments::has(ScriptState* script_state,
                                       const String& instrument_key,
                                       ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_->is_bound()) {
@@ -198,7 +198,7 @@ ScriptPromise PaymentInstruments::set(ScriptState* script_state,
                                       const String& instrument_key,
                                       const PaymentInstrument* details,
                                       ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_->is_bound()) {
@@ -233,7 +233,7 @@ ScriptPromise PaymentInstruments::set(ScriptState* script_state,
 
 ScriptPromise PaymentInstruments::clear(ScriptState* script_state,
                                         ExceptionState& exception_state) {
-  if (!AllowedToUsePaymentFeatures(script_state))
+  if (!AllowedToUsePaymentFeatures2(script_state))
     return RejectNotAllowedToUsePaymentFeatures(script_state, exception_state);
 
   if (!manager_->is_bound()) {
diff --git a/third_party/blink/renderer/modules/peerconnection/BUILD.gn b/third_party/blink/renderer/modules/peerconnection/BUILD.gn
index aed379a59f..90bb7c82e5 100644
--- a/third_party/blink/renderer/modules/peerconnection/BUILD.gn
+++ b/third_party/blink/renderer/modules/peerconnection/BUILD.gn
@@ -155,6 +155,12 @@ blink_modules_sources("peerconnection") {
     "webrtc_video_perf_reporter.h",
   ]
 
+  jumbo_excluded_sources = [
+    "peer_connection_tracker.cc",
+    "rtc_data_channel.cc",
+    "rtc_rtp_sender_impl.cc",
+  ]
+
   public_deps = [ "//third_party/webrtc_overrides:webrtc_component" ]
   deps = [
     "//build:chromecast_buildflags",
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc b/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
index afbcb192cc..cb133ece98 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.cc
@@ -237,7 +237,7 @@ RTCIceCandidatePlatform* ConvertToRTCIceCandidatePlatform(
       candidate->usernameFragment());
 }
 
-webrtc::PeerConnectionInterface::IceTransportsType IceTransportPolicyFromString(
+webrtc::PeerConnectionInterface::IceTransportsType IceTransportPolicyFromString2(
     const String& policy) {
   if (policy == "relay")
     return webrtc::PeerConnectionInterface::kRelay;
@@ -280,11 +280,11 @@ webrtc::PeerConnectionInterface::RTCConfiguration ParseConfiguration(
   if (configuration->hasIceTransportPolicy()) {
     UseCounter::Count(context, WebFeature::kRTCConfigurationIceTransportPolicy);
     web_configuration.type =
-        IceTransportPolicyFromString(configuration->iceTransportPolicy());
+        IceTransportPolicyFromString2(configuration->iceTransportPolicy());
   } else if (configuration->hasIceTransports()) {
     UseCounter::Count(context, WebFeature::kRTCConfigurationIceTransports);
     web_configuration.type =
-        IceTransportPolicyFromString(configuration->iceTransports());
+        IceTransportPolicyFromString2(configuration->iceTransports());
   }
 
   if (configuration->bundlePolicy() == "max-compat") {
diff --git a/third_party/blink/renderer/modules/permissions/BUILD.gn b/third_party/blink/renderer/modules/permissions/BUILD.gn
index 2e4b14e097..ab20f6efde 100644
--- a/third_party/blink/renderer/modules/permissions/BUILD.gn
+++ b/third_party/blink/renderer/modules/permissions/BUILD.gn
@@ -15,4 +15,5 @@ blink_modules_sources("permissions") {
     "permissions.cc",
     "permissions.h",
   ]
+  jumbo_excluded_sources = [ "permission_utils.cc" ]
 }
diff --git a/third_party/blink/renderer/modules/webaudio/analyser_handler.cc b/third_party/blink/renderer/modules/webaudio/analyser_handler.cc
index 490143f710..8008fe9146 100644
--- a/third_party/blink/renderer/modules/webaudio/analyser_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/analyser_handler.cc
@@ -14,8 +14,8 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kDefaultNumberOfInputChannels = 2;
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfInputChannels2 = 2;
+constexpr unsigned kDefaultNumberOfOutputChannels2 = 1;
 
 }  // namespace
 
@@ -24,8 +24,8 @@ AnalyserHandler::AnalyserHandler(AudioNode& node, float sample_rate)
       analyser_(
           node.context()->GetDeferredTaskHandler().RenderQuantumFrames()) {
   AddInput();
-  channel_count_ = kDefaultNumberOfInputChannels;
-  AddOutput(kDefaultNumberOfOutputChannels);
+  channel_count_ = kDefaultNumberOfInputChannels2;
+  AddOutput(kDefaultNumberOfOutputChannels2);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc
index c2dd0776b3..645ad54f89 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_buffer_source_handler.cc
@@ -32,7 +32,7 @@ constexpr double kMaxRate = 1024.0;
 
 // Default to mono. A call to setBuffer() will set the number of output
 // channels to that of the buffer.
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfOutputChannelsABSH = 1;
 
 }  // namespace
 
@@ -47,7 +47,7 @@ AudioBufferSourceHandler::AudioBufferSourceHandler(
       playback_rate_(&playback_rate),
       detune_(&detune),
       grain_duration_(kDefaultGrainDuration) {
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsABSH);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
index 903e8172d7..ea98165859 100644
--- a/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/audio_worklet_handler.cc
@@ -35,7 +35,7 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfOutputChannels_QWH = 1;
 
 }  // namespace
 
@@ -69,7 +69,7 @@ AudioWorkletHandler::AudioWorkletHandler(
   for (unsigned i = 0; i < options->numberOfOutputs(); ++i) {
     // If `options->outputChannelCount` unspecified, all outputs are mono.
     AddOutput(is_output_channel_count_given_ ? options->outputChannelCount()[i]
-                                             : kDefaultNumberOfOutputChannels);
+                                             : kDefaultNumberOfOutputChannels_QWH);
   }
   // Same for the outputs as well.
   outputs_.ReserveInitialCapacity(options->numberOfOutputs());
diff --git a/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc b/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc
index 79aff99e16..11dedaaf74 100644
--- a/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/biquad_filter_node.cc
@@ -43,7 +43,7 @@ constexpr float kMinFrequencyValue = 0.0f;
 constexpr double kDefaultQValue = 1.0;
 constexpr double kDefaultGainValue = 0.0;
 constexpr float kMinGainValue = std::numeric_limits<float>::lowest();
-constexpr double kDefaultDetuneValue = 0.0;
+constexpr double kDefaultDetuneValueBFN = 0.0;
 
 }  // namespace
 
@@ -77,7 +77,7 @@ BiquadFilterNode::BiquadFilterNode(BaseAudioContext& context)
           context,
           Uuid(),
           AudioParamHandler::kParamTypeBiquadFilterDetune,
-          kDefaultDetuneValue,
+          kDefaultDetuneValueBFN,
           AudioParamHandler::AutomationRate::kAudio,
           AudioParamHandler::AutomationRateMode::kVariable,
           /*min_value=*/-1200 * log2f(std::numeric_limits<float>::max()),
diff --git a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
index e346f5c004..e20500c75f 100644
--- a/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/constant_source_handler.cc
@@ -13,7 +13,7 @@ namespace blink {
 namespace {
 
 // A ConstantSource is always mono.
-constexpr unsigned kNumberOfOutputChannels = 1;
+constexpr unsigned kNumberOfOutputChannelsCSH = 1;
 
 }  // namespace
 
@@ -23,7 +23,7 @@ ConstantSourceHandler::ConstantSourceHandler(AudioNode& node,
     : AudioScheduledSourceHandler(kNodeTypeConstantSource, node, sample_rate),
       offset_(&offset),
       sample_accurate_values_(GetDeferredTaskHandler().RenderQuantumFrames()) {
-  AddOutput(kNumberOfOutputChannels);
+  AddOutput(kNumberOfOutputChannelsCSH);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/convolver_handler.cc b/third_party/blink/renderer/modules/webaudio/convolver_handler.cc
index 57c70161ab..15065e45f8 100644
--- a/third_party/blink/renderer/modules/webaudio/convolver_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/convolver_handler.cc
@@ -31,14 +31,14 @@ namespace {
 constexpr unsigned kMaxFftSize = 32768;
 
 constexpr unsigned kDefaultNumberOfInputChannels = 2;
-constexpr unsigned kDefaultNumberOfOutputChannels = 1;
+constexpr unsigned kDefaultNumberOfOutputChannelsCH = 1;
 
 }  // namespace
 
 ConvolverHandler::ConvolverHandler(AudioNode& node, float sample_rate)
     : AudioHandler(kNodeTypeConvolver, node, sample_rate) {
   AddInput();
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsCH);
 
   // Node-specific default mixing rules.
   channel_count_ = kDefaultNumberOfInputChannels;
diff --git a/third_party/blink/renderer/modules/webaudio/delay_handler.cc b/third_party/blink/renderer/modules/webaudio/delay_handler.cc
index ff3a2ffac5..15d63e01e8 100644
--- a/third_party/blink/renderer/modules/webaudio/delay_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/delay_handler.cc
@@ -14,8 +14,8 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kNumberOfOutputs = 1;
-constexpr unsigned kDefaultNumberOfChannels = 1;
+constexpr unsigned kNumberOfOutputsDH = 1;
+constexpr unsigned kDefaultNumberOfChannelsDH = 1;
 
 }  // namespace
 
@@ -36,14 +36,14 @@ DelayHandler::DelayHandler(AudioNode& node,
                            AudioParamHandler& delay_time,
                            double max_delay_time)
     : AudioHandler(kNodeTypeDelay, node, sample_rate),
-      number_of_channels_(kDefaultNumberOfChannels),
+      number_of_channels_(kDefaultNumberOfChannelsDH),
       sample_rate_(sample_rate),
       render_quantum_frames_(
           node.context()->GetDeferredTaskHandler().RenderQuantumFrames()),
       delay_time_(&delay_time),
       max_delay_time_(max_delay_time) {
   AddInput();
-  AddOutput(kNumberOfOutputs);
+  AddOutput(kNumberOfOutputsDH);
   Initialize();
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc b/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc
index 34324aa275..ddf351a127 100644
--- a/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/dynamics_compressor_handler.cc
@@ -19,7 +19,7 @@ namespace blink {
 namespace {
 
 // Set output to stereo by default.
-constexpr unsigned kDefaultNumberOfOutputChannels = 2;
+constexpr unsigned kDefaultNumberOfOutputChannelsDCH = 2;
 
 }  // namespace
 
@@ -39,7 +39,7 @@ DynamicsCompressorHandler::DynamicsCompressorHandler(
       attack_(&attack),
       release_(&release) {
   AddInput();
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsDCH);
 
   SetInternalChannelCountMode(kClampedMax);
 
@@ -116,7 +116,7 @@ void DynamicsCompressorHandler::Initialize() {
 
   AudioHandler::Initialize();
   dynamics_compressor_ = std::make_unique<DynamicsCompressor>(
-      Context()->sampleRate(), kDefaultNumberOfOutputChannels);
+      Context()->sampleRate(), kDefaultNumberOfOutputChannelsDCH);
 }
 
 bool DynamicsCompressorHandler::RequiresTailProcessing() const {
diff --git a/third_party/blink/renderer/modules/webaudio/gain_handler.cc b/third_party/blink/renderer/modules/webaudio/gain_handler.cc
index e1d0230960..79914092d7 100644
--- a/third_party/blink/renderer/modules/webaudio/gain_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/gain_handler.cc
@@ -13,7 +13,7 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kNumberOfOutputChannels = 1;
+constexpr unsigned kNumberOfOutputChannelsGH = 1;
 
 }  // namespace
 
@@ -25,7 +25,7 @@ GainHandler::GainHandler(AudioNode& node,
       sample_accurate_gain_values_(
           GetDeferredTaskHandler().RenderQuantumFrames()) {
   AddInput();
-  AddOutput(kNumberOfOutputChannels);
+  AddOutput(kNumberOfOutputChannelsGH);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
index fc982fa3e2..357ef5314e 100644
--- a/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/iir_filter_handler.cc
@@ -18,7 +18,7 @@ namespace blink {
 
 namespace {
 
-constexpr uint32_t kNumberOfChannels = 1;
+constexpr uint32_t kNumberOfChannelsIFH = 1;
 
 }  // namespace
 
@@ -33,7 +33,7 @@ IIRFilterHandler::IIRFilterHandler(AudioNode& node,
           sample_rate,
           std::make_unique<IIRProcessor>(
               sample_rate,
-              kNumberOfChannels,
+              kNumberOfChannelsIFH,
               node.context()->GetDeferredTaskHandler().RenderQuantumFrames(),
               feedforward_coef,
               feedback_coef,
diff --git a/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc b/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc
index cae58d3293..9d748d711c 100644
--- a/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/media_element_audio_source_handler.cc
@@ -27,7 +27,7 @@ namespace {
 
 // Default to stereo. This could change depending on what the media element
 // .src is set to.
-constexpr unsigned kDefaultNumberOfOutputChannels = 2;
+constexpr unsigned kDefaultNumberOfOutputChannelsMEASH = 2;
 
 }  // namespace
 
@@ -61,7 +61,7 @@ MediaElementAudioSourceHandler::MediaElementAudioSourceHandler(
       media_element_(media_element) {
   DCHECK(IsMainThread());
 
-  AddOutput(kDefaultNumberOfOutputChannels);
+  AddOutput(kDefaultNumberOfOutputChannelsMEASH);
 
   if (Context()->GetExecutionContext()) {
     task_runner_ = Context()->GetExecutionContext()->GetTaskRunner(
diff --git a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
index 54b27cac8b..5a8d09f8b4 100644
--- a/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/oscillator_handler.cc
@@ -27,7 +27,7 @@ namespace blink {
 namespace {
 
 // An oscillator is always mono.
-constexpr unsigned kNumberOfOutputChannels = 1;
+constexpr unsigned kNumberOfOutputChannelsOH = 1;
 
 // Convert the detune value (in cents) to a frequency scale multiplier:
 // 2^(d/1200)
@@ -185,7 +185,7 @@ OscillatorHandler::OscillatorHandler(AudioNode& node,
     }
   }
 
-  AddOutput(kNumberOfOutputChannels);
+  AddOutput(kNumberOfOutputChannelsOH);
 
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc b/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc
index 92fad010f1..6e27beff39 100644
--- a/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc
+++ b/third_party/blink/renderer/modules/webaudio/realtime_audio_worklet_thread.cc
@@ -16,11 +16,11 @@ namespace {
 
 // Use for ref-counting of all RealtimeAudioWorkletThread instances in a
 // process. Incremented by the constructor and decremented by destructor.
-int ref_count = 0;
+int ref_count_RAWT = 0;
 
-void EnsureSharedBackingThread(const ThreadCreationParams& params) {
+void EnsureSharedBackingThread_RAWT(const ThreadCreationParams& params) {
   DCHECK(IsMainThread());
-  DCHECK_EQ(ref_count, 1);
+  DCHECK_EQ(ref_count_RAWT, 1);
   WorkletThreadHolder<RealtimeAudioWorkletThread>::EnsureInstance(params);
 }
 
@@ -54,15 +54,15 @@ RealtimeAudioWorkletThread::RealtimeAudioWorkletThread(
                  "RealtimeAudioWorkletThread() - kNormal");
   }
 
-  if (++ref_count == 1) {
-    EnsureSharedBackingThread(params);
+  if (++ref_count_RAWT == 1) {
+    EnsureSharedBackingThread_RAWT(params);
   }
 }
 
 RealtimeAudioWorkletThread::~RealtimeAudioWorkletThread() {
   DCHECK(IsMainThread());
-  DCHECK_GT(ref_count, 0);
-  if (--ref_count == 0) {
+  DCHECK_GT(ref_count_RAWT, 0);
+  if (--ref_count_RAWT == 0) {
     ClearSharedBackingThread();
   }
 }
@@ -74,7 +74,7 @@ WorkerBackingThread& RealtimeAudioWorkletThread::GetWorkerBackingThread() {
 
 void RealtimeAudioWorkletThread::ClearSharedBackingThread() {
   DCHECK(IsMainThread());
-  CHECK_EQ(ref_count, 0);
+  CHECK_EQ(ref_count_RAWT, 0);
   WorkletThreadHolder<RealtimeAudioWorkletThread>::ClearInstance();
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc b/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc
index 6fdc6a038f..5357fcd15f 100644
--- a/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc
+++ b/third_party/blink/renderer/modules/webaudio/semi_realtime_audio_worklet_thread.cc
@@ -16,11 +16,11 @@ namespace {
 
 // Use for ref-counting of all SemiRealtimeAudioWorkletThread instances in a
 // process. Incremented by the constructor and decremented by destructor.
-int ref_count = 0;
+int ref_count_SRAWT = 0;
 
-void EnsureSharedBackingThread(const ThreadCreationParams& params) {
+void EnsureSharedBackingThreadSRAWT(const ThreadCreationParams& params) {
   DCHECK(IsMainThread());
-  DCHECK_EQ(ref_count, 1);
+  DCHECK_EQ(ref_count_SRAWT, 1);
   WorkletThreadHolder<SemiRealtimeAudioWorkletThread>::EnsureInstance(params);
 }
 
@@ -49,15 +49,15 @@ SemiRealtimeAudioWorkletThread::SemiRealtimeAudioWorkletThread(
     params.base_thread_type = base::ThreadType::kDefault;
   }
 
-  if (++ref_count == 1) {
-    EnsureSharedBackingThread(params);
+  if (++ref_count_SRAWT == 1) {
+    EnsureSharedBackingThreadSRAWT(params);
   }
 }
 
 SemiRealtimeAudioWorkletThread::~SemiRealtimeAudioWorkletThread() {
   DCHECK(IsMainThread());
-  DCHECK_GT(ref_count, 0);
-  if (--ref_count == 0) {
+  DCHECK_GT(ref_count_SRAWT, 0);
+  if (--ref_count_SRAWT == 0) {
     ClearSharedBackingThread();
   }
 }
@@ -69,7 +69,7 @@ WorkerBackingThread& SemiRealtimeAudioWorkletThread::GetWorkerBackingThread() {
 
 void SemiRealtimeAudioWorkletThread::ClearSharedBackingThread() {
   DCHECK(IsMainThread());
-  CHECK_EQ(ref_count, 0);
+  CHECK_EQ(ref_count_SRAWT, 0);
   WorkletThreadHolder<SemiRealtimeAudioWorkletThread>::ClearInstance();
 }
 
diff --git a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
index 2c199fb02c..2f4b24a1c7 100644
--- a/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/stereo_panner_handler.cc
@@ -20,8 +20,8 @@ namespace blink {
 namespace {
 
 // A PannerNode only supports 1 or 2 channels
-constexpr unsigned kMinimumOutputChannels = 1;
-constexpr unsigned kMaximumOutputChannels = 2;
+constexpr unsigned kMinimumOutputChannels_SPH = 1;
+constexpr unsigned kMaximumOutputChannels_SPH = 2;
 
 }  // namespace
 
@@ -33,11 +33,11 @@ StereoPannerHandler::StereoPannerHandler(AudioNode& node,
       sample_accurate_pan_values_(
           GetDeferredTaskHandler().RenderQuantumFrames()) {
   AddInput();
-  AddOutput(kMaximumOutputChannels);
+  AddOutput(kMaximumOutputChannels_SPH);
 
   // The node-specific default mixing rules declare that StereoPannerNode
   // can handle mono to stereo and stereo to stereo conversion.
-  channel_count_ = kMaximumOutputChannels;
+  channel_count_ = kMaximumOutputChannels_SPH;
   SetInternalChannelCountMode(kClampedMax);
   SetInternalChannelInterpretation(AudioBus::kSpeakers);
 
@@ -112,8 +112,8 @@ void StereoPannerHandler::SetChannelCount(unsigned channel_count,
   DCHECK(IsMainThread());
   BaseAudioContext::GraphAutoLocker locker(Context());
 
-  if (channel_count >= kMinimumOutputChannels &&
-      channel_count <= kMaximumOutputChannels) {
+  if (channel_count >= kMinimumOutputChannels_SPH &&
+      channel_count <= kMaximumOutputChannels_SPH) {
     if (channel_count_ != channel_count) {
       channel_count_ = channel_count;
       if (InternalChannelCountMode() != kMax) {
@@ -124,8 +124,8 @@ void StereoPannerHandler::SetChannelCount(unsigned channel_count,
     exception_state.ThrowDOMException(
         DOMExceptionCode::kNotSupportedError,
         ExceptionMessages::IndexOutsideRange<uint32_t>(
-            "channelCount", channel_count, kMinimumOutputChannels,
-            ExceptionMessages::kInclusiveBound, kMaximumOutputChannels,
+            "channelCount", channel_count, kMinimumOutputChannels_SPH,
+            ExceptionMessages::kInclusiveBound, kMaximumOutputChannels_SPH,
             ExceptionMessages::kInclusiveBound));
   }
 }
diff --git a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
index 7611400063..b341934b62 100644
--- a/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/wave_shaper_handler.cc
@@ -14,7 +14,7 @@ namespace blink {
 
 namespace {
 
-constexpr unsigned kNumberOfChannels = 1;
+constexpr unsigned kNumberOfChannelsWSH = 1;
 
 }  // namespace
 
@@ -25,7 +25,7 @@ WaveShaperHandler::WaveShaperHandler(AudioNode& node, float sample_rate)
           sample_rate,
           std::make_unique<WaveShaperProcessor>(
               sample_rate,
-              kNumberOfChannels,
+              kNumberOfChannelsWSH,
               node.context()->GetDeferredTaskHandler().RenderQuantumFrames())) {
   Initialize();
 }
diff --git a/third_party/blink/renderer/modules/webcodecs/BUILD.gn b/third_party/blink/renderer/modules/webcodecs/BUILD.gn
index 61f1f00c7b..1ad082fe72 100644
--- a/third_party/blink/renderer/modules/webcodecs/BUILD.gn
+++ b/third_party/blink/renderer/modules/webcodecs/BUILD.gn
@@ -95,6 +95,11 @@ blink_modules_sources("webcodecs") {
     "webcodecs_logger.cc",
     "webcodecs_logger.h",
   ]
+  jumbo_excluded_sources = [
+    "video_decoder_broker.cc",
+    "video_encoder.cc",
+    "video_frame.cc",
+  ]
   deps = [
     "//build:chromeos_buildflags",
     "//media",
diff --git a/third_party/blink/renderer/modules/webcodecs/decoder_template.cc b/third_party/blink/renderer/modules/webcodecs/decoder_template.cc
index 1966646a1b..906e511dd6 100644
--- a/third_party/blink/renderer/modules/webcodecs/decoder_template.cc
+++ b/third_party/blink/renderer/modules/webcodecs/decoder_template.cc
@@ -49,7 +49,7 @@
 namespace blink {
 
 namespace {
-constexpr const char kCategory[] = "media";
+constexpr const char kCategory2[] = "media";
 
 base::AtomicSequenceNumber g_sequence_num_for_counters;
 }  // namespace
@@ -503,7 +503,7 @@ void DecoderTemplate<Traits>::Shutdown(DOMException* exception) {
   if (IsClosed())
     return;
 
-  TRACE_EVENT1(kCategory, GetTraceNames()->shutdown.c_str(), "has_exception",
+  TRACE_EVENT1(kCategory2, GetTraceNames()->shutdown.c_str(), "has_exception",
                !!exception);
 
   shutting_down_ = true;
@@ -554,7 +554,7 @@ void DecoderTemplate<Traits>::Shutdown(DOMException* exception) {
   }
 
   bool trace_enabled = false;
-  TRACE_EVENT_CATEGORY_GROUP_ENABLED(kCategory, &trace_enabled);
+  TRACE_EVENT_CATEGORY_GROUP_ENABLED(kCategory2, &trace_enabled);
   if (trace_enabled) {
     for (auto& pending_decode : pending_decodes_)
       pending_decode.value->decode_trace.reset();
@@ -752,12 +752,12 @@ void DecoderTemplate<Traits>::OnOutput(uint32_t reset_generation,
 
   OutputType* blink_output = std::move(output_or_error).value();
 
-  TRACE_EVENT_BEGIN1(kCategory, GetTraceNames()->output.c_str(), "timestamp",
+  TRACE_EVENT_BEGIN1(kCategory2, GetTraceNames()->output.c_str(), "timestamp",
                      blink_output->timestamp());
 
   output_cb_->InvokeAndReportException(nullptr, blink_output);
 
-  TRACE_EVENT_END0(kCategory, GetTraceNames()->output.c_str());
+  TRACE_EVENT_END0(kCategory2, GetTraceNames()->output.c_str());
 
   MarkCodecActive();
 }
@@ -765,7 +765,7 @@ void DecoderTemplate<Traits>::OnOutput(uint32_t reset_generation,
 template <typename Traits>
 void DecoderTemplate<Traits>::TraceQueueSizes() const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  TRACE_COUNTER_ID2(kCategory, GetTraceNames()->requests_counter.c_str(),
+  TRACE_COUNTER_ID2(kCategory2, GetTraceNames()->requests_counter.c_str(),
                     trace_counter_id_, "decodes", num_pending_decodes_, "other",
                     requests_.size() - num_pending_decodes_);
 }
@@ -825,7 +825,7 @@ void DecoderTemplate<Traits>::Trace(Visitor* visitor) const {
 
 template <typename Traits>
 void DecoderTemplate<Traits>::OnCodecReclaimed(DOMException* exception) {
-  TRACE_EVENT0(kCategory, GetTraceNames()->reclaimed.c_str());
+  TRACE_EVENT0(kCategory2, GetTraceNames()->reclaimed.c_str());
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(is_applying_codec_pressure());
 
@@ -897,7 +897,7 @@ void DecoderTemplate<Traits>::Request::StartTracing() {
   DCHECK(!is_tracing);
   is_tracing = true;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory, TraceNameFromType(), this);
+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory2, TraceNameFromType(), this);
 }
 
 template <typename Traits>
@@ -906,7 +906,7 @@ void DecoderTemplate<Traits>::Request::EndTracing(bool shutting_down) {
   DCHECK(is_tracing);
   is_tracing = false;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory, TraceNameFromType(), this,
+  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory2, TraceNameFromType(), this,
                                   "completed", !shutting_down);
 }
 
diff --git a/third_party/blink/renderer/modules/webcodecs/encoder_base.cc b/third_party/blink/renderer/modules/webcodecs/encoder_base.cc
index 3affa02394..6681a1bab1 100644
--- a/third_party/blink/renderer/modules/webcodecs/encoder_base.cc
+++ b/third_party/blink/renderer/modules/webcodecs/encoder_base.cc
@@ -45,9 +45,9 @@
 namespace blink {
 
 namespace {
-constexpr const char kCategory[] = "media";
+constexpr const char kCategory3[] = "media";
 
-base::AtomicSequenceNumber g_sequence_num_for_counters;
+base::AtomicSequenceNumber g_sequence_num_for_counters2;
 }  // namespace
 
 // static
@@ -67,7 +67,7 @@ EncoderBase<Traits>::EncoderBase(ScriptState* script_state,
                        ExecutionContext::From(script_state)),
       state_(V8CodecState::Enum::kUnconfigured),
       script_state_(script_state),
-      trace_counter_id_(g_sequence_num_for_counters.GetNext()) {
+      trace_counter_id_(g_sequence_num_for_counters2.GetNext()) {
   auto* context = ExecutionContext::From(script_state);
   callback_runner_ = context->GetTaskRunner(TaskType::kInternalMediaRealTime);
 
@@ -200,7 +200,7 @@ void EncoderBase<Traits>::reset(ExceptionState& exception_state) {
   if (ThrowIfCodecStateClosed(state_, "reset", exception_state))
     return;
 
-  TRACE_EVENT0(kCategory, GetTraceNames()->reset.c_str());
+  TRACE_EVENT0(kCategory3, GetTraceNames()->reset.c_str());
 
   state_ = V8CodecState(V8CodecState::Enum::kUnconfigured);
   ResetInternal(MakeGarbageCollected<DOMException>(
@@ -258,7 +258,7 @@ void EncoderBase<Traits>::HandleError(DOMException* ex) {
   if (state_.AsEnum() == V8CodecState::Enum::kClosed)
     return;
 
-  TRACE_EVENT0(kCategory, GetTraceNames()->handle_error.c_str());
+  TRACE_EVENT0(kCategory3, GetTraceNames()->handle_error.c_str());
 
   // Save a temp before we clear the callback.
   V8WebCodecsErrorCallback* error_callback = error_callback_.Get();
@@ -374,7 +374,7 @@ void EncoderBase<Traits>::ProcessFlush(Request* request) {
 
 template <typename Traits>
 void EncoderBase<Traits>::OnCodecReclaimed(DOMException* exception) {
-  TRACE_EVENT0(kCategory, GetTraceNames()->reclaimed.c_str());
+  TRACE_EVENT0(kCategory3, GetTraceNames()->reclaimed.c_str());
   DCHECK_EQ(state_.AsEnum(), V8CodecState::Enum::kConfigured);
   HandleError(exception);
 }
@@ -394,7 +394,7 @@ bool EncoderBase<Traits>::HasPendingActivity() const {
 
 template <typename Traits>
 void EncoderBase<Traits>::TraceQueueSizes() const {
-  TRACE_COUNTER_ID2(kCategory, GetTraceNames()->requests_counter.c_str(),
+  TRACE_COUNTER_ID2(kCategory3, GetTraceNames()->requests_counter.c_str(),
                     trace_counter_id_, "encodes", requested_encodes_, "other",
                     requests_.size() - requested_encodes_);
 }
@@ -478,7 +478,7 @@ void EncoderBase<Traits>::Request::StartTracingVideoEncode(
   DCHECK(!is_tracing);
   is_tracing = true;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(kCategory, TraceNameFromType(), this,
+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(kCategory3, TraceNameFromType(), this,
                                     "key_frame", is_keyframe, "timestamp",
                                     timestamp);
 }
@@ -489,7 +489,7 @@ void EncoderBase<Traits>::Request::StartTracing() {
   DCHECK(!is_tracing);
   is_tracing = true;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory, TraceNameFromType(), this);
+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(kCategory3, TraceNameFromType(), this);
 }
 
 template <typename Traits>
@@ -498,7 +498,7 @@ void EncoderBase<Traits>::Request::EndTracing(bool aborted) {
   DCHECK(is_tracing);
   is_tracing = false;
 #endif
-  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory, TraceNameFromType(), this,
+  TRACE_EVENT_NESTABLE_ASYNC_END1(kCategory3, TraceNameFromType(), this,
                                   "aborted", aborted);
 }
 
diff --git a/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc b/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc
index e829dea84d..8cf583fc5e 100644
--- a/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc
+++ b/third_party/blink/renderer/modules/webcodecs/gpu_factories_retriever.cc
@@ -20,14 +20,14 @@ MainThreadTaskRunnerRestricted AccessMainThreadForGpuFactories() {
 
 namespace {
 
-media::GpuVideoAcceleratorFactories* GetGpuFactoriesOnMainThread() {
+media::GpuVideoAcceleratorFactories* GetGpuFactoriesOnMainThread2() {
   DCHECK(IsMainThread());
   return Platform::Current()->GetGpuFactories();
 }
 
 void RetrieveGpuFactories(OutputCB result_callback) {
   if (IsMainThread()) {
-    std::move(result_callback).Run(GetGpuFactoriesOnMainThread());
+    std::move(result_callback).Run(GetGpuFactoriesOnMainThread2());
     return;
   }
 
@@ -36,7 +36,7 @@ void RetrieveGpuFactories(OutputCB result_callback) {
       ->PostTaskAndReplyWithResult(
           FROM_HERE,
           ConvertToBaseOnceCallback(
-              CrossThreadBindOnce(&GetGpuFactoriesOnMainThread)),
+              CrossThreadBindOnce(&GetGpuFactoriesOnMainThread2)),
           ConvertToBaseOnceCallback(std::move(result_callback)));
 }
 
diff --git a/third_party/blink/renderer/modules/webgpu/BUILD.gn b/third_party/blink/renderer/modules/webgpu/BUILD.gn
index 560fe37907..73d1c568f0 100644
--- a/third_party/blink/renderer/modules/webgpu/BUILD.gn
+++ b/third_party/blink/renderer/modules/webgpu/BUILD.gn
@@ -102,6 +102,8 @@ blink_modules_sources("webgpu") {
     "wgsl_language_features.cc",
     "wgsl_language_features.h",
   ]
+  jumbo_excluded_sources = [ "dawn_enum_conversions.cc" ]
+
   deps = [
     "//gpu/command_buffer/client:webgpu_interface",
     "//services/metrics/public/cpp:ukm_builders",
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 7257742d5c..9443e7ed3b 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1606,6 +1606,14 @@ jumbo_component("platform") {
     ]
   }
 
+  jumbo_excluded_sources = [
+    "bindings/parkable_string_manager.cc",
+    "mediastream/media_stream_audio_source.cc",
+    "mediastream/media_stream_audio_track.cc",
+    "peerconnection/rtc_video_decoder_adapter.cc",
+    "peerconnection/rtc_video_decoder_factory.cc",
+  ]
+
   if (is_mac) {
     sources += [
       "audio/mac/fft_frame_mac.cc",
diff --git a/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc b/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
index dfbf83fbfa..b9c4fa7749 100644
--- a/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
+++ b/third_party/blink/renderer/platform/audio/cpu/x86/delay_sse2.cc
@@ -4,7 +4,9 @@
 
 #include "third_party/blink/renderer/platform/audio/delay.h"
 
+#include <emmintrin.h>
 #include <xmmintrin.h>
+#include <tuple>
 
 namespace blink {
 
diff --git a/third_party/blink/renderer/platform/audio/hrtf_elevation.cc b/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
index f602d078ae..93ea184d82 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_elevation.cc
@@ -51,11 +51,11 @@ constexpr unsigned kNumberOfRawAzimuths = 360 / kAzimuthSpacing;
 
 // Interpolates by this factor to get the total number of azimuths from every
 // azimuth loaded from resource.
-constexpr unsigned kInterpolationFactor = 8;
+constexpr unsigned kInterpolationFactorHE = 8;
 
 // Total number of azimuths after interpolation.
 constexpr unsigned kNumberOfTotalAzimuths =
-    kNumberOfRawAzimuths * kInterpolationFactor;
+    kNumberOfRawAzimuths * kInterpolationFactorHE;
 
 // Total number of components of an HRTF database.
 constexpr size_t kTotalNumberOfResponses = 240;
@@ -263,18 +263,18 @@ std::unique_ptr<HRTFElevation> HRTFElevation::CreateForSubject(
       return nullptr;
     }
 
-    interpolated_index += kInterpolationFactor;
+    interpolated_index += kInterpolationFactorHE;
   }
 
   // Now go back and interpolate intermediate azimuth values.
-  for (unsigned i = 0; i < kNumberOfTotalAzimuths; i += kInterpolationFactor) {
-    int j = (i + kInterpolationFactor) % kNumberOfTotalAzimuths;
+  for (unsigned i = 0; i < kNumberOfTotalAzimuths; i += kInterpolationFactorHE) {
+    int j = (i + kInterpolationFactorHE) % kNumberOfTotalAzimuths;
 
     // Create the interpolated convolution kernels and delays.
-    for (unsigned jj = 1; jj < kInterpolationFactor; ++jj) {
+    for (unsigned jj = 1; jj < kInterpolationFactorHE; ++jj) {
       float x =
           static_cast<float>(jj) /
-          static_cast<float>(kInterpolationFactor);  // interpolate from 0 -> 1
+          static_cast<float>(kInterpolationFactorHE);  // interpolate from 0 -> 1
 
       (*kernel_list_l)[i + jj] = HRTFKernel::CreateInterpolatedKernel(
           kernel_list_l->at(i).get(), kernel_list_l->at(j).get(), x);
diff --git a/third_party/blink/renderer/platform/audio/hrtf_panner.cc b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
index 3402d147d7..f94d433bd1 100644
--- a/third_party/blink/renderer/platform/audio/hrtf_panner.cc
+++ b/third_party/blink/renderer/platform/audio/hrtf_panner.cc
@@ -40,7 +40,7 @@ namespace {
 // The value of 2 milliseconds is larger than the largest delay which exists in
 // any HRTFKernel from the default HRTFDatabase (0.0136 seconds).
 // We ASSERT the delay values used in process() with this value.
-constexpr double kMaxDelayTimeSeconds = 0.002;
+constexpr double kMaxDelayTimeSeconds2 = 0.002;
 
 constexpr int kUninitializedAzimuth = -1;
 
@@ -85,8 +85,8 @@ HRTFPanner::HRTFPanner(float sample_rate,
       convolver_r1_(FftSizeForSampleRate(sample_rate)),
       convolver_l2_(FftSizeForSampleRate(sample_rate)),
       convolver_r2_(FftSizeForSampleRate(sample_rate)),
-      delay_line_l_(kMaxDelayTimeSeconds, sample_rate, render_quantum_frames),
-      delay_line_r_(kMaxDelayTimeSeconds, sample_rate, render_quantum_frames),
+      delay_line_l_(kMaxDelayTimeSeconds2, sample_rate, render_quantum_frames),
+      delay_line_r_(kMaxDelayTimeSeconds2, sample_rate, render_quantum_frames),
       temp_l1_(render_quantum_frames),
       temp_r1_(render_quantum_frames),
       temp_l2_(render_quantum_frames),
@@ -253,10 +253,10 @@ void HRTFPanner::Pan(double desired_azimuth,
     DCHECK(kernel_r1);
     DCHECK(kernel_l2);
     DCHECK(kernel_r2);
-    DCHECK_LT(frame_delay_l1 / SampleRate(), kMaxDelayTimeSeconds);
-    DCHECK_LT(frame_delay_r1 / SampleRate(), kMaxDelayTimeSeconds);
-    DCHECK_LT(frame_delay_l2 / SampleRate(), kMaxDelayTimeSeconds);
-    DCHECK_LT(frame_delay_r2 / SampleRate(), kMaxDelayTimeSeconds);
+    DCHECK_LT(frame_delay_l1 / SampleRate(), kMaxDelayTimeSeconds2);
+    DCHECK_LT(frame_delay_r1 / SampleRate(), kMaxDelayTimeSeconds2);
+    DCHECK_LT(frame_delay_l2 / SampleRate(), kMaxDelayTimeSeconds2);
+    DCHECK_LT(frame_delay_r2 / SampleRate(), kMaxDelayTimeSeconds2);
 
     // Crossfade inter-aural delays based on transitions.
     const double frame_delay_l =
@@ -369,7 +369,7 @@ double HRTFPanner::TailTime() const {
   // the tailTime of the HRTFPanner is the sum of the tailTime of the
   // DelayKernel and the tailTime of the FFTConvolver, which is
   // MaxDelayTimeSeconds and fftSize() / 2, respectively.
-  return kMaxDelayTimeSeconds +
+  return kMaxDelayTimeSeconds2 +
          (FftSize() / 2) / static_cast<double>(SampleRate());
 }
 
diff --git a/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.cc b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.cc
index 7529dbef9a..2232743c74 100644
--- a/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.cc
+++ b/third_party/blink/renderer/platform/fonts/opentype/open_type_math_support.cc
@@ -16,7 +16,7 @@
 
 namespace {
 // HarfBuzz' hb_position_t is a 16.16 fixed-point value.
-float HarfBuzzUnitsToFloat(hb_position_t value) {
+float HarfBuzzUnitsToFloatOTMS(hb_position_t value) {
   static const float kFloatToHbRatio = 1.0f / (1 << 16);
   return kFloatToHbRatio * value;
 }
@@ -119,7 +119,7 @@ absl::optional<float> OpenTypeMathSupport::MathConstant(
     case kRadicalExtraAscender:
     case kRadicalKernBeforeDegree:
     case kRadicalKernAfterDegree:
-      return absl::optional<float>(HarfBuzzUnitsToFloat(harfbuzz_value));
+      return absl::optional<float>(HarfBuzzUnitsToFloatOTMS(harfbuzz_value));
     default:
       NOTREACHED();
   }
@@ -135,7 +135,7 @@ absl::optional<float> OpenTypeMathSupport::MathItalicCorrection(
 
   hb_font_t* const font = harfbuzz_face->GetScaledFont();
 
-  return absl::optional<float>(HarfBuzzUnitsToFloat(
+  return absl::optional<float>(HarfBuzzUnitsToFloatOTMS(
       hb_ot_math_get_glyph_italics_correction(font, glyph)));
 }
 
@@ -228,9 +228,9 @@ OpenTypeMathSupport::GetGlyphPartRecords(
       WTF::BindRepeating([](hb_ot_math_glyph_part_t record)
                              -> OpenTypeMathStretchData::GlyphPartRecord {
         return {static_cast<Glyph>(record.glyph),
-                HarfBuzzUnitsToFloat(record.start_connector_length),
-                HarfBuzzUnitsToFloat(record.end_connector_length),
-                HarfBuzzUnitsToFloat(record.full_advance),
+                HarfBuzzUnitsToFloatOTMS(record.start_connector_length),
+                HarfBuzzUnitsToFloatOTMS(record.end_connector_length),
+                HarfBuzzUnitsToFloatOTMS(record.full_advance),
                 !!(record.flags & HB_MATH_GLYPH_PART_FLAG_EXTENDER)};
       });
   Vector<OpenTypeMathStretchData::GlyphPartRecord> parts =
@@ -247,7 +247,7 @@ OpenTypeMathSupport::GetGlyphPartRecords(
     hb_ot_math_get_glyph_assembly(hb_font, base_glyph,
                                   HarfBuzzDirection(stretch_axis), 0, nullptr,
                                   nullptr, &harfbuzz_italic_correction);
-    *italic_correction = HarfBuzzUnitsToFloat(harfbuzz_italic_correction);
+    *italic_correction = HarfBuzzUnitsToFloatOTMS(harfbuzz_italic_correction);
   }
   return parts;
 }
diff --git a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
index 24c4f3e2ac..1302f077f9 100644
--- a/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
+++ b/third_party/blink/renderer/platform/fonts/shaping/harfbuzz_shaper.cc
@@ -63,11 +63,11 @@ namespace blink {
 
 namespace {
 
-constexpr hb_feature_t CreateFeature(char c1,
-                                     char c2,
-                                     char c3,
-                                     char c4,
-                                     uint32_t value = 0) {
+constexpr hb_feature_t CreateFeature2(char c1,
+                                      char c2,
+                                      char c3,
+                                      char c4,
+                                      uint32_t value = 0) {
   return {HB_TAG(c1, c2, c3, c4), value, 0 /* start */,
           static_cast<unsigned>(-1) /* end */};
 }
@@ -714,12 +714,12 @@ CapsFeatureSettingsScopedOverlay::CapsFeatureSettingsScopedOverlay(
 
 void CapsFeatureSettingsScopedOverlay::OverlayCapsFeatures(
     FontDescription::FontVariantCaps variant_caps) {
-  static constexpr hb_feature_t smcp = CreateFeature('s', 'm', 'c', 'p', 1);
-  static constexpr hb_feature_t pcap = CreateFeature('p', 'c', 'a', 'p', 1);
-  static constexpr hb_feature_t c2sc = CreateFeature('c', '2', 's', 'c', 1);
-  static constexpr hb_feature_t c2pc = CreateFeature('c', '2', 'p', 'c', 1);
-  static constexpr hb_feature_t unic = CreateFeature('u', 'n', 'i', 'c', 1);
-  static constexpr hb_feature_t titl = CreateFeature('t', 'i', 't', 'l', 1);
+  static constexpr hb_feature_t smcp = CreateFeature2('s', 'm', 'c', 'p', 1);
+  static constexpr hb_feature_t pcap = CreateFeature2('p', 'c', 'a', 'p', 1);
+  static constexpr hb_feature_t c2sc = CreateFeature2('c', '2', 's', 'c', 1);
+  static constexpr hb_feature_t c2pc = CreateFeature2('c', '2', 'p', 'c', 1);
+  static constexpr hb_feature_t unic = CreateFeature2('u', 'n', 'i', 'c', 1);
+  static constexpr hb_feature_t titl = CreateFeature2('t', 'i', 't', 'l', 1);
   if (variant_caps == FontDescription::kSmallCaps ||
       variant_caps == FontDescription::kAllSmallCaps) {
     PrependCounting(smcp);
diff --git a/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.cc b/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.cc
index 853ae90388..1890f173f0 100644
--- a/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.cc
+++ b/third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.cc
@@ -376,7 +376,7 @@ void CanvasResourceDispatcher::OnBeginFrame(
     const WTF::HashMap<uint32_t, viz::FrameTimingDetails>&,
     bool frame_ack,
     WTF::Vector<viz::ReturnedResource> resources) {
-  if (features::IsOnBeginFrameAcksEnabled()) {
+  if (::features::IsOnBeginFrameAcksEnabled()) {
     if (frame_ack) {
       DidReceiveCompositorFrameAck(std::move(resources));
     } else if (!resources.empty()) {
diff --git a/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc b/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
index 061e96237a..7df7208f3b 100644
--- a/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
+++ b/third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
@@ -49,6 +49,10 @@
 #include "third_party/skia/include/core/SkColorSpace.h"
 #include "third_party/skia/include/private/SkJpegMetadataDecoder.h"
 
+#if defined(OS_WIN)
+#include <basetsd.h>  // Included before jpeglib.h because of INT32 clash
+#endif                // OS_WIN
+
 extern "C" {
 #include <setjmp.h>
 #include <stdio.h>  // jpeglib.h needs stdio FILE.
diff --git a/third_party/blink/renderer/platform/loader/BUILD.gn b/third_party/blink/renderer/platform/loader/BUILD.gn
index 659fb23c8a..77ea41d5d8 100644
--- a/third_party/blink/renderer/platform/loader/BUILD.gn
+++ b/third_party/blink/renderer/platform/loader/BUILD.gn
@@ -178,6 +178,8 @@ blink_platform_sources("loader") {
   sources +=
       get_target_outputs(":make_platform_loader_generated_delivery_type_names")
 
+  jumbo_excluded_sources = [  "fetch/url_loader/sync_load_context.cc" ]
+
   deps = [
     ":make_platform_loader_generated_delivery_type_names",
     ":make_platform_loader_generated_fetch_initiator_type_names",
diff --git a/third_party/blink/renderer/platform/loader/web_url_request_util.cc b/third_party/blink/renderer/platform/loader/web_url_request_util.cc
index d2246ec79c..ecb9c33fc0 100644
--- a/third_party/blink/renderer/platform/loader/web_url_request_util.cc
+++ b/third_party/blink/renderer/platform/loader/web_url_request_util.cc
@@ -30,6 +30,7 @@
 #include "third_party/blink/public/platform/web_string.h"
 #include "third_party/blink/public/platform/web_url_request.h"
 #include "third_party/blink/renderer/platform/loader/mixed_content.h"
+#include "third_party/blink/renderer/platform/wtf/assertions.h"
 #include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
diff --git a/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc b/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc
index 142fdccf28..3b727c6bbf 100644
--- a/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc
+++ b/third_party/blink/renderer/platform/peerconnection/stats_collecting_decoder.cc
@@ -22,7 +22,7 @@ constexpr base::TimeDelta kCheckSimultaneousDecodersInterval = base::Seconds(5);
 
 // Number of StatsCollectingDecoder instances right now that have started
 // decoding.
-std::atomic_int* GetDecoderCounter() {
+std::atomic_int* GetDecoderCounter2() {
   static std::atomic_int s_counter(0);
   return &s_counter;
 }
@@ -59,7 +59,7 @@ int32_t StatsCollectingDecoder::Decode(const webrtc::EncodedImage& input_image,
   DCHECK_CALLED_ON_VALID_SEQUENCE(decoding_sequence_checker_);
   if (!first_frame_decoded_) {
     first_frame_decoded_ = true;
-    ++(*GetDecoderCounter());
+    ++(*GetDecoderCounter2());
   }
   {
     base::AutoLock auto_lock(lock_);
@@ -92,7 +92,7 @@ int32_t StatsCollectingDecoder::Release() {
   }
 
   if (first_frame_decoded_) {
-    --(*GetDecoderCounter());
+    --(*GetDecoderCounter2());
     first_frame_decoded_ = false;
   }
 
@@ -132,13 +132,13 @@ void StatsCollectingDecoder::Decoded(webrtc::VideoFrame& decodedImage,
   if ((now - last_check_for_simultaneous_decoders_) >
       kCheckSimultaneousDecodersInterval) {
     last_check_for_simultaneous_decoders_ = now;
-    DVLOG(3) << "Simultaneous decoders: " << *GetDecoderCounter();
+    DVLOG(3) << "Simultaneous decoders: " << *GetDecoderCounter2();
     if (active_stats_collection()) {
-      if (*GetDecoderCounter() > kMaximumDecodersToCollectStats) {
+      if (*GetDecoderCounter2() > kMaximumDecodersToCollectStats) {
         // Too many decoders, cancel stats collection.
         ClearStatsCollection();
       }
-    } else if (*GetDecoderCounter() <= kMaximumDecodersToCollectStats) {
+    } else if (*GetDecoderCounter2() <= kMaximumDecodersToCollectStats) {
       // Start up stats collection since there's only a single decoder active.
       StartStatsCollection();
     }
diff --git a/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc b/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc
index 368da11875..7aad7fba36 100644
--- a/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc
+++ b/third_party/blink/renderer/platform/widget/compositing/layer_tree_view.cc
@@ -364,7 +364,7 @@ void LayerTreeView::WillCommit(const cc::CommitState&) {
   if (!delegate_)
     return;
   delegate_->WillCommitCompositorFrame();
-  if (base::FeatureList::IsEnabled(features::kNonBlockingCommit)) {
+  if (base::FeatureList::IsEnabled(::features::kNonBlockingCommit)) {
     widget_scheduler_->DidCommitFrameToCompositor();
   }
 }
@@ -377,7 +377,7 @@ void LayerTreeView::DidCommit(int source_frame_number,
     return;
   }
   delegate_->DidCommitCompositorFrame(commit_start_time, commit_finish_time);
-  if (!base::FeatureList::IsEnabled(features::kNonBlockingCommit)) {
+  if (!base::FeatureList::IsEnabled(::features::kNonBlockingCommit)) {
     widget_scheduler_->DidCommitFrameToCompositor();
   }
 }
diff --git a/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc b/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc
index 29eb158398..f1989a299a 100644
--- a/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc
+++ b/third_party/blink/renderer/platform/widget/input/elastic_overscroll_controller.cc
@@ -69,7 +69,7 @@ ElasticOverscrollController::ElasticOverscrollController(
 std::unique_ptr<ElasticOverscrollController>
 ElasticOverscrollController::Create(cc::ScrollElasticityHelper* helper) {
 #if BUILDFLAG(IS_WIN)
-  return base::FeatureList::IsEnabled(features::kElasticOverscroll)
+  return base::FeatureList::IsEnabled(::features::kElasticOverscroll)
              ? std::make_unique<ElasticOverscrollControllerBezier>(helper)
              : nullptr;
 #else
diff --git a/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc b/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc
index 2987e6ee06..710a2bd491 100644
--- a/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc
+++ b/third_party/blink/renderer/platform/widget/input/widget_base_input_handler.cc
@@ -154,7 +154,7 @@ mojom::InputEventResultState GetAckResult(WebInputEventResult processed) {
   return mojom::InputEventResultState::kConsumed;
 }
 
-bool IsGestureScroll(WebInputEvent::Type type) {
+bool IsGestureScrollWBIH(WebInputEvent::Type type) {
   switch (type) {
     case WebGestureEvent::Type::kGestureScrollBegin:
     case WebGestureEvent::Type::kGestureScrollUpdate:
@@ -548,7 +548,7 @@ void WidgetBaseInputHandler::InjectScrollbarGestureScroll(
     ui::ScrollGranularity granularity,
     cc::ElementId scrollable_area_element_id,
     WebInputEvent::Type injected_type) {
-  DCHECK(IsGestureScroll(injected_type));
+  DCHECK(IsGestureScrollWBIH(injected_type));
   // If we're currently handling an input event, cache the appropriate
   // parameters so we can dispatch the events directly once blink finishes
   // handling the event.
diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 3ca4e89e13..70035220bc 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -235,6 +235,10 @@ jumbo_component("base") {
 
   libs = []
 
+  jumbo_excluded_sources = [
+    "resource/resource_bundle.cc",
+  ]
+
   if (is_android) {
     sources += [
       "device_form_factor_android.cc",
diff --git a/ui/base/ime/win/BUILD.gn b/ui/base/ime/win/BUILD.gn
index 428e205bd0..18db932eea 100644
--- a/ui/base/ime/win/BUILD.gn
+++ b/ui/base/ime/win/BUILD.gn
@@ -30,6 +30,7 @@ jumbo_component("win") {
     "virtual_keyboard_debounce_timer.cc",
     "virtual_keyboard_debounce_timer.h",
   ]
+  jumbo_excluded_sources = [ "tsf_text_store.cc" ]
 
   defines = [ "IS_UI_BASE_IME_WIN_IMPL" ]
 
diff --git a/ui/base/x/BUILD.gn b/ui/base/x/BUILD.gn
index 5f9af7e3cc..5f88f00d2d 100644
--- a/ui/base/x/BUILD.gn
+++ b/ui/base/x/BUILD.gn
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//build/config/linux/gtk/gtk.gni")
 import("//build/config/ozone.gni")
 import("//build/config/ui.gni")
@@ -10,7 +9,7 @@ import("//testing/libfuzzer/fuzzer_test.gni")
 
 assert(ozone_platform_x11)
 
-jumbo_component("x") {
+component("x") {
   output_name = "ui_base_x"
 
   sources = [
diff --git a/ui/color/BUILD.gn b/ui/color/BUILD.gn
index 22f496e123..b5bc1e1f05 100644
--- a/ui/color/BUILD.gn
+++ b/ui/color/BUILD.gn
@@ -4,14 +4,13 @@
 
 import("//build/buildflag_header.gni")
 import("//build/config/chromeos/ui_mode.gni")
-import("//build/config/jumbo.gni")
 import("//mojo/public/tools/bindings/mojom.gni")
 import("//testing/test.gni")
 import("//ui/base/ui_features.gni")
 
 assert(use_blink, "Not supported without use_blink")
 
-jumbo_source_set("color_headers") {
+source_set("color_headers") {
   sources = [
     "color_id.h",
     "color_id_macros.inc",
@@ -33,7 +32,7 @@ jumbo_source_set("color_headers") {
 }
 
 # Keep the deps on this target to a minimum so that chromeos/crosapi can depend on it.
-jumbo_component("color_provider_key") {
+component("color_provider_key") {
   sources = [
     "color_provider_key.cc",
     "color_provider_key.h",
@@ -49,7 +48,7 @@ jumbo_component("color_provider_key") {
   ]
 }
 
-jumbo_component("color") {
+component("color") {
   sources = [
     "color_metrics.cc",
     "color_mixer.cc",
@@ -140,7 +139,7 @@ if (is_win) {
   }
 }
 
-jumbo_component("mixers") {
+component("mixers") {
   sources = [
     "color_mixers.cc",
     "color_mixers.h",
diff --git a/ui/gfx/geometry/transform_operations.cc b/ui/gfx/geometry/transform_operations.cc
index f9c2ee1b15..316b1aa689 100644
--- a/ui/gfx/geometry/transform_operations.cc
+++ b/ui/gfx/geometry/transform_operations.cc
@@ -139,7 +139,7 @@ bool TransformOperations::IsTranslation() const {
   return true;
 }
 
-static SkScalar TanDegrees(double degrees) {
+static SkScalar TanDegrees2(double degrees) {
   return SkDoubleToScalar(std::tan(DegToRad(degrees)));
 }
 
@@ -163,8 +163,8 @@ bool TransformOperations::ScaleComponent(SkScalar* scale) const {
       case TransformOperation::TRANSFORM_OPERATION_SKEWX:
       case TransformOperation::TRANSFORM_OPERATION_SKEWY:
       case TransformOperation::TRANSFORM_OPERATION_SKEW: {
-        SkScalar x_component = TanDegrees(operation.skew.x);
-        SkScalar y_component = TanDegrees(operation.skew.y);
+        SkScalar x_component = TanDegrees2(operation.skew.x);
+        SkScalar y_component = TanDegrees2(operation.skew.y);
         SkScalar x_scale = std::sqrt(x_component * x_component + 1);
         SkScalar y_scale = std::sqrt(y_component * y_component + 1);
         operations_scale *= std::max(x_scale, y_scale);
diff --git a/ui/gl/BUILD.gn b/ui/gl/BUILD.gn
index 9766f2bc72..6cfd2feaa0 100644
--- a/ui/gl/BUILD.gn
+++ b/ui/gl/BUILD.gn
@@ -134,6 +134,10 @@ jumbo_component("gl") {
     "trace_util.h",
   ]
 
+  jumbo_excluded_sources = [
+    "presenter.cc",
+  ]
+
   if (is_android) {
     sources += [
       "android/scoped_a_native_window.cc",
@@ -216,6 +220,10 @@ jumbo_component("gl") {
         "gl_angle_util_vulkan.cc",
         "gl_angle_util_vulkan.h",
       ]
+
+      jumbo_excluded_sources += [
+        "gl_angle_util_vulkan.cc",
+      ]
     }
 
     if (is_android) {
diff --git a/ui/gl/direct_composition_surface_win.cc b/ui/gl/direct_composition_surface_win.cc
index 3ec43c5a48..b763bd1f4a 100644
--- a/ui/gl/direct_composition_surface_win.cc
+++ b/ui/gl/direct_composition_surface_win.cc
@@ -24,7 +24,7 @@ namespace gl {
 
 namespace {
 
-bool SupportsLowLatencyPresentation() {
+bool SupportsLowLatencyPresentation2() {
   return base::FeatureList::IsEnabled(
       features::kDirectCompositionLowLatencyPresentation);
 }
@@ -171,7 +171,7 @@ void DirectCompositionSurfaceWin::SetVSyncEnabled(bool enabled) {
 void DirectCompositionSurfaceWin::OnVSync(base::TimeTicks vsync_time,
                                           base::TimeDelta interval) {
   // Main thread will run vsync callback in low latency presentation mode.
-  if (VSyncCallbackEnabled() && !SupportsLowLatencyPresentation()) {
+  if (VSyncCallbackEnabled() && !SupportsLowLatencyPresentation2()) {
     DCHECK(vsync_callback_);
     vsync_callback_.Run(vsync_time, interval);
   }
@@ -294,7 +294,7 @@ void DirectCompositionSurfaceWin::HandleVSyncOnMainThread(
   last_vsync_interval_ = interval;
 
   CheckPendingFrames();
-  if (SupportsLowLatencyPresentation() && VSyncCallbackEnabled() &&
+  if (SupportsLowLatencyPresentation2() && VSyncCallbackEnabled() &&
       pending_frames_.size() < max_pending_frames_) {
     DCHECK(vsync_callback_);
     vsync_callback_.Run(vsync_time, interval);
diff --git a/ui/native_theme/BUILD.gn b/ui/native_theme/BUILD.gn
index a32f9a4c36..60f431fb5d 100644
--- a/ui/native_theme/BUILD.gn
+++ b/ui/native_theme/BUILD.gn
@@ -2,7 +2,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//testing/test.gni")
 
@@ -23,7 +22,7 @@ component("features") {
   ]
 }
 
-jumbo_component("native_theme") {
+component("native_theme") {
   sources = [
     "caption_style.cc",
     "caption_style.h",
@@ -109,7 +108,7 @@ jumbo_component("native_theme") {
 }
 
 if (is_win) {
-  jumbo_component("native_theme_browser") {
+  component("native_theme_browser") {
     defines = [ "NATIVE_THEME_IMPLEMENTATION" ]
 
     # These files cannot work in the renderer on Windows.
@@ -131,11 +130,11 @@ if (is_win) {
     libs = [ "uxtheme.lib" ]
   }
 } else {
-  jumbo_source_set("native_theme_browser") {
+  source_set("native_theme_browser") {
   }
 }
 
-jumbo_source_set("test_support") {
+source_set("test_support") {
   testonly = true
 
   deps = [
diff --git a/v8/BUILD.gn b/v8/BUILD.gn
index ee5dbe8ba4..e0cfabb3d7 100644
--- a/v8/BUILD.gn
+++ b/v8/BUILD.gn
@@ -4968,6 +4968,9 @@ v8_source_set("v8_compiler_for_mksnapshot_source_set") {
   visibility = [ ":*" ]  # Only targets in this file can depend on this.
 
   sources = v8_compiler_sources
+  jumbo_excluded_sources = [
+    "src/compiler/bytecode-analysis.cc",
+  ]
 
   public_deps = [
     ":generate_bytecode_builtins_list",
@@ -5002,6 +5005,9 @@ v8_source_set("v8_compiler") {
 
   if (v8_enable_turbofan) {
     sources = v8_compiler_sources
+    jumbo_excluded_sources = [
+      "src/compiler/bytecode-analysis.cc",
+    ]
   } else {
     # With Turbofan disabled, we only include the stubbed-out API.
     sources = [ "src/compiler/turbofan-disabled.cc" ]
@@ -5610,6 +5616,8 @@ v8_source_set("v8_base_without_compiler") {
     ]
   }
 
+  jumbo_excluded_sources = []
+
   if (v8_enable_maglev) {
     sources += [
       "src/maglev/maglev-assembler.cc",
@@ -5637,11 +5645,19 @@ v8_source_set("v8_base_without_compiler") {
         "src/maglev/arm64/maglev-assembler-arm64.cc",
         "src/maglev/arm64/maglev-ir-arm64.cc",
       ]
+      jumbo_excluded_sources += [
+        "src/maglev/arm64/maglev-assembler-arm64.cc",
+        "src/maglev/arm64/maglev-ir-arm64.cc",
+      ]
     } else if (v8_current_cpu == "x64") {
       sources += [
         "src/maglev/x64/maglev-assembler-x64.cc",
         "src/maglev/x64/maglev-ir-x64.cc",
       ]
+      jumbo_excluded_sources += [
+        "src/maglev/x64/maglev-assembler-x64.cc",
+        "src/maglev/x64/maglev-ir-x64.cc",
+      ]
     }
   }
 
@@ -5701,6 +5717,13 @@ v8_source_set("v8_base_without_compiler") {
       "src/wasm/wasm-subtyping.cc",
       "src/wasm/well-known-imports.cc",
     ]
+    jumbo_excluded_sources += [
+      "src/asmjs/asm-js.cc",
+      "src/asmjs/asm-parser.cc",
+      "src/asmjs/asm-scanner.cc",
+      "src/wasm/turboshaft-graph-interface.cc",
+      "src/wasm/wasm-module.cc",
+    ]
   }
 
   if (v8_enable_third_party_heap) {
@@ -5730,13 +5753,16 @@ v8_source_set("v8_base_without_compiler") {
     sources += [ "src/heap/reference-summarizer.cc" ]
   }
 
-  jumbo_excluded_sources = [
+  jumbo_excluded_sources += [
+    "src/execution/clobber-registers.cc", # Host asm vs target asm includes
     # TODO(mostynb@vewd.com): don't exclude these http://crbug.com/752428
     "src/profiler/heap-snapshot-generator.cc",  # Macro clash in mman-linux.h
     "src/heap/local-heap.cc",
     "src/heap/safepoint.cc",
     "src/objects/js-display-names.cc",
     "src/objects/js-relative-time-format.cc",
+    "src/objects/js-temporal-objects.cc",
+    "src/utils/ostreams.cc",
 
     # These source files take an unusually large amount of time to
     # compile.  Build them separately to avoid bottlenecks.
diff --git a/v8/src/baseline/arm/baseline-compiler-arm-inl.h b/v8/src/baseline/arm/baseline-compiler-arm-inl.h
index 87861e8250..43ecf166cc 100644
--- a/v8/src/baseline/arm/baseline-compiler-arm-inl.h
+++ b/v8/src/baseline/arm/baseline-compiler-arm-inl.h
@@ -96,6 +96,8 @@ void BaselineCompiler::VerifyFrameSize() {
   __ masm()->Assert(eq, AbortReason::kUnexpectedStackPointer);
 }
 
+#undef __
+
 }  // namespace baseline
 }  // namespace internal
 }  // namespace v8
diff --git a/v8/src/baseline/baseline-compiler.cc b/v8/src/baseline/baseline-compiler.cc
index 30b371264d..8946baff14 100644
--- a/v8/src/baseline/baseline-compiler.cc
+++ b/v8/src/baseline/baseline-compiler.cc
@@ -2407,6 +2407,8 @@ SaveAccumulatorScope::~SaveAccumulatorScope() {
   assembler_->Pop(kInterpreterAccumulatorRegister);
 }
 
+#undef  __
+
 }  // namespace baseline
 }  // namespace internal
 }  // namespace v8
diff --git a/v8/src/compiler/backend/instruction.h b/v8/src/compiler/backend/instruction.h
index b48d3e04a7..3697d50554 100644
--- a/v8/src/compiler/backend/instruction.h
+++ b/v8/src/compiler/backend/instruction.h
@@ -519,9 +519,9 @@ class LocationOperand : public InstructionOperand {
     return static_cast<int64_t>(value_) >> IndexField::kShift;
   }
 
-  Register GetRegister() const {
+  v8::internal::Register GetRegister() const {
     DCHECK(IsRegister());
-    return Register::from_code(register_code());
+    return v8::internal::Register::from_code(register_code());
   }
 
   FloatRegister GetFloatRegister() const {
diff --git a/v8/src/diagnostics/perf-jit.cc b/v8/src/diagnostics/perf-jit.cc
index 3ab0e68a4b..a74b84e70c 100644
--- a/v8/src/diagnostics/perf-jit.cc
+++ b/v8/src/diagnostics/perf-jit.cc
@@ -37,6 +37,8 @@
 #include <sys/mman.h>
 #include <unistd.h>
 
+#undef MAP_TYPE
+
 #include <memory>
 
 #include "src/base/platform/wrappers.h"
diff --git a/v8/src/heap/cppgc-js/unified-heap-marking-verifier.cc b/v8/src/heap/cppgc-js/unified-heap-marking-verifier.cc
index ca4a9183d5..2471878c4c 100644
--- a/v8/src/heap/cppgc-js/unified-heap-marking-verifier.cc
+++ b/v8/src/heap/cppgc-js/unified-heap-marking-verifier.cc
@@ -55,7 +55,7 @@ class UnifiedHeapVerificationVisitor final : public JSVisitor {
 
 }  // namespace
 
-class BasicTracedReferenceExtractor final {
+class BasicTracedReferenceExtractor_UHMV final {
  public:
   static Address* GetObjectSlotForMarking(const TracedReferenceBase& ref) {
     return const_cast<Address*>(
@@ -68,7 +68,7 @@ void UnifiedHeapVerificationState::VerifyMarkedTracedReference(
   // The following code will crash with null pointer derefs when finding a
   // non-empty `TracedReferenceBase` when `CppHeap` is in detached mode.
   Address* traced_handle_location =
-      BasicTracedReferenceExtractor::GetObjectSlotForMarking(ref);
+      BasicTracedReferenceExtractor_UHMV::GetObjectSlotForMarking(ref);
   // We cannot assume that the reference is non-null as we may get here by
   // tracing an ephemeron which doesn't have early bailouts, see
   // `cppgc::Visitor::TraceEphemeron()` for non-Member values.
diff --git a/v8/src/heap/cppgc/marker.cc b/v8/src/heap/cppgc/marker.cc
index 003318ed61..0f1295ac26 100644
--- a/v8/src/heap/cppgc/marker.cc
+++ b/v8/src/heap/cppgc/marker.cc
@@ -56,9 +56,9 @@ bool ExitIncrementalMarkingIfNeeded(MarkingConfig config, HeapBase& heap) {
   return false;
 }
 
-static constexpr size_t kDefaultDeadlineCheckInterval = 150u;
+static constexpr size_t kDefaultMarkerDeadlineCheckInterval = 150u;
 
-template <size_t kDeadlineCheckInterval = kDefaultDeadlineCheckInterval,
+template <size_t kDeadlineCheckInterval = kDefaultMarkerDeadlineCheckInterval,
           typename WorklistLocal, typename Callback>
 bool DrainWorklistWithBytesAndTimeDeadline(BasicMarkingState& marking_state,
                                            size_t marked_bytes_deadline,
@@ -617,7 +617,7 @@ bool MarkerBase::ProcessWorklistsWithDeadline(
     {
       StatsCollector::EnabledScope inner_scope(
           heap().stats_collector(), StatsCollector::kMarkProcessBailOutObjects);
-      if (!DrainWorklistWithBytesAndTimeDeadline<kDefaultDeadlineCheckInterval /
+      if (!DrainWorklistWithBytesAndTimeDeadline<kDefaultMarkerDeadlineCheckInterval /
                                                  5>(
               mutator_marking_state_, SIZE_MAX, time_deadline,
               mutator_marking_state_.concurrent_marking_bailout_worklist(),
diff --git a/v8/src/heap/cppgc/sweeper.cc b/v8/src/heap/cppgc/sweeper.cc
index 91fee124d8..8b25234127 100644
--- a/v8/src/heap/cppgc/sweeper.cc
+++ b/v8/src/heap/cppgc/sweeper.cc
@@ -64,7 +64,7 @@ constexpr const char* ToString(MutatorThreadSweepingMode sweeping_mode) {
   }
 }
 
-enum class StickyBits : uint8_t {
+enum class StickyBitsSweeper : uint8_t {
   kDisabled,
   kEnabled,
 };
@@ -236,10 +236,10 @@ struct SpaceState {
 
 using SpaceStates = std::vector<SpaceState>;
 
-void StickyUnmark(HeapObjectHeader* header, StickyBits sticky_bits) {
+void StickyUnmark(HeapObjectHeader* header, StickyBitsSweeper sticky_bits) {
 #if defined(CPPGC_YOUNG_GENERATION)
   // Young generation in Oilpan uses sticky mark bits.
-  if (sticky_bits == StickyBits::kDisabled)
+  if (sticky_bits == StickyBitsSweeper::kDisabled)
     header->Unmark<AccessMode::kAtomic>();
 #else   // !defined(CPPGC_YOUNG_GENERATION)
   header->Unmark<AccessMode::kAtomic>();
@@ -338,7 +338,7 @@ class DeferredFinalizationBuilder final : public FreeHandler {
 
 template <typename FinalizationBuilder>
 typename FinalizationBuilder::ResultType SweepNormalPage(
-    NormalPage* page, PageAllocator& page_allocator, StickyBits sticky_bits) {
+    NormalPage* page, PageAllocator& page_allocator, StickyBitsSweeper sticky_bits) {
   constexpr auto kAtomicAccess = AccessMode::kAtomic;
   FinalizationBuilder builder(*page, page_allocator);
 
@@ -552,8 +552,8 @@ class MutatorThreadSweeper final : private HeapVisitor<MutatorThreadSweeper> {
         platform_(platform),
         free_memory_handling_(free_memory_handling),
         sticky_bits_(heap->generational_gc_supported()
-                         ? StickyBits::kEnabled
-                         : StickyBits::kDisabled) {}
+                         ? StickyBitsSweeper::kEnabled
+                         : StickyBitsSweeper::kDisabled) {}
 
   void Sweep() {
     for (SpaceState& state : *states_) {
@@ -644,7 +644,7 @@ class MutatorThreadSweeper final : private HeapVisitor<MutatorThreadSweeper> {
   cppgc::Platform* platform_;
   size_t largest_new_free_list_entry_ = 0;
   const FreeMemoryHandling free_memory_handling_;
-  const StickyBits sticky_bits_;
+  const StickyBitsSweeper sticky_bits_;
 };
 
 class ConcurrentSweepTask final : public cppgc::JobTask,
@@ -660,8 +660,8 @@ class ConcurrentSweepTask final : public cppgc::JobTask,
         states_(states),
         platform_(platform),
         free_memory_handling_(free_memory_handling),
-        sticky_bits_(heap.generational_gc_supported() ? StickyBits::kEnabled
-                                                      : StickyBits::kDisabled) {
+        sticky_bits_(heap.generational_gc_supported() ? StickyBitsSweeper::kEnabled
+                                                      : StickyBitsSweeper::kDisabled) {
   }
 
   void Run(cppgc::JobDelegate* delegate) final {
@@ -731,7 +731,7 @@ class ConcurrentSweepTask final : public cppgc::JobTask,
   Platform* platform_;
   std::atomic_bool is_completed_{false};
   const FreeMemoryHandling free_memory_handling_;
-  const StickyBits sticky_bits_;
+  const StickyBitsSweeper sticky_bits_;
 };
 
 // This visitor:
diff --git a/v8/src/heap/minor-mark-sweep.cc b/v8/src/heap/minor-mark-sweep.cc
index d1e3ad8d91..4266bfcb9d 100644
--- a/v8/src/heap/minor-mark-sweep.cc
+++ b/v8/src/heap/minor-mark-sweep.cc
@@ -776,7 +776,7 @@ namespace {
 
 // NewSpacePages with more live bytes than this threshold qualify for fast
 // evacuation.
-intptr_t NewSpacePageEvacuationThreshold() {
+intptr_t NewSpacePageEvacuationThreshold2() {
   return v8_flags.minor_ms_page_promotion_threshold *
          MemoryChunkLayout::AllocatableMemoryInDataPage() / 100;
 }
@@ -786,7 +786,7 @@ bool ShouldMovePage(Page* p, intptr_t live_bytes, intptr_t wasted_bytes) {
   Heap* heap = p->heap();
   DCHECK(!p->NeverEvacuate());
   const bool should_move_page =
-      ((live_bytes + wasted_bytes) > NewSpacePageEvacuationThreshold() ||
+      ((live_bytes + wasted_bytes) > NewSpacePageEvacuationThreshold2() ||
        (p->AllocatedLabSize() == 0)) &&
       (heap->new_space()->IsPromotionCandidate(p)) &&
       heap->CanExpandOldGeneration(live_bytes);
@@ -797,7 +797,7 @@ bool ShouldMovePage(Page* p, intptr_t live_bytes, intptr_t wasted_bytes) {
         ", live bytes = %zu, wasted bytes = %zu, promotion threshold = %zu"
         ", allocated labs size = %zu\n",
         p, should_move_page, live_bytes, wasted_bytes,
-        NewSpacePageEvacuationThreshold(), p->AllocatedLabSize());
+        NewSpacePageEvacuationThreshold2(), p->AllocatedLabSize());
   }
   if (!should_move_page &&
       (p->AgeInNewSpace() == v8_flags.minor_ms_max_page_age)) {
diff --git a/v8/src/heap/scavenger.cc b/v8/src/heap/scavenger.cc
index 4e305171d2..cf04a52be8 100644
--- a/v8/src/heap/scavenger.cc
+++ b/v8/src/heap/scavenger.cc
@@ -613,7 +613,7 @@ Scavenger::PromotionList::Local::Local(Scavenger::PromotionList* promotion_list)
           promotion_list->large_object_promotion_list_) {}
 
 namespace {
-MainAllocator* CreateSharedOldAllocator(Heap* heap) {
+MainAllocator* CreateSharedOldAllocator2(Heap* heap) {
   if (v8_flags.shared_string_table && heap->isolate()->has_shared_space()) {
     return new MainAllocator(heap, heap->shared_allocation_space(),
                              MainAllocator::kInGC);
@@ -639,7 +639,7 @@ Scavenger::Scavenger(ScavengerCollector* collector, Heap* heap, bool is_logging,
       copied_size_(0),
       promoted_size_(0),
       allocator_(heap, CompactionSpaceKind::kCompactionSpaceForScavenge),
-      shared_old_allocator_(CreateSharedOldAllocator(heap_)),
+      shared_old_allocator_(CreateSharedOldAllocator2(heap_)),
       is_logging_(is_logging),
       is_incremental_marking_(heap->incremental_marking()->IsMarking()),
       is_compacting_(heap->incremental_marking()->IsCompacting()),
diff --git a/v8/src/heap/traced-handles-marking-visitor.h b/v8/src/heap/traced-handles-marking-visitor.h
index 174ba9150f..6d312575b8 100644
--- a/v8/src/heap/traced-handles-marking-visitor.h
+++ b/v8/src/heap/traced-handles-marking-visitor.h
@@ -37,7 +37,7 @@ class ConservativeTracedHandlesMarkingVisitor final
   const TracedHandles::MarkMode mark_mode_;
 };
 
-#endif  // V8_HEAP_TRACED_HANDLES_MARKING_VISITOR_H_
-
 }  // namespace internal
 }  // namespace v8
+
+#endif  // V8_HEAP_TRACED_HANDLES_MARKING_VISITOR_H_
diff --git a/v8/src/inspector/BUILD.gn b/v8/src/inspector/BUILD.gn
index 9a86323237..422ea6032d 100644
--- a/v8/src/inspector/BUILD.gn
+++ b/v8/src/inspector/BUILD.gn
@@ -171,6 +171,7 @@ v8_source_set("inspector") {
     "value-mirror.cc",
     "value-mirror.h",
   ]
+  jumbo_excluded_sources = [ "value-mirror.cc" ]
 }
 
 #Target to generate all .cc files.
diff --git a/v8/src/inspector/value-mirror.cc b/v8/src/inspector/value-mirror.cc
index 8b80672098..b5e68fdafc 100644
--- a/v8/src/inspector/value-mirror.cc
+++ b/v8/src/inspector/value-mirror.cc
@@ -200,7 +200,7 @@ String16 abbreviateString(const String16& value, AbbreviateMode mode) {
   return String16::concat(value.substring(0, maxLength - 1), ellipsis);
 }
 
-String16 descriptionForSymbol(v8::Local<v8::Context> context,
+String16 descriptionForSymbol2(v8::Local<v8::Context> context,
                               v8::Local<v8::Symbol> symbol) {
   v8::Isolate* isolate = context->GetIsolate();
   return String16::concat(
@@ -705,7 +705,7 @@ class SymbolMirror final : public ValueMirrorBase {
         v8Value(context->GetIsolate()).As<v8::Symbol>();
     *result = RemoteObject::create()
                   .setType(RemoteObject::TypeEnum::Symbol)
-                  .setDescription(descriptionForSymbol(context, value))
+                  .setDescription(descriptionForSymbol2(context, value))
                   .build();
     return Response::Success();
   }
@@ -720,7 +720,7 @@ class SymbolMirror final : public ValueMirrorBase {
                    .setName(name)
                    .setType(RemoteObject::TypeEnum::Symbol)
                    .setValue(abbreviateString(
-                       descriptionForSymbol(context, value), kEnd))
+                       descriptionForSymbol2(context, value), kEnd))
                    .build();
   }
 
@@ -732,7 +732,7 @@ class SymbolMirror final : public ValueMirrorBase {
     *preview =
         ObjectPreview::create()
             .setType(RemoteObject::TypeEnum::Symbol)
-            .setDescription(descriptionForSymbol(context, value))
+            .setDescription(descriptionForSymbol2(context, value))
             .setOverflow(false)
             .setProperties(std::make_unique<protocol::Array<PropertyPreview>>())
             .build();
@@ -1525,7 +1525,7 @@ bool ValueMirror::getProperties(v8::Local<v8::Context> context,
       name = toProtocolString(isolate, v8Name.As<v8::String>());
     } else {
       v8::Local<v8::Symbol> symbol = v8Name.As<v8::Symbol>();
-      name = descriptionForSymbol(context, symbol);
+      name = descriptionForSymbol2(context, symbol);
       symbolMirror = ValueMirror::create(context, symbol);
     }
 
diff --git a/v8/src/libplatform/default-thread-isolated-allocator.cc b/v8/src/libplatform/default-thread-isolated-allocator.cc
index bda0e43cef..36a365b257 100644
--- a/v8/src/libplatform/default-thread-isolated-allocator.cc
+++ b/v8/src/libplatform/default-thread-isolated-allocator.cc
@@ -16,6 +16,8 @@
 #include <unistd.h>
 #endif
 
+#undef MAP_TYPE
+
 #if V8_HAS_PKU_JIT_WRITE_PROTECT
 
 extern int pkey_alloc(unsigned int flags, unsigned int access_rights) V8_WEAK;
diff --git a/v8/src/maglev/arm/maglev-ir-arm.cc b/v8/src/maglev/arm/maglev-ir-arm.cc
index 6b9b147012..628fbd5826 100644
--- a/v8/src/maglev/arm/maglev-ir-arm.cc
+++ b/v8/src/maglev/arm/maglev-ir-arm.cc
@@ -871,6 +871,8 @@ void Return::GenerateCode(MaglevAssembler* masm, const ProcessingState& state) {
   __ Ret();
 }
 
+#undef __
+
 }  // namespace maglev
 }  // namespace internal
 }  // namespace v8
diff --git a/v8/src/maglev/maglev-assembler-inl.h b/v8/src/maglev/maglev-assembler-inl.h
index 3546fe5073..12d8fa740c 100644
--- a/v8/src/maglev/maglev-assembler-inl.h
+++ b/v8/src/maglev/maglev-assembler-inl.h
@@ -487,11 +487,11 @@ void CheckArgs(Args&&... args) {}
 
 #endif  // DEBUG
 
-template <typename Descriptor, typename... Args>
+template <typename Descriptor2, typename... Args>
 void PushArgumentsForBuiltin(MaglevAssembler* masm, std::tuple<Args...> args) {
   std::apply(
       [&](auto&&... stack_args) {
-        if (Descriptor::kStackArgumentOrder == StackArgumentOrder::kDefault) {
+        if (Descriptor2::kStackArgumentOrder == StackArgumentOrder::kDefault) {
           masm->Push(std::forward<decltype(stack_args)>(stack_args)...);
         } else {
           masm->PushReverse(std::forward<decltype(stack_args)>(stack_args)...);
diff --git a/v8/src/maglev/maglev-assembler.cc b/v8/src/maglev/maglev-assembler.cc
index 4f88672454..247a6f7342 100644
--- a/v8/src/maglev/maglev-assembler.cc
+++ b/v8/src/maglev/maglev-assembler.cc
@@ -546,6 +546,8 @@ void MaglevAssembler::StoreFixedArrayElementWithWriteBarrier(
       kValueCanBeSmi);
 }
 
+#undef __
+
 }  // namespace maglev
 }  // namespace internal
 }  // namespace v8
diff --git a/v8/src/maglev/maglev-code-generator.cc b/v8/src/maglev/maglev-code-generator.cc
index 5f428eadea..4ef704c5f7 100644
--- a/v8/src/maglev/maglev-code-generator.cc
+++ b/v8/src/maglev/maglev-code-generator.cc
@@ -424,8 +424,9 @@ class ParallelMoveResolver {
       // The DecompressIfNeeded clause is redundant with the if-constexpr above,
       // but otherwise this code cannot be compiled by compilers not yet
       // implementing CWG2518.
+#if 0
       static_assert(DecompressIfNeeded && COMPRESS_POINTERS_BOOL);
-
+#endif
       if (targets.needs_decompression == kNeedsDecompression) {
         __ DecompressTagged(source_reg, source_reg);
       }
@@ -471,8 +472,9 @@ class ParallelMoveResolver {
       // The DecompressIfNeeded clause is redundant with the if-constexpr above,
       // but otherwise this code cannot be compiled by compilers not yet
       // implementing CWG2518.
+#if 0
       static_assert(DecompressIfNeeded && COMPRESS_POINTERS_BOOL);
-
+#endif
       if (targets.needs_decompression == kNeedsDecompression) {
         __ DecompressTagged(register_with_slot_value, register_with_slot_value);
         targets.needs_decompression = kDoesNotNeedDecompression;
@@ -1792,6 +1794,8 @@ Handle<DeoptimizationData> MaglevCodeGenerator::GenerateDeoptimizationData(
   return data;
 }
 
+#undef __
+
 }  // namespace maglev
 }  // namespace internal
 }  // namespace v8
diff --git a/v8/src/maglev/maglev-ir.cc b/v8/src/maglev/maglev-ir.cc
index 73ba7e37c9..0c4fe231e7 100644
--- a/v8/src/maglev/maglev-ir.cc
+++ b/v8/src/maglev/maglev-ir.cc
@@ -6718,6 +6718,8 @@ void BranchIfTypeOf::PrintParams(std::ostream& os,
   os << "(" << interpreter::TestTypeOfFlags::ToString(literal_) << ")";
 }
 
+#undef __
+
 }  // namespace maglev
 }  // namespace internal
 }  // namespace v8
diff --git a/v8/src/objects/js-list-format.cc b/v8/src/objects/js-list-format.cc
index 4f29271788..ca07a35c0e 100644
--- a/v8/src/objects/js-list-format.cc
+++ b/v8/src/objects/js-list-format.cc
@@ -248,7 +248,7 @@ Handle<String> IcuFieldIdToType(Isolate* isolate, int32_t field_id) {
 
 // A helper function to convert the FormattedList to a
 // MaybeHandle<JSArray> for the implementation of formatToParts.
-MaybeHandle<JSArray> FormattedListToJSArray(
+MaybeHandle<JSArray> FormattedListToJSArray2(
     Isolate* isolate, const icu::FormattedValue& formatted) {
   Handle<JSArray> array = isolate->factory()->NewJSArray(0);
   icu::ConstrainedFieldPosition cfpos;
@@ -286,7 +286,7 @@ MaybeHandle<String> JSListFormat::FormatList(Isolate* isolate,
 MaybeHandle<JSArray> JSListFormat::FormatListToParts(
     Isolate* isolate, Handle<JSListFormat> format, Handle<FixedArray> list) {
   return FormatListCommon<JSArray>(isolate, format, list,
-                                   FormattedListToJSArray);
+                                   FormattedListToJSArray2);
 }
 
 namespace {
diff --git a/v8/src/objects/js-temporal-objects.cc b/v8/src/objects/js-temporal-objects.cc
index bee900c189..9b509dbe07 100644
--- a/v8/src/objects/js-temporal-objects.cc
+++ b/v8/src/objects/js-temporal-objects.cc
@@ -168,10 +168,10 @@ enum class Arithmetic { kAdd, kSubtract };
 // Enum for since/until
 enum class TimePreposition { kSince, kUntil };
 
-enum class Offset { kPrefer, kUse, kIgnore, kReject };
-V8_WARN_UNUSED_RESULT Maybe<Offset> ToTemporalOffset(Isolate* isolate,
+enum class OffsetAction { kPrefer, kUse, kIgnore, kReject };
+V8_WARN_UNUSED_RESULT Maybe<OffsetAction> ToTemporalOffset(Isolate* isolate,
                                                      Handle<Object> options,
-                                                     Offset fallback,
+                                                     OffsetAction fallback,
                                                      const char* method_name);
 
 // sec-temporal-totemporalroundingmode
@@ -2223,18 +2223,18 @@ Maybe<ShowOverflow> ToTemporalOverflow(Isolate* isolate, Handle<Object> options,
 }
 
 // #sec-temporal-totemporaloffset
-Maybe<Offset> ToTemporalOffset(Isolate* isolate, Handle<Object> options,
-                               Offset fallback, const char* method_name) {
+Maybe<OffsetAction> ToTemporalOffset(Isolate* isolate, Handle<Object> options,
+                               OffsetAction fallback, const char* method_name) {
   // 1. If options is undefined, return fallback.
   if (IsUndefined(*options)) return Just(fallback);
   DCHECK(IsJSReceiver(*options));
 
   // 2. Return ? GetOption(options, "offset",  String ,  "prefer", "use",
   // "ignore", "reject" , fallback).
-  return GetStringOption<Offset>(
+  return GetStringOption<OffsetAction>(
       isolate, Handle<JSReceiver>::cast(options), "offset", method_name,
       {"prefer", "use", "ignore", "reject"},
-      {Offset::kPrefer, Offset::kUse, Offset::kIgnore, Offset::kReject},
+      {OffsetAction::kPrefer, OffsetAction::kUse, OffsetAction::kIgnore, OffsetAction::kReject},
       fallback);
 }
 
@@ -8070,7 +8070,7 @@ MaybeHandle<BigInt> InterpretISODateTimeOffset(
     Isolate* isolate, const DateTimeRecord& data,
     OffsetBehaviour offset_behaviour, int64_t offset_nanoseconds,
     Handle<JSReceiver> time_zone, Disambiguation disambiguation,
-    Offset offset_option, MatchBehaviour match_behaviour,
+    OffsetAction offset_option, MatchBehaviour match_behaviour,
     const char* method_name);
 
 // #sec-temporal-interprettemporaldatetimefields
@@ -8292,7 +8292,7 @@ MaybeHandle<Object> ToRelativeTemporalObject(Isolate* isolate,
       isolate, epoch_nanoseconds,
       InterpretISODateTimeOffset(isolate, result, offset_behaviour, offset_ns,
                                  time_zone, Disambiguation::kCompatible,
-                                 Offset::kReject, match_behaviour, method_name),
+                                 OffsetAction::kReject, match_behaviour, method_name),
       Object);
 
   // 12. Return ? CreateTemporalZonedDateTime(epochNanoseconds, timeZone,
@@ -16114,10 +16114,10 @@ MaybeHandle<JSTemporalZonedDateTime> ToTemporalZonedDateTime(
       Handle<JSTemporalZonedDateTime>());
 
   // 8. Let offset be ? ToTemporalOffset(options, "reject").
-  enum Offset offset;
+  enum OffsetAction offset;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, offset,
-      ToTemporalOffset(isolate, options, Offset::kReject, method_name),
+      ToTemporalOffset(isolate, options, OffsetAction::kReject, method_name),
       Handle<JSTemporalZonedDateTime>());
 
   // 9. Let epochNanoseconds be ? InterpretISODateTimeOffset(result.[[Year]],
@@ -16179,10 +16179,10 @@ MaybeHandle<JSTemporalZonedDateTime> JSTemporalZonedDateTime::From(
 
     // c. Perform ? ToTemporalOffset(options, "reject").
     {
-      enum Offset offset;
+      enum OffsetAction offset;
       MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
           isolate, offset,
-          ToTemporalOffset(isolate, options, Offset::kReject, method_name),
+          ToTemporalOffset(isolate, options, OffsetAction::kReject, method_name),
           Handle<JSTemporalZonedDateTime>());
       USE(offset);
     }
@@ -16293,7 +16293,7 @@ MaybeHandle<BigInt> InterpretISODateTimeOffset(
     Isolate* isolate, const DateTimeRecord& data,
     OffsetBehaviour offset_behaviour, int64_t offset_nanoseconds,
     Handle<JSReceiver> time_zone, Disambiguation disambiguation,
-    Offset offset_option, MatchBehaviour match_behaviour,
+    OffsetAction offset_option, MatchBehaviour match_behaviour,
     const char* method_name) {
   TEMPORAL_ENTER_FUNC();
 
@@ -16311,7 +16311,7 @@ MaybeHandle<BigInt> InterpretISODateTimeOffset(
 
   // 4. If offsetBehaviour is wall, or offsetOption is "ignore", then
   if (offset_behaviour == OffsetBehaviour::kWall ||
-      offset_option == Offset::kIgnore) {
+      offset_option == OffsetAction::kIgnore) {
     // a. Let instant be ? BuiltinTimeZoneGetInstantFor(timeZone, dateTime,
     // disambiguation).
     Handle<JSTemporalInstant> instant;
@@ -16325,7 +16325,7 @@ MaybeHandle<BigInt> InterpretISODateTimeOffset(
   }
   // 5. If offsetBehaviour is exact, or offsetOption is "use", then
   if (offset_behaviour == OffsetBehaviour::kExact ||
-      offset_option == Offset::kUse) {
+      offset_option == OffsetAction::kUse) {
     // a. Let epochNanoseconds be ? GetEpochFromISOParts(year, month, day, hour,
     // minute, second, millisecond, microsecond, nanosecond).
     Handle<BigInt> epoch_nanoseconds =
@@ -16347,7 +16347,7 @@ MaybeHandle<BigInt> InterpretISODateTimeOffset(
   // 6. Assert: offsetBehaviour is option.
   DCHECK_EQ(offset_behaviour, OffsetBehaviour::kOption);
   // 7. Assert: offsetOption is "prefer" or "reject".
-  DCHECK(offset_option == Offset::kPrefer || offset_option == Offset::kReject);
+  DCHECK(offset_option == OffsetAction::kPrefer || offset_option == OffsetAction::kReject);
   // 8. Let possibleInstants be ? GetPossibleInstantsFor(timeZone, dateTime).
   Handle<FixedArray> possible_instants;
   ASSIGN_RETURN_ON_EXCEPTION(
@@ -16385,7 +16385,7 @@ MaybeHandle<BigInt> InterpretISODateTimeOffset(
     }
   }
   // 10. If offsetOption is "reject", throw a RangeError exception.
-  if (offset_option == Offset::kReject) {
+  if (offset_option == OffsetAction::kReject) {
     THROW_NEW_ERROR(isolate, NEW_TEMPORAL_INVALID_ARG_RANGE_ERROR(), BigInt);
   }
   // 11. Let instant be ? DisambiguatePossibleInstants(possibleInstants,
@@ -16466,10 +16466,10 @@ MaybeHandle<JSTemporalZonedDateTime> JSTemporalZonedDateTime::With(
       Handle<JSTemporalZonedDateTime>());
 
   // 11. Let offset be ? ToTemporalOffset(options, "prefer").
-  enum Offset offset;
+  enum OffsetAction offset;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, offset,
-      ToTemporalOffset(isolate, options, Offset::kPrefer, method_name),
+      ToTemporalOffset(isolate, options, OffsetAction::kPrefer, method_name),
       Handle<JSTemporalZonedDateTime>());
 
   // 12. Let timeZone be zonedDateTime.[[TimeZone]].
@@ -17201,7 +17201,7 @@ MaybeHandle<JSTemporalZonedDateTime> JSTemporalZonedDateTime::Round(
       isolate, epoch_nanoseconds,
       InterpretISODateTimeOffset(
           isolate, round_result, OffsetBehaviour::kOption, offset_nanoseconds,
-          time_zone, Disambiguation::kCompatible, Offset::kPrefer,
+          time_zone, Disambiguation::kCompatible, OffsetAction::kPrefer,
           MatchBehaviour::kMatchExactly, method_name),
       JSTemporalZonedDateTime);
 
diff --git a/v8/src/regexp/experimental/experimental-compiler.cc b/v8/src/regexp/experimental/experimental-compiler.cc
index 8acaa4b5ac..0f1969c31b 100644
--- a/v8/src/regexp/experimental/experimental-compiler.cc
+++ b/v8/src/regexp/experimental/experimental-compiler.cc
@@ -230,7 +230,7 @@ bool ExperimentalRegExpCompiler::CanBeHandled(RegExpTree* tree,
   return CanBeHandledVisitor::Check(tree, flags, capture_count);
 }
 
-namespace {
+namespace experimental {
 
 // A label in bytecode which starts with no known address. The address *must*
 // be bound with `Bind` before the label goes out of scope.
@@ -884,7 +884,7 @@ class CompileVisitor : private RegExpVisitor {
 
 ZoneList<RegExpInstruction> ExperimentalRegExpCompiler::Compile(
     RegExpTree* tree, RegExpFlags flags, Zone* zone) {
-  return CompileVisitor::Compile(tree, flags, zone);
+  return experimental::CompileVisitor::Compile(tree, flags, zone);
 }
 
 }  // namespace internal
diff --git a/v8/src/regexp/regexp-compiler-tonode.cc b/v8/src/regexp/regexp-compiler-tonode.cc
index 3372e655eb..70bd65f434 100644
--- a/v8/src/regexp/regexp-compiler-tonode.cc
+++ b/v8/src/regexp/regexp-compiler-tonode.cc
@@ -23,7 +23,7 @@ namespace internal {
 
 using namespace regexp_compiler_constants;  // NOLINT(build/namespaces)
 
-constexpr base::uc32 kMaxCodePoint = 0x10ffff;
+constexpr base::uc32 kMaxCodePoint2 = 0x10ffff;
 constexpr int kMaxUtf16CodeUnit = 0xffff;
 constexpr uint32_t kMaxUtf16CodeUnitU = 0xffff;
 constexpr int32_t kMaxOneByteCharCode = unibrow::Latin1::kMaxChar;
@@ -72,7 +72,7 @@ bool CompareInverseRanges(ZoneList<CharacterRange>* ranges,
     }
   }
 
-  return range.to() == kMaxCodePoint;
+  return range.to() == kMaxCodePoint2;
 }
 
 bool CompareRanges(ZoneList<CharacterRange>* ranges, const int* special_class,
@@ -480,7 +480,7 @@ RegExpNode* RegExpClassRanges::ToNode(RegExpCompiler* compiler,
     // internally created for an empty set.
     DCHECK_IMPLIES(
         IsUnicodeSets(compiler->flags()),
-        ranges->length() == 1 && ranges->first().IsEverything(kMaxCodePoint));
+        ranges->length() == 1 && ranges->first().IsEverything(kMaxCodePoint2));
     ZoneList<CharacterRange>* negated =
         zone->New<ZoneList<CharacterRange>>(2, zone);
     CharacterRange::Negate(ranges, negated, zone);
@@ -1366,7 +1366,7 @@ void AddClassNegated(const int* elmv, int elmc,
   elmc--;
   DCHECK_EQ(kRangeEndMarker, elmv[elmc]);
   DCHECK_NE(0x0000, elmv[0]);
-  DCHECK_NE(kMaxCodePoint, elmv[elmc - 1]);
+  DCHECK_NE(kMaxCodePoint2, elmv[elmc - 1]);
   base::uc16 last = 0x0000;
   for (int i = 0; i < elmc; i += 2) {
     DCHECK(last <= elmv[i] - 1);
@@ -1374,7 +1374,7 @@ void AddClassNegated(const int* elmv, int elmc,
     ranges->Add(CharacterRange::Range(last, elmv[i] - 1), zone);
     last = elmv[i + 1];
   }
-  ranges->Add(CharacterRange::Range(last, kMaxCodePoint), zone);
+  ranges->Add(CharacterRange::Range(last, kMaxCodePoint2), zone);
 }
 
 }  // namespace
@@ -1718,8 +1718,8 @@ void CharacterRange::Negate(const ZoneList<CharacterRange>* ranges,
     from = range.to() + 1;
     i++;
   }
-  if (from < kMaxCodePoint) {
-    negated_ranges->Add(CharacterRange::Range(from, kMaxCodePoint), zone);
+  if (from < kMaxCodePoint2) {
+    negated_ranges->Add(CharacterRange::Range(from, kMaxCodePoint2), zone);
   }
 }
 
@@ -1770,7 +1770,7 @@ void SafeAdvanceRange(const ZoneList<CharacterRange>* range, int* index,
     *from = range->at(*index).from();
     *to = range->at(*index).to();
   } else {
-    *from = kMaxCodePoint + 1;
+    *from = kMaxCodePoint2 + 1;
   }
 }
 
diff --git a/v8/src/runtime/runtime-internal.cc b/v8/src/runtime/runtime-internal.cc
index df66ca864b..310ba1e25d 100644
--- a/v8/src/runtime/runtime-internal.cc
+++ b/v8/src/runtime/runtime-internal.cc
@@ -19,7 +19,7 @@
 #include "src/utils/ostreams.h"
 
 #if V8_ENABLE_WEBASSEMBLY
-// TODO(chromium:1236668): Drop this when the "SaveAndClearThreadInWasmFlag"
+// TODO(chromium:1236668): Drop this when the "SaveAndClearThreadInWasmFlag_internal"
 // approach is no longer needed.
 #include "src/trap-handler/trap-handler.h"
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -457,9 +457,9 @@ RUNTIME_FUNCTION(Runtime_BytecodeBudgetInterruptWithStackCheck_Maglev) {
 namespace {
 
 #if V8_ENABLE_WEBASSEMBLY
-class V8_NODISCARD SaveAndClearThreadInWasmFlag {
+class V8_NODISCARD SaveAndClearThreadInWasmFlag_internal {
  public:
-  SaveAndClearThreadInWasmFlag() {
+  SaveAndClearThreadInWasmFlag_internal() {
     if (trap_handler::IsTrapHandlerEnabled()) {
       if (trap_handler::IsThreadInWasm()) {
         thread_was_in_wasm_ = true;
@@ -467,7 +467,7 @@ class V8_NODISCARD SaveAndClearThreadInWasmFlag {
       }
     }
   }
-  ~SaveAndClearThreadInWasmFlag() {
+  ~SaveAndClearThreadInWasmFlag_internal() {
     if (thread_was_in_wasm_) {
       trap_handler::SetThreadInWasm();
     }
@@ -477,7 +477,7 @@ class V8_NODISCARD SaveAndClearThreadInWasmFlag {
   bool thread_was_in_wasm_{false};
 };
 #else
-class SaveAndClearThreadInWasmFlag {};
+class SaveAndClearThreadInWasmFlag_internal {};
 #endif  // V8_ENABLE_WEBASSEMBLY
 
 }  // namespace
@@ -499,7 +499,7 @@ RUNTIME_FUNCTION(Runtime_AllocateInYoungGeneration) {
   // which is important in case any GC needs to happen.
   // TODO(chromium:1236668): Find a better fix, likely by replacing the global
   // flag.
-  SaveAndClearThreadInWasmFlag clear_wasm_flag;
+  SaveAndClearThreadInWasmFlag_internal clear_wasm_flag;
 #endif  // V8_ENABLE_WEBASSEMBLY
 
   // TODO(v8:9472): Until double-aligned allocation is fixed for new-space
diff --git a/v8/src/sandbox/testing.cc b/v8/src/sandbox/testing.cc
index 1f36613d08..e09844af0e 100644
--- a/v8/src/sandbox/testing.cc
+++ b/v8/src/sandbox/testing.cc
@@ -18,6 +18,7 @@
 #include <signal.h>
 #include <sys/mman.h>
 #include <unistd.h>
+#undef MAP_TYPE
 #endif  // V8_OS_LINUX
 
 namespace v8 {
diff --git a/v8/src/snapshot/read-only-deserializer.cc b/v8/src/snapshot/read-only-deserializer.cc
index ea5ebb1a96..43d2436418 100644
--- a/v8/src/snapshot/read-only-deserializer.cc
+++ b/v8/src/snapshot/read-only-deserializer.cc
@@ -179,7 +179,7 @@ void ReadOnlyDeserializer::DeserializeIntoIsolate() {
   }
 }
 
-void NoExternalReferencesCallback() {
+void NoExternalReferencesCallback2() {
   // The following check will trigger if a function or object template with
   // references to native functions have been deserialized from snapshot, but
   // no actual external references were provided when the isolate was created.
@@ -230,7 +230,7 @@ class ObjectPostProcessor final {
       const intptr_t* refs = isolate_->api_external_references();
       Address address =
           refs == nullptr
-              ? reinterpret_cast<Address>(NoExternalReferencesCallback)
+              ? reinterpret_cast<Address>(NoExternalReferencesCallback2)
               : static_cast<Address>(refs[index]);
       DCHECK_NE(address, kNullAddress);
       return address;
diff --git a/v8/src/torque/csa-generator.cc b/v8/src/torque/csa-generator.cc
index ec9eaccf79..0fdaa4defc 100644
--- a/v8/src/torque/csa-generator.cc
+++ b/v8/src/torque/csa-generator.cc
@@ -924,8 +924,8 @@ void CSAGenerator::EmitInstruction(const StoreReferenceInstruction& instruction,
 }
 
 namespace {
-std::string GetBitFieldSpecialization(const Type* container,
-                                      const BitField& field) {
+std::string GetBitFieldSpecialization2(const Type* container,
+                                       const BitField& field) {
   auto smi_tagged_type =
       Type::MatchUnaryGeneric(container, TypeOracle::GetSmiTaggedGeneric());
   std::string container_type = smi_tagged_type
@@ -978,7 +978,7 @@ void CSAGenerator::EmitInstruction(const LoadBitFieldInstruction& instruction,
   out() << "    " << result_name << " = ca_.UncheckedCast<"
         << field_type->GetGeneratedTNodeTypeName()
         << ">(CodeStubAssembler(state_)." << decoder << "<"
-        << GetBitFieldSpecialization(struct_type, instruction.bit_field)
+        << GetBitFieldSpecialization2(struct_type, instruction.bit_field)
         << ">(ca_.UncheckedCast<" << struct_word_type << ">("
         << bit_field_struct << ")));\n";
 }
@@ -1020,7 +1020,7 @@ void CSAGenerator::EmitInstruction(const StoreBitFieldInstruction& instruction,
 
   std::string result_expression =
       "CodeStubAssembler(state_)." + encoder + "<" +
-      GetBitFieldSpecialization(struct_type, instruction.bit_field) +
+      GetBitFieldSpecialization2(struct_type, instruction.bit_field) +
       ">(ca_.UncheckedCast<" + struct_word_type + ">(" + bit_field_struct +
       "), ca_.UncheckedCast<" + field_word_type + ">(" + value + ")" +
       (instruction.starts_as_zero ? ", true" : "") + ")";
diff --git a/v8/src/utils/sha-256.cc b/v8/src/utils/sha-256.cc
index 4b1d2bd42b..f55c0b4aec 100644
--- a/v8/src/utils/sha-256.cc
+++ b/v8/src/utils/sha-256.cc
@@ -174,3 +174,6 @@ const uint8_t* SHA256_hash(const void* data, size_t len, uint8_t* digest) {
 
 }  // namespace internal
 }  // namespace v8
+
+#undef ror
+#undef shr
diff --git a/v8/src/wasm/wasm-external-refs.cc b/v8/src/wasm/wasm-external-refs.cc
index b34228964d..43a5fde290 100644
--- a/v8/src/wasm/wasm-external-refs.cc
+++ b/v8/src/wasm/wasm-external-refs.cc
@@ -444,8 +444,8 @@ V ReadAndIncrementOffset(Address data, size_t* offset) {
   return result;
 }
 
-constexpr int32_t kSuccess = 1;
-constexpr int32_t kOutOfBounds = 0;
+constexpr int32_t kSuccess2 = 1;
+constexpr int32_t kOutOfBounds2 = 0;
 }  // namespace
 
 int32_t memory_init_wrapper(Address trusted_data_addr, uint32_t mem_index,
@@ -457,16 +457,16 @@ int32_t memory_init_wrapper(Address trusted_data_addr, uint32_t mem_index,
       Tagged<WasmTrustedInstanceData>::cast(Tagged<Object>{trusted_data_addr});
 
   uint64_t mem_size = trusted_data->memory_size(mem_index);
-  if (!base::IsInBounds<uint64_t>(dst, size, mem_size)) return kOutOfBounds;
+  if (!base::IsInBounds<uint64_t>(dst, size, mem_size)) return kOutOfBounds2;
 
   uint32_t seg_size = trusted_data->data_segment_sizes()->get(seg_index);
-  if (!base::IsInBounds<uint32_t>(src, size, seg_size)) return kOutOfBounds;
+  if (!base::IsInBounds<uint32_t>(src, size, seg_size)) return kOutOfBounds2;
 
   uint8_t* seg_start = reinterpret_cast<uint8_t*>(
       trusted_data->data_segment_starts()->get(seg_index));
   std::memcpy(EffectiveAddress(trusted_data, mem_index, dst), seg_start + src,
               size);
-  return kSuccess;
+  return kSuccess2;
 }
 
 int32_t memory_copy_wrapper(Address trusted_data_addr, uint32_t dst_mem_index,
@@ -479,13 +479,13 @@ int32_t memory_copy_wrapper(Address trusted_data_addr, uint32_t dst_mem_index,
 
   uint64_t dst_mem_size = trusted_data->memory_size(dst_mem_index);
   uint64_t src_mem_size = trusted_data->memory_size(src_mem_index);
-  if (!base::IsInBounds<uint64_t>(dst, size, dst_mem_size)) return kOutOfBounds;
-  if (!base::IsInBounds<uint64_t>(src, size, src_mem_size)) return kOutOfBounds;
+  if (!base::IsInBounds<uint64_t>(dst, size, dst_mem_size)) return kOutOfBounds2;
+  if (!base::IsInBounds<uint64_t>(src, size, src_mem_size)) return kOutOfBounds2;
 
   // Use std::memmove, because the ranges can overlap.
   std::memmove(EffectiveAddress(trusted_data, dst_mem_index, dst),
                EffectiveAddress(trusted_data, src_mem_index, src), size);
-  return kSuccess;
+  return kSuccess2;
 }
 
 int32_t memory_fill_wrapper(Address trusted_data_addr, uint32_t mem_index,
@@ -497,10 +497,10 @@ int32_t memory_fill_wrapper(Address trusted_data_addr, uint32_t mem_index,
       Tagged<WasmTrustedInstanceData>::cast(Tagged<Object>{trusted_data_addr});
 
   uint64_t mem_size = trusted_data->memory_size(mem_index);
-  if (!base::IsInBounds<uint64_t>(dst, size, mem_size)) return kOutOfBounds;
+  if (!base::IsInBounds<uint64_t>(dst, size, mem_size)) return kOutOfBounds2;
 
   std::memset(EffectiveAddress(trusted_data, mem_index, dst), value, size);
-  return kSuccess;
+  return kSuccess2;
 }
 
 namespace {
diff --git a/v8/test/cctest/BUILD.gn b/v8/test/cctest/BUILD.gn
index 8493f6da98..fff88bfcf0 100644
--- a/v8/test/cctest/BUILD.gn
+++ b/v8/test/cctest/BUILD.gn
@@ -216,8 +216,6 @@ v8_source_set("cctest_sources") {
     jumbo_excluded_sources = [
       # TODO(mostynb@opera.com): figure out the jumbo issues with these source
       # files, and include them in jumbo compilation units.
-      "interpreter/bytecode-expectations-printer.cc",
-      "interpreter/test-bytecode-generator.cc",
       "test-api.cc",
     ]
   }
